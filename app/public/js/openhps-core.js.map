{"version":3,"file":"web/openhps-core.js","mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC;AACzC,CAAC;AACD,O;;;;;;;;;;;;;;;;;;;;;;;;ACV0B;AAC0B;AAC2B;AAClB;AAC4C;AACzG;AACA,2CAA2C,aAAa;AACxD;AACA;AACA,oCAAoC,mBAAmB;AACvD;AACA;AACA,YAAY,eAAe;AAC3B;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,eAAe;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA,YAAY,6BAA6B;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,eAAe;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,eAAe;AAC3B,YAAY,6BAA6B;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,eAAe;AAC3B;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA,YAAY,eAAe;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACO,2BAA2B,sEAAY;AAC9C;AACA,cAAc,uEAAU;AACxB;AACA;AACA,8BAA8B,uDAAiB,KAAK,uDAAiB,CAAC,6CAAU;AAChF;AACA,8BAA8B,uDAAiB,KAAK,uDAAiB,CAAC,iDAAc;AACpF;AACA,8BAA8B,qDAAe,KAAK,uDAAiB,CAAC,8CAAQ;AAC5E;AACA,8BAA8B,iDAAW;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,UAAU;AACvB,eAAe,cAAc;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,SAAS;AACtB,aAAa,cAAc;AAC3B,eAAe,cAAc;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,WAAW;AACxB,eAAe,cAAc;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,mCAAmC;AAChD,eAAe,cAAc;AAC7B;AACA;AACA,yBAAyB,uEAAU;AACnC;AACA;AACA;AACA,OAAO;AACP,MAAM;AACN;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,MAAM,oFAAuB;AAC7B;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;;;;;;;;;;;;;;;;;AC3MwC;AACV;AACM;AAC7B;AACP;AACA;AACA;AACA;AACA;AACA,WAAW,2DAAwB;AACnC;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,WAAW,6DAA0B;AACrC;AACA,+BAA+B,4CAAY;AAC3C;AACA;AACA,oBAAoB,qBAAa;AACjC;AACA;AACA;AACA;AACA;AACA,0DAA0D,uCAAI;AAC9D;AACA;AACA,SAAS;AACT,QAAQ,yDAAyD,6CAAO;AACxE;AACA;AACA,SAAS;AACT;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,uCAAuC,8DAA2B;AAClE,iCAAiC,8DAA2B;AAC5D;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;AC1D+C;AACS;AACQ;AAChE;AACA,2CAA2C;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,kBAAkB;AAC9B;AACA;AACA;AACA;AACA;AACA,uCAAuC,kBAAkB,KAAK,gBAAgB;AAC9E;AACA;AACA;AACA;AACA,8BAA8B,gEAAS;AACvC;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,aAAa;AAC1B,eAAe,MAAM;AACrB;AACA;AACA,iDAAiD;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,aAAa;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA,iDAAU,EAAE,yDAAkB,IAAI,iDAAU;AAC5C,OAAO,iDAAU,EAAE,yDAAkB,IAAI,iDAAU;;;;;;;;;;;;;;;;;AC5Db;AACtC;AACA;AACA;AACA;AACO,gCAAgC,gDAAY;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;;;;;;;;;;;;;;;;;;;;;;ACtBA;AAC+C;AACX;AACa;AAC4C;AACxC;AACH;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,kBAAkB;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D,iBAAiB;AAChF;AACA;AACA,YAAY,yDAAyD;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,iBAAiB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,gDAAM;AACrB;AACA,4BAA4B,iEAAe;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM,yBAAyB,0DAAU;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,YAAY;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,YAAY;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,qBAAqB;AAClC,aAAa,QAAQ;AACrB,eAAe,cAAc;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,mBAAmB;AAChC,eAAe,cAAc;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,MAAM;AACN;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,eAAe,YAAY;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,YAAY;AACzB,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,YAAY;AACzB,eAAe,WAAW;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,cAAc;AAC3B,eAAe,WAAW;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,gBAAgB;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,YAAY;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,WAAW;AAC1B;AACA;AACA,WAAW,iEAAoB;AAC/B;AACA;AACA,iDAAU,EAAE,+DAAkB;AAC9B;AACA,CAAC,GAAG,iDAAU;AACd,iDAAU,EAAE,+DAAkB;AAC9B;AACA,CAAC,GAAG,iDAAU;AACd,iDAAU,EAAE,+DAAkB;AAC9B;AACA,CAAC,GAAG,iDAAU;AACd,iDAAU,EAAE,+DAAkB;AAC9B;AACA,CAAC,GAAG,iDAAU;AACd,iDAAU,EAAE,kEAAqB,SAAS,0DAAU;AACpD;AACA,CAAC,GAAG,iDAAU;AACd,0BAA0B,iDAAU,EAAE,+DAAkB,IAAI,iDAAU;;;;;;;;;;;;;;;;;;;;;AChMtE;AACsC;AACS;AACa;AACd;AACJ;AAC1C,4EAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,gFAA8B;AACpF;AACA,yBAAyB,gFAA8B;AACvD,IAAI;AACJ;AACA;AACA;AACA;AACA,eAAe,4EAAqC;AACpD;AACA;AACA;AACA;AACA;AACA;AACA,MAAM,qFAAiD;AACvD,8BAA8B,yDAAkB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA,sEAAsE,0BAA0B;AAChG;AACA;AACA;AACA;AACA,iDAAiD,0BAA0B;AAC3E;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,aAAa,YAAY;AACzB,aAAa,sBAAsB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA,mCAAmC,yDAAkB;AACrD;AACA,uBAAuB,gFAA8B;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB,WAAW;AACX,aAAa,KAAK;AAClB,eAAe,gBAAgB;AAC/B;AACA;AACA,WAAW,iFAA+B;AAC1C;AACA;AACA;AACA;AACA,sBAAsB;AACtB,WAAW;AACX,aAAa,KAAK;AAClB,eAAe,gBAAgB;AAC/B;AACA;AACA,WAAW,qFAAmC;AAC9C;AACA;AACA;AACA;AACA,sBAAsB;AACtB,aAAa,KAAK;AAClB,eAAe,gBAAgB;AAC/B;AACA;AACA,WAAW,qFAAmC;AAC9C;AACA;AACA;AACA;AACA,aAAa,YAAY;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,KAAK;AAClB,eAAe,KAAK;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,KAAK;AAClB,aAAa,sBAAsB;AACnC,eAAe,KAAK;AACpB;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,0FAAwC;AACvF;AACA,0DAA0D;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,0FAAwC;AACnG;AACA;AACA;AACA;AACA,gCAAgC,mDAAU;AAC1C,kCAAkC,uDAAY;AAC9C;AACA,kCAAkC,gDAAY;AAC9C;AACA;AACA,wDAAwD;AACxD;AACA;AACA;AACA;AACA,UAAU;AACV;AACA,KAAK,iDAAiD,YAAY;AAClE;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,iDAAiD,YAAY;AAClE,GAAG;AACH,CAAC;;;;;;;;;;;;;;;;;AChM8C;AAC/C;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,aAAa,KAAK;AAClB,eAAe,gBAAgB;AAC/B;AACA;AACA,WAAW,4EAAqC;AAChD;AACA;AACA;AACA;AACA,WAAW;AACX,aAAa,KAAK;AAClB,eAAe,gBAAgB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,aAAa,KAAK;AAClB,eAAe,gBAAgB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,aAAa;AAC1B,aAAa,QAAQ;AACrB,eAAe,2BAA2B;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,aAAa;AAC1B,eAAe,2BAA2B;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;AChGmF;AAC5E,2BAA2B,yEAAgB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACpB6E;AACtE,yBAAyB,qEAAc;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACpB4C;AAC2B;AACvE;AACA,WAAW,mBAAmB;AAC9B,WAAW,gCAAgC;AAC3C,aAAa,mBAAmB;AAChC;AACO;AACP;AACA,yBAAyB,0DAAkB;AAC3C,IAAI,0DAAe;AACnB,IAAI,gEAAwB;AAC5B;AACA;;;;;;;;;;;;;;;;ACb0C;AAC6B;AACvE;AACA,WAAW,mBAAmB;AAC9B,WAAW,mBAAmB;AAC9B,WAAW,8BAA8B;AACzC,aAAa,mBAAmB;AAChC;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,yBAAyB,0DAAkB;AAC3C,IAAI,wDAAa;AACjB,IAAI,gEAAwB;AAC5B;AACA;;;;;;;;;;;;;;;;;;AC/B0B;AACa;AACgC;AACvE;AACA,WAAW,2BAA2B;AACtC,aAAa,mBAAmB;AAChC;AACO;AACP;AACA,yBAAyB,0DAAkB;AAC3C,IAAI,qDAAU;AACd,IAAI,gEAAwB;AAC5B;AACA;;;;;;;;;;;;;;;;ACb0D;AACa;AACvE;AACA,WAAW,2BAA2B;AACtC,aAAa,mBAAmB;AAChC;AACO,gDAAgD;AACvD;AACA;AACA;AACA,yBAAyB,0DAAkB;AAC3C,IAAI,uEAAkB;AACtB,IAAI,gEAAwB;AAC5B;AACA;;;;;;;;;;;;;;;;;ACduC;AACY;AACA;AACnD;AACA;AACA;AACA,WAAW,2BAA2B;AACtC,aAAa,gBAAgB;AAC7B;AACO;AACP;AACA,IAAI,qDAAU;AACd,IAAI,6EAAmC;AACvC,IAAI,gEAAwB;AAC5B;AACA;;;;;;;;;;;;;;;;ACf0C;AAC6B;AACvE;AACA,WAAW,aAAa;AACxB,WAAW,8BAA8B;AACzC,aAAa,mBAAmB;AAChC;AACO;AACP;AACA,yBAAyB,0DAAkB;AAC3C,IAAI,wDAAa;AACjB,IAAI,gEAAwB;AAC5B;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;ACbqC;AACA;AACK;AACF;AACA;AACK;;;;;;;;;;;;;;;ACLtC;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,gCAAgC;;;;;;;;;;;;;;;;;;;;ACRoB;AACF;AACU;AAC7D;AACA,kBAAkB,mBAAO,CAAC,kEAAkB;AAC5C;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,aAAa;AACxB,WAAW,KAAK;AAChB;AACO;AACP;AACA;AACA;AACA,oBAAoB,kFAA2C;AAC/D,qBAAqB,qFAAmC;AACxD;AACA;AACA;AACA,2DAA2D,OAAO;AAClE;AACA,8GAA8G;AAC9G;AACA,iHAAiH;AACjH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,iFAA+B,8CAA8C,kFAA2C;AACtJ;AACA;AACA,oHAAoH;AACpH;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,iBAAiB,kFAA2C;AAC5D;AACA,2CAA2C,qEAAwB;AACnE,iDAAiD,uEAA0B;AAC3E,iCAAiC,2CAAI;AACrC;AACA;AACA;AACA;AACA;AACA,WAAW,cAAc;AACzB,WAAW,2BAA2B;AACtC;AACO;AACP;AACA,kBAAkB,iFAA+B;AACjD,mBAAmB,qFAAmC;AACtD;AACA;AACA;AACA;AACA;AACA;AACA,kHAAkH,qHAAqH;AACvO;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,iFAA+B;AACvD,8FAA8F;AAC9F;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,iFAA+B;AACrD;AACA;AACA;AACA,GAAG;AACH;AACA,EAAE,wEAA2B;AAC7B;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB,WAAW,QAAQ;AACnB,WAAW,KAAK;AAChB,aAAa,KAAK;AAClB;AACO;AACP;AACA;AACA;AACA;AACA,8BAA8B,sFAAoC;AAClE;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,aAAa,KAAK;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,SAAS,EAAE;AACX,QAAQ;AACR;AACA;AACA,SAAS;AACT;AACA,KAAK;AACL;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACjJ4B;AACH;AACE;AACE;AACJ;AACQ;AACJ;AACE;;;;;;;;;;;;;;;;;;;;;;;;;;;ACP/B;AAC+C;AACiB;AACA;AAC4C;AACxE;AACe;AACK;AAClB;AACtC;AACA;AACA,2DAA2D,qBAAqB;AAChF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wEAAwE,wBAAwB;AAChG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB;AACA,oBAAoB,gDAAM;AAC1B;AACA;AACA,4BAA4B,iEAAe;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,kBAAkB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,qBAAqB;AAClC,eAAe,kBAAkB;AACjC;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,kBAAkB;AAC/B,aAAa,qBAAqB;AAClC,eAAe,YAAY;AAC3B;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,eAAe,YAAY;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,oBAAoB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,aAAa,iCAAiC;AAC9C,eAAe,YAAY;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,kBAAkB;AAC/B,eAAe,YAAY;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,eAAe,oBAAoB;AACnC;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB,eAAe,kBAAkB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,iCAAiC;AAC9C,eAAe,+BAA+B;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,YAAY;AAC3B;AACA;AACA,WAAW,iEAAoB;AAC/B;AACA;AACA,iDAAU,EAAE,+DAAkB,IAAI,iDAAU;AAC5C,iDAAU,EAAE,+DAAkB;AAC9B;AACA,cAAc,wDAAe;AAC7B,CAAC,GAAG,iDAAU;AACd,iDAAU,EAAE,+DAAkB;AAC9B;AACA,CAAC,GAAG,iDAAU;AACd,iDAAU,EAAE,+DAAkB,IAAI,iDAAU;AAC5C,iDAAU,EAAE,+DAAkB,IAAI,iDAAU,gBAAgB,wEAAgB,GAAG,iDAAU,uBAAuB,wEAAgB;AAChI,iDAAU,EAAE,oEAAuB,CAAC,wEAAgB,GAAG,iDAAU,wBAAwB,iDAAU;AACnG,4BAA4B,iDAAU,EAAE,gEAAkB,IAAI,iDAAU;AAClD;AACtB,gCAAgC,gDAAY;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,qBAAqB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,eAAe;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;AC9P+C;AACwB;AAC7B;AACF;AACE;AAC1C;AACA,yBAAyB,kBAAkB;AAC3C;AACA;AACA;AACA,2BAA2B,mDAAU;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA,iCAAiC,gDAAW,0BAA0B,kDAAW;AACjF;AACA;AACA,iDAAU,EAAE,+DAAkB,IAAI,iDAAU;AAC5C,iDAAU,EAAE,+DAAkB,IAAI,iDAAU;AAC5C,eAAe,iDAAU,EAAE,+DAAkB;AAC7C;AACA,EAAE,iDAAU;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC7BiB;AACL;AACO;;;;;;;;;;;;;;;;;;;ACFgB;AACO;AACT;AACE;AAC/C;AACA;AACA;AACA;AACA;AACA,wEAAwE,uDAAY;AACpF;AACA,gEAAgE,kDAAW;AAC3E;AACA;AACA,4BAA4B,iDAAU,EAAE,+DAAkB,IAAI,iDAAU,+BAA+B,kDAAW;;;;;;;;;;;;;;;;;;;ACdnE;AACO;AACV;AACG;AAC/C;AACA;AACA;AACA;AACA;AACA,gDAAgD,uDAAY;AAC5D;AACA,gEAAgE,iDAAY;AAC5E;AACA;AACA,gBAAgB,iDAAU,EAAE,+DAAkB,IAAI,iDAAU,+BAA+B,iDAAY;;;;;;;;;;;;;;;;;;;ACdxD;AACO;AACV;AACG;AAC/C;AACA;AACA;AACA;AACA;AACA,gDAAgD,uDAAY;AAC5D;AACA,gEAAgE,iDAAY;AAC5E;AACA;AACA,gBAAgB,iDAAU,EAAE,+DAAkB,IAAI,iDAAU,+BAA+B,iDAAY;;;;;;;;;;;;;;;;;;;ACdxD;AACO;AACP;AACA;AAC/C;AACA;AACA;AACA;AACA;AACA,wCAAwC,uDAAY;AACpD;AACA,gEAAgE,oDAAe;AAC/E;AACA;AACA,YAAY,iDAAU,EAAE,+DAAkB,IAAI,iDAAU,+BAA+B,oDAAe;;;;;;;;;;;;;;;;;;;ACdvD;AACO;AACV;AACG;AAC/C;AACA;AACA;AACA;AACA;AACA,sEAAsE,uDAAY;AAClF;AACA,gEAAgE,iDAAY;AAC5E;AACA;AACA,2BAA2B,iDAAU,EAAE,+DAAkB,IAAI,iDAAU,+BAA+B,iDAAY;;;;;;;;;;;;;;;;;;;ACdnE;AACO;AACR;AACC;AAC/C;AACA;AACA;AACA;AACA;AACA,8DAA8D,uDAAY;AAC1E;AACA,gEAAgE,mDAAc;AAC9E;AACA;AACA,uBAAuB,iDAAU,EAAE,+DAAkB,IAAI,iDAAU,+BAA+B,mDAAc;;;;;;;;;;;;;;;;;;;ACdjE;AACO;AACb;AACM;AAC/C;AACA;AACA;AACA;AACA;AACA,8CAA8C,uDAAY;AAC1D;AACA,gEAAgE,8CAAS;AACzE;AACA;AACA,eAAe,iDAAU,EAAE,+DAAkB,IAAI,iDAAU,+BAA+B,8CAAS;;;;;;;;;;;;;;;;;;;ACdpD;AACO;AACT;AACE;AAC/C;AACA;AACA;AACA;AACA;AACA,wEAAwE,uDAAY;AACpF;AACA,gEAAgE,kDAAW;AAC3E;AACA;AACA,4BAA4B,iDAAU,EAAE,+DAAkB,IAAI,iDAAU,+BAA+B,kDAAW;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACdlF;AACA;AACJ;AACe;AACC;AACA;AACb;;;;;;;;;;;;;;;;;;;;;;;;;ACNgB;AACJ;AAC+B;AACW;AACzC;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,mDAAU;AAC5D;AACA;AACA;AACA,4BAA4B,gDAAO;AACnC,qCAAqC,gDAAO;AAC5C,kCAAkC,gDAAO;AACzC,yBAAyB,mDAAU;AACnC;AACA;AACA;AACA;AACA,aAAa,qBAAqB;AAClC;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,iCAAiC;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,aAAa;AAC1B,eAAe,eAAe;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wEAAwE,eAAe;AACvF;AACA;AACA,SAAS;AACT,QAAQ;AACR;AACA;AACA,KAAK;AACL;AACA;AACA,4CAA4C,gDAAO;AACnD;AACA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB,eAAe,gBAAgB;AAC/B;AACA;AACA,4CAA4C,gDAAO;AACnD;AACA;AACA;AACA;AACA,4BAA4B,gDAAO;AACnC,yBAAyB,mDAAU;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,gDAAO;AAChD;AACA;AACA;AACA;AACA,4BAA4B,gDAAO;AACnC;AACA;AACA;AACA;AACA,qBAAqB,mDAAU;AAC/B;AACA;AACA,MAAM,sBAAsB,8CAAK;AACjC,uBAAuB,6DAAoB;AAC3C;AACA,MAAM,sBAAsB,kDAAS;AACrC,uBAAuB,iEAAwB;AAC/C;AACA,MAAM;AACN,uBAAuB,6DAAoB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,kBAAkB;AAC/B,aAAa,4BAA4B;AACzC,eAAe,kBAAkB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kEAAkE,uEAA8B;AAChG;AACA,gCAAgC,gDAAO;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAU,EAAE,+DAAkB;AAC9B;AACA,CAAC,GAAG,iDAAU,gBAAgB,gDAAO;AACrC,iDAAU,EAAE,+DAAkB;AAC9B;AACA,CAAC,GAAG,iDAAU,gBAAgB,gDAAO;AACrC,iDAAU,EAAE,+DAAkB;AAC9B;AACA,CAAC,GAAG,iDAAU,gBAAgB,gDAAO;AACrC,iDAAU,EAAE,+DAAkB;AAC9B;AACA,CAAC,GAAG,iDAAU,gBAAgB,mDAAU;AACxC,iDAAU,EAAE,+DAAkB;AAC9B;AACA,CAAC,GAAG,iDAAU,gBAAgB,8CAAU;AACxC,iBAAiB,iDAAU,EAAE,+DAAkB,IAAI,iDAAU;;;;;;;;;;;;;;;;ACxM5B;;;;;;;;;;;;;;;;;;;;;;ACAc;AACO;AAC6B;AAC1C;AACE;AAC3C;AACA,sDAAsD,cAAc;AACpE;AACA;AACA;AACA;AACA,0DAA0D,+DAAgB;AAC1E,2BAA2B,oDAAgB;AAC3C;AACA,sBAAsB,gDAAO;AAC7B,4CAA4C,oDAAgB;AAC5D,4CAA4C,oDAAgB;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,oBAAoB;AACjC,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,gDAAO;AACxB,MAAM;AACN,iBAAiB,gDAAO;AACxB;AACA;AACA;AACA;AACA;AACA,eAAe,oBAAoB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAU,EAAE,+DAAkB;AAC9B,cAAc,2DAAkB;AAChC,CAAC,GAAG,iDAAU,yBAAyB,iDAAU;AACjD,iDAAU,EAAE,+DAAkB;AAC9B,cAAc,2DAAkB;AAChC,CAAC,GAAG,iDAAU,yBAAyB,iDAAU;AACjD,qBAAqB,iDAAU,EAAE,+DAAkB,IAAI,iDAAU,uCAAuC,8CAAU;;;;;;;;;;;;;;;;;;;;;;ACtFnE;AACoC;AACjC;AACQ;AAC1D;AACA,sDAAsD,cAAc;AACpE;AACA;AACA;AACA;AACA,0DAA0D,mEAAkB;AAC5E,8BAA8B,oDAAgB;AAC9C;AACA,4CAA4C,oDAAgB;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,2CAAO;AACxB,MAAM;AACN,iBAAiB,2CAAO;AACxB;AACA;AACA;AACA;AACA;AACA,eAAe,oBAAoB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAU,EAAE,+DAAkB;AAC9B,cAAc,2DAAkB;AAChC,CAAC,GAAG,iDAAU,yBAAyB,iDAAU;AACjD,qBAAqB,iDAAU,EAAE,+DAAkB,IAAI,iDAAU,+CAA+C,8CAAU;;;;;;;;;;;;;;;;;;;;;;;;;AC9D3E;AACD;AACA;AACF;AAC2B;AACf;AACV;AACI;AACV;AACxC;AACA,8BAA8B,iBAAiB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,iEAAe;AACpC;AACA;AACA;AACA,wBAAwB,sDAAQ;AAChC;AACA;AACA;AACA,gBAAgB,yDAAgB;AAChC;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,uBAAuB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,UAAU;AACzB;AACA;AACA;AACA,2BAA2B,0DAAU;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,gBAAgB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,sDAAQ;AAClC;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,iBAAiB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,sDAAQ;AAClC;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,mBAAmB;AAChC,aAAa,MAAM;AACnB,eAAe,kBAAkB;AACjC;AACA;AACA;AACA,0BAA0B,0DAAU;AACpC,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,kBAAkB;AAC/B,aAAa,YAAY;AACzB,eAAe,QAAQ;AACvB;AACA,6CAA6C,6CAAS;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,kBAAkB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAU,EAAE,+DAAkB;AAC9B;AACA,CAAC,GAAG,iDAAU;AACd,iDAAU,EAAE,+DAAkB,IAAI,iDAAU,gBAAgB,sDAAQ;AACpE,iDAAU,EAAE,+DAAkB,IAAI,iDAAU,gBAAgB,qDAAW;AACvE,iDAAU,EAAE,+DAAkB,IAAI,iDAAU,gBAAgB,mDAAU;AACtE,iDAAU,EAAE,+DAAkB;AAC9B;AACA,CAAC,GAAG,iDAAU;AACd,iDAAU,EAAE,+DAAkB;AAC9B;AACA,CAAC,GAAG,iDAAU,gBAAgB,sDAAQ;AACtC,iDAAU,EAAE,+DAAkB;AAC9B;AACA,CAAC,GAAG,iDAAU;AACd,mBAAmB,iDAAU,EAAE,+DAAkB;;;;;;;;;;;;;;;;;;;;;;;;;AClKjD;AAC+C;AACQ;AACE;AAC0B;AACzB;AACJ;AACtD;AACA;AACA;AACA;AACA;AACA,uFAAuF,mEAAkB;AACzG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,sBAAsB;AACnC,eAAe,QAAQ;AACvB;AACA;AACA,yCAAyC,6CAAS;AAClD;AACA;AACA;AACA;AACA,aAAa,sBAAsB;AACnC,eAAe,QAAQ;AACvB;AACA;AACA,WAAW,2EAAwB,4BAA4B,mEAAgB;AAC/E;AACA;AACA;AACA;AACA,aAAa,sBAAsB;AACnC,eAAe,QAAQ;AACvB;AACA;AACA,oBAAoB,2EAAwB,iBAAiB,mEAAgB;AAC7E,oBAAoB,2EAAwB,gBAAgB,mEAAgB;AAC5E,oBAAoB,2EAAwB,wBAAwB,mEAAgB;AACpF,oBAAoB,2EAAwB,uBAAuB,mEAAgB;AACnF;AACA;AACA;AACA;AACA,+CAA+C,mEAAgB,iBAAiB,oEAAgB;AAChG,8CAA8C,oEAAgB;AAC9D,8CAA8C,mEAAgB;AAC9D,wDAAwD,mEAAgB;AACxE,uDAAuD,mEAAgB;AACvE,mEAAmE,yDAAqB,4CAA4C,yDAAqB;AACzJ,2EAA2E,yDAAqB,2CAA2C,yDAAqB;AAChK;AACA,wBAAwB,2EAAwB,OAAO,mEAAgB;AACvE,yBAAyB,2EAAwB,OAAO,mEAAgB;AACxE;AACA;AACA;AACA;AACA,4BAA4B,6CAAS;AACrC;AACA,wBAAwB,8DAAU;AAClC,kBAAkB,oDAAgB,KAAK,2CAAO,wBAAwB,oEAAgB,0BAA0B,oEAAgB,0BAA0B,oEAAgB,IAAI,6CAAS;AACvL,MAAM,yBAAyB,uCAAG;AAClC,uCAAuC,6CAAS;AAChD;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,6CAAS;AAC5B,wBAAwB,uCAAG;AAC3B,aAAa,qDAAiB,KAAK,2CAAO;AAC1C,MAAM,yBAAyB,8DAAU;AACzC,aAAa,qDAAiB,KAAK,2CAAO,CAAC,4EAAwB,gBAAgB,4EAAwB,gBAAgB,4EAAwB,iBAAiB,4CAAQ;AAC5K;AACA;AACA;AACA;AACA;AACA,eAAe,sBAAsB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAU,EAAE,+DAAkB;AAC9B,cAAc,2DAAkB;AAChC,CAAC,GAAG,iDAAU,yBAAyB,iDAAU;AACjD,iDAAU,EAAE,+DAAkB;AAC9B,cAAc,2DAAkB;AAChC,CAAC,GAAG,iDAAU,yBAAyB,iDAAU;AACjD,iDAAU,EAAE,+DAAkB;AAC9B,cAAc,2DAAkB;AAChC,CAAC,GAAG,iDAAU,yBAAyB,iDAAU;AACjD,gDAAgD,iDAAU,EAAE,+DAAkB,IAAI,iDAAU;;;;;;;;;;;;;;;;;;;;;;;;AC5I5F;AAC+C;AACD;AACqC;AAC3B;AACV;AACN;AACU;AAClD;AACA;AACA;AACA;AACA;AACA,4DAA4D,mDAAU;AACtE;AACA;AACA,oCAAoC,0DAAU,IAAI,oDAAgB;AAClE,qBAAqB,iEAAe;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAU,EAAE,+DAAkB;AAC9B;AACA,cAAc,wDAAe;AAC7B,CAAC,GAAG,iDAAU;AACd,iDAAU,EAAE,+DAAkB;AAC9B;AACA,CAAC,GAAG,iDAAU,gBAAgB,sDAAQ;AACtC,8BAA8B,iDAAU,EAAE,+DAAkB,IAAI,iDAAU,uDAAuD,sDAAQ;;;;;;;;;;;;;;;;;;;;;;;;;ACpC1F;AACS;AACf;AACG;AAC2B;AACzB;AACI;AACQ;AACd;AAC5C;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,8BAA8B,iDAAO;AACrC;AACA;AACA;AACA;AACA;AACA,qBAAqB,iEAAe;AACpC;AACA;AACA;AACA,gBAAgB,oDAAgB;AAChC;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,uBAAuB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,UAAU;AACzB;AACA;AACA;AACA,2BAA2B,0DAAU;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,SAAS;AACtB,eAAe,MAAM;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,oBAAoB;AACjC,eAAe,MAAM;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,aAAa;AAC5B;AACA;AACA;AACA,wBAAwB,wEAA8B;AACtD;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,oBAAoB;AACnC;AACA;AACA;AACA,yBAAyB,mEAAkB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAU,EAAE,+DAAkB;AAC9B;AACA,CAAC,GAAG,iDAAU;AACd,iDAAU,EAAE,+DAAkB,IAAI,iDAAU,gBAAgB,8CAAU;AACtE,iDAAU,EAAE,+DAAkB;AAC9B;AACA,CAAC,GAAG,iDAAU,gBAAgB,sDAAQ;AACtC,iDAAU,EAAE,+DAAkB,IAAI,iDAAU,yBAAyB,iDAAU;AAC/E,OAAO,iDAAU,EAAE,+DAAkB;;;;;;;;;;;;;;;;;;;;;AC1HU;AACP;AAC+B;AAC3B;AACU;AACtD;AACA;AACA;AACA;AACA;AACA,gDAAgD,+DAAgB;AAChE;AACA,+CAA+C,oDAAgB;AAC/D;AACA;AACA;AACA,2BAA2B,qDAAW;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAU,EAAE,+DAAkB,IAAI,iDAAU,gBAAgB,qDAAW;AACvE,iDAAU,EAAE,+DAAkB,IAAI,iDAAU,gBAAgB,6CAAS;AACrE,gBAAgB,iDAAU,EAAE,+DAAkB,IAAI,iDAAU,uCAAuC,6CAAS,EAAE,qDAAW;;;;;;;;;;;;;;;;;;;;ACpC1E;AACO;AACH;AACP;AACM;AAClD;AACA;AACA;AACA;AACA;AACA,oEAAoE,+DAAgB;AACpF;AACA,qCAAqC,yEAAqC;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,iDAAU,EAAE,+DAAkB,IAAI,iDAAU,+BAA+B,oDAAe;;;;;;;;;;;;;;;;;;;;ACrBrE;AACN;AAC8B;AACjB;AACtD;AACA;AACA;AACA;AACA;AACA,sDAAsD,+DAAgB;AACtE;AACA,qCAAqC,oDAAgB;AACrD;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAU,EAAE,+DAAkB,IAAI,iDAAU,gBAAgB,8CAAU;AACtE,mBAAmB,iDAAU,EAAE,+DAAkB,IAAI,iDAAU,uCAAuC,8CAAU;;;;;;;;;;;;;;;;;;;;AC3BjE;AACO;AACH;AACR;AACM;AACjD;AACA;AACA;AACA;AACA;AACA,kEAAkE,+DAAgB;AAClF;AACA,qCAAqC,uEAAmC;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,iDAAU,EAAE,+DAAkB,IAAI,iDAAU,+BAA+B,mDAAc;;;;;;;;;;;;;;;;;;;;;;;ACrBnE;AACS;AACrB;AACgB;AACoB;AACzB;AACI;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,iEAAe;AACpC;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA,gCAAgC,gDAAY;AAC5C;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,uBAAuB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,UAAU;AACzB;AACA;AACA;AACA,2BAA2B,0DAAU;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,mBAAmB;AAChC,aAAa,MAAM;AACnB,eAAe,kBAAkB;AACjC;AACA;AACA;AACA,0BAA0B,0DAAU;AACpC,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,kBAAkB;AACjC;AACA;AACA,WAAW,iEAAoB;AAC/B;AACA;AACA,iDAAU,EAAE,+DAAkB;AAC9B;AACA,CAAC,GAAG,iDAAU;AACd,iDAAU,EAAE,+DAAkB,IAAI,iDAAU;AAC5C,iDAAU,EAAE,+DAAkB,IAAI,iDAAU;AAC5C,iDAAU,EAAE,+DAAkB,IAAI,iDAAU;AAC5C,iDAAU,EAAE,+DAAkB;AAC9B;AACA,CAAC,GAAG,iDAAU,gBAAgB,sDAAQ;AACtC,iDAAU,EAAE,+DAAkB;AAC9B;AACA,CAAC,GAAG,iDAAU;AACd,mBAAmB,iDAAU,EAAE,+DAAkB,IAAI,iDAAU;;;;;;;;;;;;;;;;;;;;;;ACtGhB;AACiD;AAC5D;AACkB;AACE;AACxD;AACA;AACA,eAAe,gDAAM;AACrB;AACA;AACA,4BAA4B,iEAAe;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAU,EAAE,+DAAkB;AAC9B;AACA,CAAC,GAAG,iDAAU;AACd,iDAAU,EAAE,+DAAkB;AAC9B;AACA,CAAC,GAAG,iDAAU;AACd,iDAAU,EAAE,oEAAuB,CAAC,+DAAgB,GAAG,iDAAU;AACjE,iDAAU,EAAE,+DAAkB;AAC9B;AACA,CAAC,GAAG,iDAAU;AACd,aAAa,iDAAU,EAAE,+DAAkB,IAAI,iDAAU;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC/B9B;AACQ;AACA;AACI;AACF;AACA;AACL;AACG;AACO;AACD;AACX;AACD;;;;;;;;;;;;;;;;;;;ACXkB;AACA;AACI;AACP;AAC5C;AACA;AACA;AACA;AACA;AACA,8CAA8C,qDAAW;AACzD,0CAA0C,4EAAwC;AAClF,yBAAyB,4EAAwC;AACjE;AACA;AACA,eAAe,iDAAU,EAAE,+DAAkB,IAAI,iDAAU;;;;;;;;;;;;;;;;;;;ACdZ;AACI;AACoB;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,MAAM;AACnB,eAAe,UAAU;AACzB;AACA;AACA;AACA,yBAAyB,uBAAuB;AAChD;AACA;AACA,2BAA2B,wDAAO;AAClC,yBAAyB,uBAAuB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,MAAM;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAU,EAAE,+DAAkB,IAAI,iDAAU;AAC5C,iDAAU,EAAE,+DAAkB;AAC9B;AACA,CAAC,GAAG,iDAAU;AACd,WAAW,iDAAU,EAAE,+DAAkB,IAAI,iDAAU;;;;;;;;;;;;;;;;;;AC5CR;AACI;AACb;AACtC,0CAA0C,+CAAQ;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,iDAAU,EAAE,+DAAkB,IAAI,iDAAU;;;;;;;;;;;;;;;;;;;ACdV;AACH;AACO;AACb;AACtC,0CAA0C,+CAAQ;AAClD;AACA,cAAc,iDAAO;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,MAAM;AACnB,eAAe,YAAY;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,iDAAU,EAAE,+DAAkB,IAAI,iDAAU;;;;;;;;;;;;;;;;;;ACzCV;AACI;AACT;AAC1C,0CAA0C,mDAAU;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,MAAM;AACnB,eAAe,YAAY;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,iDAAU,EAAE,+DAAkB,IAAI,iDAAU;;;;;;;;;;;;;;;;;;;AC7BV;AAC4B;AACxB;AACP;AAC5C;AACA;AACA;AACA,oDAAoD,qDAAW;AAC/D,8BAA8B,kGAAqC;AACnE,yBAAyB,kGAAqC;AAC9D;AACA,iCAAiC,kGAAqC;AACtE;AACA;AACA;AACA,kBAAkB,iDAAU,EAAE,+DAAkB,IAAI,iDAAU;;;;;;;;;;;;;;;;;;ACff;AACH;AACO;AACnD,sCAAsC,qDAAW;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,iDAAU,EAAE,+DAAkB,IAAI,iDAAU;;;;;;;;;;;;;;;;;;;ACdR;AACI;AACF;AACL;AAC5C;AACA;AACA;AACA,kDAAkD,qDAAW;AAC7D,8BAA8B,uEAAmC;AACjE,yBAAyB,uEAAmC;AAC5D;AACA,iCAAiC,uEAAmC;AACpE;AACA;AACA;AACA,iBAAiB,iDAAU,EAAE,+DAAkB,IAAI,iDAAU;;;;;;;;;;;;;;;;;;;ACfd;AACI;AACP;AACA;AAC5C;AACA;AACA;AACA,wCAAwC,qDAAW;AACnD,8BAA8B,4DAAwB;AACtD,yBAAyB,4DAAwB;AACjD;AACA;AACA,YAAY,iDAAU,EAAE,+DAAkB,IAAI,iDAAU;;;;;;;;;;;;;;;;;;;ACZT;AACH;AACO;AACH;AAChD,sCAAsC,qDAAW;AACjD,gCAAgC,4DAAmB;AACnD,6CAA6C,4DAAmB;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,iDAAU,EAAE,+DAAkB,IAAI,iDAAU;;;;;;;;;;;;;;;;;;;;;;;;ACfR;AACS;AACrB;AACQ;AACwC;AAC7C;AACI;AAC1C;AACA;AACA;AACA,4CAA4C,gDAAO;AACnD;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,4HAA4H,gDAAY;AACxI,qBAAqB,iEAAe;AACpC,oCAAoC,mDAAU,yBAAyB,gDAAY;AACnF;AACA;AACA;AACA;AACA,aAAa,mBAAmB;AAChC,eAAe,aAAa;AAC5B;AACA;AACA;AACA,0BAA0B,mDAAU;AACpC,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAU,EAAE,+DAAkB;AAC9B;AACA,cAAc,wDAAe;AAC7B,CAAC,GAAG,iDAAU;AACd,iDAAU,EAAE,+DAAkB;AAC9B;AACA,CAAC,GAAG,iDAAU,gBAAgB,+CAAQ;AACtC,iDAAU,EAAE,+DAAkB,IAAI,iDAAU;AAC5C,cAAc,iDAAU,EAAE,+DAAkB,IAAI,iDAAU,+CAA+C,wCAAI,UAAU,+CAAQ;;;;;;;;;;;;;;;;;;;ACpDhF;AACI;AACA;AACP;AAC5C;AACA;AACA;AACA,4CAA4C,qDAAW;AACvD,gCAAgC,gEAAuB;AACvD,6CAA6C,gEAAuB;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,iDAAU,EAAE,+DAAkB,IAAI,iDAAU;;;;;;;;;;;;;;;;;;;;AClBX;AACwB;AACnB;AACF;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,UAAU;AACzB;AACA;AACA;AACA;AACA;AACA,iDAAU,EAAE,+DAAkB,IAAI,iDAAU,gBAAgB,2DAAc;AAC1E,iDAAU,EAAE,+DAAkB,IAAI,iDAAU,gBAAgB,6DAAe;AAC3E,WAAW,iDAAU,EAAE,+DAAkB,IAAI,iDAAU,uBAAuB,2DAAc,EAAE,6DAAe;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACzBlF;AACO;AACD;AACF;AACH;AACE;AACA;AACH;AACA;AACA;AACE;AACA;;;;;;;;;;;;;;;;;;ACXQ;AACC;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,mBAAmB,gDAAY;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,yBAAyB;AACtC,aAAa,aAAa;AAC1B,eAAe,eAAe;AAC9B;AACA,yBAAyB;AACzB;AACA,uDAAuD;AACvD;AACA,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,6CAA6C,8CAAS;AACtD,WAAW;AACX,UAAU;AACV,2CAA2C,8CAAS;AACpD;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA,aAAa,aAAa;AAC1B,eAAe,eAAe;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;AC3E+C;AACX;AAC2C;AACT;AACtE,wCAAwC,0EAAiB;AACzD;AACA;AACA;AACA;AACA;AACA,eAAe,gDAAM;AACrB;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB,aAAa,KAAK;AAClB;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,0BAA0B;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,yBAAyB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,aAAa;AAC1B,eAAe,eAAe;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA,aAAa,yBAAyB;AACtC,aAAa,aAAa;AAC1B,eAAe,eAAe;AAC9B;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,SAAS;AACT;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAU,EAAE,oEAAkB,IAAI,iDAAU;AAC5C,iDAAU,EAAE,oEAAkB,IAAI,iDAAU;AAC5C,YAAY,iDAAU,EAAE,oEAAkB,IAAI,iDAAU;;;;;;;;;;;;;;;;;;;;;;;ACtKT;AACN;AAC2B;AAClC;AACG;AACoE;AACzG;AACA;AACA;AACA,0CAA0C,uCAAI;AAC9C;AACA;AACA;AACA;AACA,8BAA8B,sEAAa;AAC3C,4BAA4B,sEAAa;AACzC;AACA;AACA;AACA,iBAAiB,sDAAsD;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB,eAAe,WAAW;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,aAAa;AAC1B,eAAe,eAAe;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,yBAAyB;AACtC,aAAa,aAAa;AAC1B,eAAe,eAAe;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAU,EAAE,uEAAqB,SAAS,iDAAS;AACnD;AACA,CAAC,GAAG,iDAAU;AACd,iDAAU,EAAE,uEAAqB,SAAS,uCAAI;AAC9C;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA,CAAC,GAAG,iDAAU;AACd,iDAAU,EAAE,oEAAkB;AAC9B;AACA;AACA;AACA;AACA,CAAC,GAAG,iDAAU,gBAAgB,iDAAS;AACvC,iDAAU,EAAE,oEAAkB;AAC9B;AACA;AACA;AACA;AACA,CAAC,GAAG,iDAAU,gBAAgB,iDAAS;AACvC,aAAa,iDAAU,EAAE,oEAAkB;AAC3C;AACA;AACA,4DAA4D,uCAAI;AAChE,KAAK;AACL;AACA;AACA,CAAC,GAAG,iDAAU;;;;;;;;;;;;;;;AC/JP;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN,uCAAuC,UAAU,GAAG,UAAU;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,UAAU,GAAG,UAAU;AACvD;AACA;AACA,gCAAgC,UAAU,GAAG,UAAU;AACvD;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,gCAAgC,oBAAoB,GAAG,oBAAoB;AAC3E,QAAQ;AACR,gCAAgC,qBAAqB,GAAG,qBAAqB;AAC7E;AACA,KAAK;AACL;AACA;;;;;;;;;;;;;;;;;;;;;;;;ACjC+C;AACO;AACH;AACQ;AACjB;AAC6B;AACkC;AAC3C;AAC9D;AACA;AACA;AACA,0CAA0C,mDAAU;AACpD;AACA;AACA;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,wDAAc;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM,gCAAgC,6DAAW;AACjD;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,gBAAgB;AAC7B,eAAe,WAAW;AAC1B;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,gBAAgB;AAC7B,eAAe,WAAW;AAC1B;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,SAAS;AACtB,aAAa,cAAc;AAC3B;AACA;AACA;AACA,2BAA2B,6DAAW;AACtC;AACA,0EAA0E,+DAAgB;AAC1F,MAAM;AACN;AACA,sEAAsE,wEAAY;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,iDAAU,EAAE,uEAAqB,SAAS,qDAAO;AACjD;AACA,CAAC,GAAG,iDAAU;AACd,iDAAU,EAAE,uEAAqB,SAAS,6DAAW;AACrD;AACA,CAAC,GAAG,iDAAU;AACd,iDAAU,EAAE,oEAAkB,IAAI,iDAAU,gBAAgB,wDAAc;AAC1E,aAAa,iDAAU,EAAE,oEAAkB,IAAI,iDAAU;;;;;;;;;;;;;;;;;;;;;;ACtNlB;AAC8B;AACG;AACpB;AACrB;AAC+B;AAC9D;AACA;AACA;AACA;AACA;AACO;AACP,0BAA0B,4EAAU;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,2BAA2B,4EAAe;AAC1C;AACA;AACA;AACA,QAAQ;AACR;AACA,4BAA4B,yDAAU;AACtC,iCAAiC,uCAAI;AACrC;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,2BAA2B;AACxC,eAAe,cAAc;AAC7B;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,0BAA0B,4EAAe;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA,2BAA2B,uCAAI;AAC/B,2BAA2B,uCAAI;AAC/B;AACA;AACA;AACA;AACA,MAAM,8EAAuB;AAC7B;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA,QAAQ,yBAAyB,4EAAU;AAC3C;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA,6BAA6B,4EAAe;AAC5C;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,MAAM;AACnB;AACA;AACA;AACA,6BAA6B,uCAAI;AACjC,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,UAAU;AACvB,eAAe,mBAAmB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,UAAU;AACvB,aAAa,QAAQ;AACrB,aAAa,UAAU;AACvB,eAAe,mBAAmB;AAClC;AACA,sDAAsD,wDAAoB;AAC1E;AACA;AACA,wCAAwC,wDAAoB;AAC5D;AACA;AACA,qCAAqC,wDAAoB;AACzD;AACA;AACA;AACA;AACA;AACA,eAAe,mBAAmB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,yBAAyB;AACtC,eAAe,mBAAmB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,yBAAyB;AACtC,eAAe,mBAAmB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,mBAAmB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,cAAc;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,6BAA6B,4EAAe;AAC5C;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,+BAA+B,uCAAI;AACnC;AACA,OAAO;AACP;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AC1R6C;;;;;;;;;;;;;;;ACA7C;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACdqC;AACT;;;;;;;;;;;;;;;;;;;;;ACDF;AACC;AACF;AACF;AACC;AACC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACLC;AACF;AACA;AACA;AACD;AACA;AACG;AACK;AACP;AACC;;;;;;;;;;;;;;;;ACTM;AAC/B;AACA;AACA;AACO,2BAA2B,uCAAI;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,UAAU;AACV;AACA;AACA;AACA,WAAW;AACX;AACA,OAAO;AACP,KAAK;AACL;AACA;;;;;;;;;;;;;;;AC3C+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACO,6BAA6B,uCAAI;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,aAAa;AAC1B,eAAe,eAAe;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,yBAAyB;AACtC,aAAa,aAAa;AAC1B,eAAe,eAAe;AAC9B;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AChDqC;AACa;AAClD;AACA,wCAAwC,kBAAkB,MAAM,iBAAiB;AACjF;AACA;AACA;AACA;AACA,kBAAkB,sBAAsB;AACxC;AACA,YAAY,8CAA8C;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACO,mCAAmC,2DAAc;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,SAAS;AACT;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,aAAa,WAAW;AACxB,aAAa,QAAQ;AACrB,eAAe,qBAAqB;AACpC;AACA;AACA;AACA,kCAAkC,6CAAU;AAC5C;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,6CAAU;AAC9D;AACA;AACA,KAAK;AACL;AACA;;;;;;;;;;;;;;;;;;ACtE+C;AAChB;AACO;AACkB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,wCAAwC;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,uCAAI;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT,QAAQ;AACR;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,qEAAqE,UAAU;AAC/E;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA,sCAAsC,8CAAQ;AAC9C;AACA;AACA;AACA;AACA,aAAa,YAAY;AACzB,aAAa,KAAK;AAClB,eAAe,cAAc;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA,aAAa,YAAY;AACzB,aAAa,KAAK;AAClB,eAAe,cAAc;AAC7B;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,iBAAiB,iDAAU,EAAE,oEAAkB,IAAI,iDAAU;;;;;;;;;;;;;;;;;;;ACnGf;AACf;AAC0B;AACD;AACxD;AACA;AACA;AACA;AACA;AACO,yBAAyB,uCAAI;AACpC;AACA;AACA;AACA;AACA,mDAAmD,iEAAa;AAChE,sGAAsG,0EAAwB;AAC9H,0GAA0G,4EAA0B;AACpI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,6EAA6E;AAC7E;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,iDAAiD,sDAAS;AAC1D;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;AC1E+C;AACS;AACpB;AACL;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,wBAAwB;AAC5C;AACA,YAAY,sBAAsB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,uCAAI;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,UAAU;AACV;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf,aAAa;AACb,YAAY;AACZ;AACA;AACA,aAAa;AACb;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,gDAAM;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,WAAW,iDAAU,EAAE,oEAAkB,IAAI,iDAAU;;;;;;;;;;;;;;;;;;;;ACzFR;AACQ;AACxB;AAC6C;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,YAAY;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,wBAAwB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,uCAAI;AAC9C;AACA;AACA;AACA,aAAa,mBAAmB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,YAAY;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA,wDAAwD,+DAAU;AAClE;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,WAAW;AACX,SAAS;AACT,OAAO;AACP;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA,aAAa,YAAY;AACzB,aAAa,YAAY;AACzB,eAAe,YAAY;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,oBAAoB,WAAW;AAC/B;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,OAAO;AACP;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA,iDAAU,EAAE,oEAAkB,IAAI,iDAAU;AAC5C,aAAa,iDAAU,EAAE,oEAAkB,IAAI,iDAAU;;;;;;;;;;;;;;;;;;ACvNhB;AACV;AACW;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,IAAI,sBAAsB;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;AACA;AACA;AACO,yBAAyB,uCAAI;AACpC;AACA;AACA;AACA;AACA,0BAA0B,uCAAI;AAC9B;AACA,+BAA+B,2DAAwB;AACvD,MAAM;AACN;AACA;AACA;AACA;AACA,8BAA8B,0DAA+B;AAC7D;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,kDAAa;AACtC;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,QAAQ;AACR;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,aAAa;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,WAAW;AACxB,aAAa,aAAa;AAC1B;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;AC9GkC;AAC3B,8BAA8B,uCAAI;AACzC;AACA;AACA;AACA,KAAK;AACL;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACP2B;AACE;AACJ;AACF;AACE;AACQ;AACJ;AACU;AACV;AACE;AACF;;;;;;;;;;;;;;;;;ACVY;AACsB;AAC/D;AACA;AACA;AACA;AACA;AACO,mCAAmC,uEAAoB;AAC9D;AACA;AACA,yDAAyD,oDAAgB;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,4DAAwB;AACnE,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;;;;;;;;;;;;;;;AC9B8C;AAC4B;AAC1E;AACA;AACA;AACA;AACA;AACO,qCAAqC,mFAA0B;AACtE;AACA,UAAU,mDAAgB;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;;;;;;;;;;;;;;;;;;;AChCgF;AACxC;AACG;AAC+B;AAC1E;AACA;AACA;AACA;AACA;AACO,kCAAkC,mFAA0B;AACnE;AACA,UAAU,mDAAgB;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,6CAAU;AAC5C;AACA;AACA;AACA,6CAA6C,uDAAoB;AACjE;AACA,YAAY;AACZ;AACA;AACA;AACA,kCAAkC,6CAAU;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,6CAAU;AAClD;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,6CAAU;AAC5C;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,aAAa,oBAAoB;AACjC,eAAe,kBAAkB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,OAAO;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA,sBAAsB,kBAAkB;AACxC;AACA;AACA;AACA;AACA;AACA,eAAe,UAAU;AACzB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;AACA;AACA,sBAAsB,gBAAgB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,2BAA2B;AACvD;AACA;AACA,sBAAsB,OAAO;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,OAAO;AAC7B;AACA,wBAAwB,OAAO;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,oBAAoB;AAC9C;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA,4BAA4B,gDAAO;AACnC;AACA;AACA;AACA;AACA;AACA,aAAa,aAAa;AAC1B,aAAa,aAAa;AAC1B,eAAe,kBAAkB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,8BAA8B;AAC3C,aAAa,8BAA8B;AAC3C,eAAe,sBAAsB;AACrC;AACA;AACA;AACA;AACA;AACA,sBAAsB,4DAAwB,mBAAmB,oDAAgB;AACjF,sBAAsB,4DAAwB,kBAAkB,oDAAgB;AAChF,sBAAsB,4DAAwB,mBAAmB,oDAAgB;AACjF,sBAAsB,4DAAwB,kBAAkB,oDAAgB;AAChF;AACA;AACA;AACA;AACA,2BAA2B,uDAAoB;AAC/C,0BAA0B,4DAAwB,OAAO,oDAAgB;AACzE,2BAA2B,4DAAwB,OAAO,oDAAgB;AAC1E;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,6CAAU;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,gDAAO;AACjC;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,gDAAO;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AClU+D;AACnB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACO,2CAA2C,uEAAoB;AACtE;AACA;AACA,kCAAkC,iDAAc;AAChD;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,iDAAc;AAC/D;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;;;;;;;;;;;;;;AC1D+D;AAC/D;AACA;AACA;AACA;AACA;AACO,yCAAyC,uEAAoB;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,OAAO;AACP;AACA,OAAO;AACP,KAAK;AACL;AACA;;;;;;;;;;;;;;;;;;ACjC2C;AACM;AACyB;AAC1E;AACA;AACA;AACA,MAAM;AACN,MAAM;AACN,MAAM;AACN;AACA;AACA;AACO,gCAAgC,mFAA0B;AACjE;AACA,UAAU,gDAAa;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iFAAiF,oDAAgB;AACjG;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,WAAW;AACX,aAAa,oBAAoB;AACjC,aAAa,UAAU;AACvB,eAAe,2BAA2B;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,2CAAO;AAClC;AACA,KAAK;AACL;AACA;;;;;;;;;;;;;;;ACtF8E;AAC9E;AACA;AACA;AACO,4BAA4B,uFAA4B;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;;;;;;;;;;;;;;;;AC/BkC;AACyB;AACO;AAClE;AACA;AACA;AACO,mCAAmC,uEAAoB;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,gDAAS;AACzD;AACA;AACA,uBAAuB,iEAAe;AACtC,WAAW;AACX,UAAU;AACV,yDAAyD,iEAAe;AACxE;AACA,yBAAyB,iEAAe;AACxC,aAAa;AACb;AACA,UAAU;AACV;AACA,uBAAuB,iEAAe;AACtC,WAAW;AACX;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,WAAW;AACX,SAAS;AACT,OAAO;AACP,KAAK;AACL;AACA;;;;;;;;;;;;;;;ACvC8E;AAC9E;AACA;AACA;AACO,2BAA2B,uFAA4B;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;;;;;;;;;;;;;;;;ACjC8E;AACrC;AACzC;AACA;AACA;AACA;AACA;AACO,+BAA+B,uFAA4B;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,2CAAO;AACpC;AACA,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,2CAAO;AAC7B,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,SAAS;AACvB,cAAc,SAAS;AACvB,eAAe,SAAS;AACxB;AACA;AACA;AACA,qBAAqB,2CAAO;AAC5B;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,+DAA+D,2CAAO;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,SAAS;AACvB,eAAe,SAAS;AACxB;AACA;AACA,uEAAuE,2CAAO;AAC9E;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACvH8E;AAC9E;AACA;AACA;AACO,2BAA2B,uFAA4B;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;;;;;;;;;;;;;;;;AClCkC;AACgC;AACP;AAC3D;AACA;AACA;AACO,2CAA2C,uEAAoB;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,wBAAwB,oBAAoB;AAC5C;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA,gDAAgD,gDAAS;AACzD;AACA;AACA;AACA,iCAAiC,iEAAe;AAChD;AACA;AACA;AACA,WAAW;AACX,UAAU;AACV;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP,KAAK;AACL;AACA;;;;;;;;;;;;;;;;ACjE2D;AACL;AACtD;AACA;AACA;AACO,qCAAqC,+DAAgB;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,kFAAkF,iEAAe;AACjG;AACA,YAAY;AACZ;AACA;AACA,SAAS;AACT;AACA,OAAO;AACP,KAAK;AACL;AACA;;;;;;;;;;;;;;;ACpC8E;AAC9E;AACA;AACA;AACO,4BAA4B,uFAA4B;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA,wBAAwB,qBAAqB;AAC7C;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACvCuC;AACQ;AACZ;AACJ;AACA;AACC;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACNe;AACzB;AACuB;AACP;AACF;AACG;;;;;;;;;;;;;;;;ACLL;AAClC;AACA;AACA;AACO,0BAA0B,uCAAI;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wEAAwE,SAAS;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,WAAW;AACX,iBAAiB;AACjB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,WAAW;AACX,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;AC5DkC;AAClC;AACA;AACA;AACO,4BAA4B,uCAAI;;;;;;;;;;;;;;;;ACJU;AACf;AAClC;AACA;AACA;AACO,yBAAyB,uCAAI;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0EAA0E,sDAAS;AACnF;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA,6BAA6B;AAC7B;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;;;;;;;;;;;;;;;;ACzDkC;AACK;AACvC;AACA;AACA;AACO,6BAA6B,uCAAI;AACxC,4CAA4C,wDAAoB;AAChE;AACA;AACA;AACA;AACA,oDAAoD,wDAAoB;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,eAAe;AAC9B;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AC7DuC;AACL;AAClC;AACA;AACA;AACO,6BAA6B,uCAAI;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,yBAAyB,4CAAS;AAClC;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;;;;;;;;;;;;;;;ACzBuC;AACY;AACnD;AACA;AACA;AACA;AACA;AACO,6BAA6B,2DAAc;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,2CAA2C,wDAAoB;AACtE,KAAK;AACL;AACA;;;;;;;;;;;;;;;ACpBmD;AACnD;AACA;AACA;AACO,8BAA8B,2DAAc;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,KAAK;AACL;AACA;;;;;;;;;;;;;;;ACnBkC;AAClC;AACA;AACA;AACO,+BAA+B,uCAAI;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;;;;;;;;;;;;;;;;ACf0D;AAClB;AACE;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,6BAA6B,mDAAU;AAC9C;AACA;AACA;AACA,aAAa,cAAc;AAC3B,eAAe,YAAY;AAC3B;AACA;AACA;AACA;AACA,oBAAoB,oBAAoB;AACxC;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,sBAAsB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,+DAAU;AAC7D,iDAAiD,+DAAU;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,+DAAU,IAAI,oDAAgB;AACrF,uDAAuD,+DAAU,IAAI,oDAAgB;AACrF;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,aAAa;AAC1B,eAAe,oBAAoB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,KAAK;AACL,oBAAoB,mBAAmB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;;;;;;;;;;;;;;;;;ACvIiD;AACmB;AAC1B;AAC1C;AACA;AACA;AACO,+BAA+B,mDAAU;AAChD;AACA;AACA,uBAAuB,sDAAgB,KAAK,uDAAiB,CAAC,sDAAS;AACvE;AACA;AACA,KAAK;AACL;AACA;;;;;;;;;;;;;;;;;;ACdmD;AACZ;AACK;AACG;AAC/C;AACA;AACA;AACA;AACA;AACA;AACO,yBAAyB,2DAAc;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,wDAAoB;AAC/E,2EAA2E,yDAAmB;AAC9F;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,eAAe;AAC9B;AACA;AACA;AACA;AACA;AACA,qDAAqD,yDAAmB,0BAA0B,wDAAoB;AACtH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,wBAAwB,qDAAe;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,QAAQ;AACR,+BAA+B,oDAAS;AACxC;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,YAAY;AACZ;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,qDAAe;AACpC;AACA;;;;;;;;;;;;;;;AC1HkD;AAClD;AACA;AACA;AACO,8BAA8B,2DAAc;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;;;;;;;;;;;;;;AChBkD;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,8BAA8B,2DAAc;AACnD;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;;;;;;;;;;;;;;ACvBsD;AACtD;AACA;AACA;AACO,2BAA2B,+DAAgB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT,QAAQ;AACR;AACA;AACA,KAAK;AACL;AACA;;;;;;;;;;;;;;;;AChC4C;AACU;AACtD;AACA;AACA;AACA;AACA;AACO,2BAA2B,+DAAgB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,qDAAe;AACnD;AACA;AACA;AACA,SAAS;AACT,QAAQ;AACR;AACA;AACA,SAAS;AACT;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA,+CAA+C,qDAAe;AAC9D;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;;;;;;;;;;;;;;;;ACzDkC;AACU;AAC5C;AACA;AACA;AACO,4BAA4B,uCAAI;AACvC,uCAAuC,6DAAoB;AAC3D;AACA;AACA;AACA,oDAAoD,6DAAoB;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,eAAe,eAAe;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;AC/D+D;AAC/D;AACA;AACA;AACA;AACA;AACA;AACO,iCAAiC,uEAAoB;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACvB8B;AACK;AACH;AACE;AACD;AACC;AACA;AACC;AACF;AACI;AACN;AACE;AACJ;AACE;AACF;;;;;;;;;;;;;;;;ACdU;AACvC;AACA;AACA;AACO,+BAA+B,+CAAQ;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;;;;;;;;;;;;;;ACdsD;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACO,8BAA8B,+DAAgB;AACrD;AACA;AACA;AACA,aAAa,UAAU;AACvB,aAAa,iBAAiB;AAC9B;AACA;AACA;AACA;AACA;AACA,8DAA8D,SAAS;AACvE;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACvB2C;AACJ;AACC;AACxC;AACA;AACA;AACO,6BAA6B,+CAAQ;AAC5C;AACA;AACA;AACA,gFAAgF,mDAAU;AAC1F,kBAAkB,SAAS;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,6CAAI;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;AC5BkC;AACC;;;;;;;;;;;;;;;;ACDQ;AAC3C;AACA;AACA;AACO,iCAAiC,mDAAU;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;;;;;;;;;;;;;;;;;AChBwC;AACS;AACN;AAC3C;AACA;AACA;AACO,gCAAgC,mDAAU;AACjD;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,iDAAiD,6CAAU;AAC3D;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,WAAW;AACX,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA,0BAA0B,sDAAS;AACnC;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,OAAO;AACP,KAAK;AACL;AACA;;;;;;;;;;;;;;;ACvC2C;AAC3C;AACA;AACA;AACA;AACA;AACA;AACO,6BAA6B,mDAAU;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;;;;;;;;;;;;;;;;AC9B2C;AACH;AACG;AAC3C;AACA;AACA;AACO,+BAA+B,mDAAU;AAChD;AACA;AACA;AACA,gFAAgF,mDAAU;AAC1F,kBAAkB,SAAS;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,6CAAI;AACjC;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;ACpCiC;AACI;AACD;;;;;;;;;;;;;;;;;ACFC;AACO;AAC5C;AACA;AACA;AACO,+BAA+B,qDAAW;AACjD;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,WAAW;AACxB,eAAe,WAAW;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,aAAa,aAAa;AAC1B,eAAe,aAAa;AAC5B;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,aAAa,aAAa;AAC1B,eAAe,aAAa;AAC5B;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,aAAa,qBAAqB;AAClC,aAAa,aAAa;AAC1B,eAAe,aAAa;AAC5B;AACA;AACA;AACA;AACA;AACA,qCAAqC,6CAAU;AAC/C;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;;;;;;;;;;;;;;;ACjE6C;AACD;AAC5C;AACA;AACA;AACA;AACO,gCAAgC,qDAAW;AAClD;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,YAAY;AACzB,eAAe,YAAY;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,eAAe,cAAc;AAC7B;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,aAAa,kBAAkB;AAC/B,eAAe,cAAc;AAC7B;AACA;AACA;AACA;AACA,4BAA4B,qDAAkB;AAC9C;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,eAAe,cAAc;AAC7B;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,eAAe,cAAc;AAC7B;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,eAAe,cAAc;AAC7B;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;;;;;;;;;;;;;;;;;;AClG+C;AAC6B;AACpB;AACpB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,kBAAkB;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,6CAAO;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,eAAe,aAAa;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAU,EAAE,oEAAkB,IAAI,iDAAU,gBAAgB,iEAAiB;AAC7E,iDAAU,EAAE,oEAAkB,IAAI,iDAAU;AAC5C,cAAc,iDAAU,EAAE,oEAAkB,IAAI,iDAAU,uBAAuB,iEAAiB;;;;;;;;;;;;;;;;;;;;AClFnD;AACX;AACoB;AACoB;AAC5E;AACA;AACA;AACA;AACA,wDAAwD,6CAAO;AAC/D,oCAAoC;AACpC;AACA;AACA,+DAA+D,0EAAwB;AACvF,mEAAmE,4EAA0B;AAC7F;AACA;AACA;AACA;AACA;AACA;AACA,iDAAU,EAAE,oEAAkB;AAC9B;AACA,kCAAkC,+EAA6B;AAC/D,CAAC,GAAG,iDAAU;AACd,iDAAU,EAAE,oEAAkB,IAAI,iDAAU;AAC5C,oBAAoB,iDAAU,EAAE,oEAAkB,IAAI,iDAAU;;;;;;;;;;;;;;;;ACzBpB;AACrC,+BAA+B,qDAAW;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACVoC;AAC7B,2BAA2B,6CAAO;AACzC;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACN4C;AACY;AACxD;AACA;AACA;AACA;AACO,kCAAkC,qDAAW;AACpD;AACA;AACA;AACA,wBAAwB,iEAAiB;AACzC;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,eAAe,cAAc;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,aAAa,KAAK;AAClB,eAAe,eAAe;AAC9B;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;ACtCqC;AACD;AACA;AACQ;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,mCAAmC,6CAAO;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,6CAAU;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,aAAa,qBAAqB;AAClC,aAAa,kBAAkB;AAC/B,eAAe,eAAe;AAC9B;AACA;AACA;AACA,oCAAoC,6CAAU;AAC9C;AACA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA,aAAa,qBAAqB;AAClC,aAAa,YAAY;AACzB,eAAe,2BAA2B;AAC1C;AACA,yCAAyC;AACzC;AACA;AACA;AACA,oCAAoC,6CAAU;AAC9C;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,gCAAgC;AACzC;AACA;AACA,SAAS;AACT,QAAQ;AACR;AACA;AACA,uBAAuB,6DAAmB,WAAW,yDAAe,IAAI,wDAAoB;AAC5F;AACA;AACA;AACA,YAAY;AACZ,iFAAiF;AACjF;AACA,aAAa;AACb;AACA,SAAS;AACT;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,aAAa,qBAAqB;AAClC,aAAa,mDAAmD;AAChE,aAAa,iBAAiB;AAC9B,eAAe,QAAQ;AACvB;AACA,8CAA8C;AAC9C;AACA,kCAAkC,6CAAU;AAC5C;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACtLwD;AACM;AACvD,gCAAgC,iEAAiB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR,kBAAkB,oBAAoB,mBAAmB,KAAK;AAC9D;AACA,KAAK;AACL;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,UAAU;AACV;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA,YAAY,gFAA6B;AACzC;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,uBAAuB,wFAAqC;AAC5D,uBAAuB,wFAAqC;AAC5D;AACA;AACA,YAAY;AACZ;AACA,YAAY;AACZ;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR,oCAAoC,oBAAoB,mBAAmB,IAAI;AAC/E;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,cAAc,gFAA6B;AAC3C;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA,cAAc,gFAA6B;AAC3C;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;;;;;;;;;;;;;AC5GA;AACA,wBAAwB,kBAAkB,QAAQ,wBAAwB;AAC1E;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C;AAC9C,oCAAoC;AACpC;AACA,kCAAkC,OAAO;AACzC;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,UAAU;AACV;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,WAAW;AACX,UAAU;AACV;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;ACxI+C;AAC6B;AAChC;AACR;AAC7B,8BAA8B,qDAAW;AAChD;AACA;AACA;AACA,aAAa,QAAQ;AACrB,aAAa,YAAY;AACzB,eAAe,cAAc;AAC7B;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,gDAAM;AACjB;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA,iDAAU,EAAE,oEAAkB,IAAI,iDAAU;AAC5C,iDAAU,EAAE,oEAAkB;AAC9B;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,CAAC,GAAG,iDAAU;AACd,WAAW,iDAAU,EAAE,oEAAkB,IAAI,iDAAU;;;;;;;;;;;;;;;;;;;;AC5CR;AAChB;AACK;AACoB;AACxD;AACA;AACA;AACA,gDAAgD,6CAAO;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,aAAa,iBAAiB;AAC9B,aAAa,mBAAmB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,aAAa,mBAAmB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB,aAAa,OAAO;AACpB,eAAe,2BAA2B;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,yBAAyB;AACtC,eAAe,eAAe;AAC9B;AACA;AACA;AACA,2CAA2C,uCAAI;AAC/C;AACA,4DAA4D,iBAAiB;AAC7E;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,aAAa,SAAS;AACtB,eAAe,eAAe;AAC9B;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,gBAAgB,iDAAU,EAAE,oEAAkB,IAAI,iDAAU;AACnC;AAClB,iCAAiC,6CAAO;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,SAAS;AACtB,aAAa,sBAAsB;AACnC,eAAe,UAAU;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;ACvK+C;AACoB;AAC/B;AACwC;AAC5E;AACA,kCAAkC,YAAY,YAAY;AAC1D;AACA,oCAAoC,0EAAiB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,WAAW,gDAAM;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB,aAAa,KAAK;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAU,EAAE,oEAAkB,IAAI,iDAAU;AAC5C,UAAU,iDAAU,EAAE,oEAAkB,IAAI,iDAAU;;;;;;;;;;;;;;;;;;;;;AClDtD;AAC+C;AACX;AACA;AACoE;AACxG;AACA;AACA;AACA,4DAA4D,6CAAO;AACnE,mCAAmC,wDAAoB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,wDAAoB;AACrD;AACA;AACA;AACA,wBAAwB,mBAAO,CAAC,wBAAW;AAC3C;AACA;AACA;AACA,qCAAqC,wDAAoB;AACzD;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,UAAU;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAU,EAAE,4EAA0B,IAAI,iDAAU;AACpD,iDAAU,EAAE,oEAAkB,IAAI,iDAAU,gBAAgB,4CAAQ;AACpE,iDAAU,EAAE,oEAAkB,IAAI,iDAAU,0BAA0B,iDAAU;AAChF,8BAA8B,iDAAU,EAAE,oEAAkB,IAAI,iDAAU,iCAAiC,4CAAQ;;;;;;;;;;;;;;;;;;ACzFjF;AACqB;AACX;AAC5C;AACA;AACA;AACA;AACO,gCAAgC,qDAAW;AAClD;AACA;AACA;AACA;AACA;AACA,2DAA2D,+DAAU;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,gDAAS;AAC/D;AACA,SAAS;AACT;AACA,QAAQ;AACR,+DAA+D,yBAAyB;AACxF;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,aAAa,qBAAqB;AAClC,eAAe,qBAAqB;AACpC;AACA;AACA;AACA;AACA,qCAAqC,+DAAU;AAC/C,OAAO;AACP;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA,aAAa,qBAAqB;AAClC,aAAa,eAAe;AAC5B,aAAa,eAAe;AAC5B,eAAe,YAAY;AAC3B;AACA;AACA;AACA;AACA,qCAAqC,+DAAU;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA,aAAa,qBAAqB;AAClC,eAAe,mBAAmB;AAClC;AACA;AACA;AACA;AACA,qCAAqC,+DAAU;AAC/C,OAAO;AACP;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA,aAAa,YAAY;AACzB,aAAa,QAAQ;AACrB,eAAe,qBAAqB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,QAAQ;AACR;AACA;AACA,KAAK;AACL;AACA;;;;;;;;;;;;;;;;;ACtHwD;AACpB;AACoB;AACxD;AACA;AACA;AACA;AACA;AACO,iCAAiC,gEAAY;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,0BAA0B,4EAA0B;AACpD,cAAc;AACd;AACA;AACA,WAAW;AACX;AACA,UAAU;AACV;AACA,4BAA4B,4EAA0B;AACtD,YAAY;AACZ;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,SAAS;AACtB,aAAa,sBAAsB;AACnC,eAAe,UAAU;AACzB;AACA;AACA;AACA,mBAAmB,gDAAM;AACzB;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,YAAY,+EAA6B;AACzC,8BAA8B,0EAAwB;AACtD,UAAU;AACV;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA,KAAK;AACL;AACA;;;;;;;;;;;;;;;AClG8C;AACvC,+BAA+B,uDAAY;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACRqC;AAC9B,2BAA2B,6CAAO;AACzC;AACA;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACzBoC;AACV;AACU;AACC;AACD;AACF;AACJ;AACA;AACM;AACN;AACQ;AACH;AACL;AACS;AACP;AACO;AACJ;;;;;;;;;;;;;;;;;;AChBU;AACN;AACA;AACvC,iCAAiC,gDAAO;AACxC,qCAAqC,sDAAU;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,oDAAK;AACjC;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA,6BAA6B,oDAAK;AAClC;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA,4BAA4B,oDAAK;AACjC;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA,6BAA6B,oDAAK;AAClC;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA,4BAA4B,oDAAK;AACjC;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA,6BAA6B,oDAAK;AAClC;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACxLA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACrLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,oBAAoB,OAAO;AAC3B;AACA;AACA;AACA;AACA;AACA,oBAAoB,OAAO;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACpPuC;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,QAAQ;AAC5B;AACA;AACA;AACA;AACA;AACA,oBAAoB,QAAQ;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,gDAAO;AACpC;AACA,+BAA+B,gDAAO;AACtC,8BAA8B,gDAAO;AACrC,4BAA4B,gDAAO;AACnC,4BAA4B,gDAAO;AACnC,4BAA4B,gDAAO;;;;;;;;;;;;;;;;AC5pBS;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA,MAAM;AACN,qCAAqC;;AAErC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,gDAAe;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACpcA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACvQ4C;AACC;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;;AAErC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,qBAAqB,gDAAe;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,sDAAU;;;;;;;;;;;;;;;AClc/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,wBAAwB;AACxB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,qBAAqB;AACrB;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,QAAQ;AACR;;AAEA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,QAAQ;AACR;;AAEA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;;AAEA;;AAEA,0GAA0G;;AAE1G;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;ACzawC;AACxC;AACA;AACA;AACA,WAAW,UAAU;AACrB,WAAW,UAAU;AACrB,aAAa,QAAQ;AACrB;AACO;AACP,kBAAkB,2DAAwB,YAAY,mDAAgB;AACtE,kBAAkB,2DAAwB,YAAY,mDAAgB;AACtE,mBAAmB,2DAAwB,wBAAwB,mDAAgB;AACnF,mBAAmB,2DAAwB,wBAAwB,mDAAgB;AACnF;AACA;AACA,SAAS,wDAAqB;AAC9B;AACA;AACA;AACA;AACA,WAAW,UAAU;AACrB,WAAW,UAAU;AACrB,aAAa,QAAQ;AACrB;AACO;AACP;AACA,kBAAkB,mBAAmB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,UAAU;AACrB,WAAW,UAAU;AACrB,aAAa,QAAQ;AACrB;AACO;AACP;AACA,kBAAkB,mBAAmB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,UAAU;AACrB,WAAW,UAAU;AACrB,aAAa,QAAQ;AACrB;AACO;AACP;AACA,kBAAkB,mBAAmB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,UAAU;AACrB,WAAW,UAAU;AACrB,aAAa,QAAQ;AACrB;AACO;AACP;AACA,kBAAkB,mBAAmB;AACrC;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACzEuB;AACA;;;;;;;;;;;;;;;;;;;;;ACDvB;AAC+C;AACD;AACiC;AAC3C;AACA;AACpC;AACA;AACA;AACA,sDAAsD,6CAAO;AAC7D,4CAA4C,6DAAgB;AAC5D,kCAAkC,6DAAgB,2BAA2B,6DAAgB,2BAA2B,6DAAgB;AACxI;AACA,uCAAuC,6DAAgB;AACvD,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,kBAAkB;AAC/B,eAAe,WAAW;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,SAAS;AACxB;AACA;AACA,WAAW,mEAA6B;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAU,EAAE,oEAAkB,IAAI,iDAAU;AAC5C,0BAA0B,iDAAU,EAAE,oEAAkB,IAAI,iDAAU,uDAAuD,sDAAS;;;;;;;;;;;;;;;;;;;;;;;ACxDtI;AAC+C;AAC4C;AACtD;AACD;AACU;AACV;AACpC;AACA;AACA;AACA,0CAA0C,4CAAW;AACrD;AACA;AACA;AACA,oCAAoC,6DAAgB;AACpD,oCAAoC,6DAAgB;AACpD,oCAAoC,6DAAgB;AACpD;AACA;AACA;AACA;AACA;AACA,aAAa,kBAAkB;AAC/B,aAAa,QAAQ;AACrB,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,SAAS;AACtB,aAAa,QAAQ;AACrB,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,WAAW;AACxB,eAAe,SAAS;AACxB;AACA,kBAAkB,6DAAgB;AAClC,eAAe,6CAAO,CAAC,qEAAwB,gBAAgB,qEAAwB,gBAAgB,qEAAwB;AAC/H;AACA;AACA;AACA;AACA,sBAAsB;AACtB,aAAa,WAAW;AACxB,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,SAAS;AACxB;AACA;AACA,WAAW,+DAAyB;AACpC;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA,WAAW,qEAAwB,SAAS,6DAAgB;AAC5D;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA,WAAW,qEAAwB,SAAS,6DAAgB;AAC5D;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA,WAAW,qEAAwB,SAAS,6DAAgB;AAC5D;AACA;AACA;AACA;AACA;AACA,iDAAU,EAAE,oEAAkB;AAC9B,cAAc,gEAAkB;AAChC,CAAC,GAAG,iDAAU;AACd,iDAAU,EAAE,oEAAkB;AAC9B,cAAc,gEAAkB;AAChC,CAAC,GAAG,iDAAU;AACd,iDAAU,EAAE,oEAAkB;AAC9B,cAAc,gEAAkB;AAChC,CAAC,GAAG,iDAAU;AACd,kBAAkB,iDAAU,EAAE,oEAAkB,IAAI,iDAAU,uDAAuD,sDAAS;;;;;;;;;;;;;;;;;;;AC3G/E;AACqC;AAC/C;AACrC;AACA;AACA;AACA,oCAAoC,8CAAa;AACjD;AACA;AACA;AACA,aAAa,YAAY;AACzB,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAU,EAAE,yEAAuB,UAAU,iDAAU;AACvD,UAAU,iDAAU,EAAE,oEAAkB;;;;;;;;;;;;;;;;;;;ACxBO;AACqC;AAC/C;AACrC;AACA;AACA;AACA,oCAAoC,8CAAa;AACjD;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,aAAa,YAAY;AACzB,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,kBAAkB;AAC/B,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,aAAa;AAC1B,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,eAAe;AAC5B,aAAa,QAAQ;AACrB,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAU,EAAE,yEAAuB,UAAU,iDAAU;AACvD,UAAU,iDAAU,EAAE,oEAAkB;;;;;;;;;;;;;;;;;;;;;;;;ACjExC;AAC+C;AAC4C;AACtD;AACL;AACI;AACI;AACJ;AACpC;AACA;AACA;AACA,yDAAyD,iDAAgB;AACzE;AACA;AACA;AACA,aAAa,kBAAkB;AAC/B,eAAe,YAAY;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,yCAAK;AAC9B;AACA,MAAM,0BAA0B,6CAAO;AACvC,kCAAkC,yCAAK;AACvC,MAAM;AACN,kCAAkC,yCAAK;AACvC,MAAM;AACN,kCAAkC,yCAAK;AACvC,MAAM;AACN,kCAAkC,yCAAK;AACvC;AACA;AACA;AACA;AACA;AACA,wBAAwB,iDAAS;AACjC,sCAAsC,6CAAO;AAC7C,MAAM;AACN,4BAA4B,iDAAS;AACrC;AACA,MAAM;AACN,4BAA4B,iDAAS;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,YAAY;AACzB,aAAa,SAAS;AACtB,eAAe,YAAY;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,YAAY;AACzB,eAAe,OAAO;AACtB;AACA;AACA,WAAW,wDAAoB;AAC/B;AACA;AACA;AACA;AACA,eAAe,WAAW;AAC1B;AACA;AACA,WAAW,gEAAwB;AACnC;AACA;AACA;AACA;AACA,eAAe,SAAS;AACxB;AACA;AACA,WAAW,oEAA8B;AACzC;AACA;AACA;AACA;AACA;AACA,iDAAU,EAAE,oEAAkB;AAC9B,cAAc,gEAAkB;AAChC,CAAC,GAAG,iDAAU;AACd,iDAAU,EAAE,oEAAkB;AAC9B,cAAc,gEAAkB;AAChC,CAAC,GAAG,iDAAU;AACd,iDAAU,EAAE,oEAAkB;AAC9B,cAAc,gEAAkB;AAChC,CAAC,GAAG,iDAAU;AACd,iDAAU,EAAE,oEAAkB;AAC9B,QAAQ,gEAAkB;AAC1B,CAAC,GAAG,iDAAU;AACd,4BAA4B,iDAAU,EAAE,oEAAkB;;;;;;;;;;;;;;;;;;;;AC3GX;AAC4C;AACtD;AACrC;AACA;AACA;AACA,oCAAoC,8CAAa;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAU,EAAE,oEAAkB;AAC9B,cAAc,gEAAkB;AAChC,CAAC,GAAG,iDAAU;AACd,iDAAU,EAAE,oEAAkB;AAC9B,cAAc,gEAAkB;AAChC,CAAC,GAAG,iDAAU;AACd,UAAU,iDAAU,EAAE,oEAAkB;;;;;;;;;;;;;;;;;;;;ACpBO;AAC4C;AACtD;AACrC;AACA;AACA;AACA,oCAAoC,8CAAa;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAU,EAAE,oEAAkB;AAC9B,cAAc,gEAAkB;AAChC,CAAC,GAAG,iDAAU;AACd,iDAAU,EAAE,oEAAkB;AAC9B,cAAc,gEAAkB;AAChC,CAAC,GAAG,iDAAU;AACd,iDAAU,EAAE,oEAAkB;AAC9B,cAAc,gEAAkB;AAChC,CAAC,GAAG,iDAAU;AACd,UAAU,iDAAU,EAAE,oEAAkB;;;;;;;;;;;;;;;;;;;;AC1BO;AAC4C;AACtD;AACrC;AACA;AACA;AACA,oCAAoC,8CAAa;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAU,EAAE,oEAAkB;AAC9B,cAAc,gEAAkB;AAChC,CAAC,GAAG,iDAAU;AACd,iDAAU,EAAE,oEAAkB;AAC9B,cAAc,gEAAkB;AAChC,CAAC,GAAG,iDAAU;AACd,iDAAU,EAAE,oEAAkB;AAC9B,cAAc,gEAAkB;AAChC,CAAC,GAAG,iDAAU;AACd,iDAAU,EAAE,oEAAkB;AAC9B,cAAc,gEAAkB;AAChC,CAAC,GAAG,iDAAU;AACd,UAAU,iDAAU,EAAE,oEAAkB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC1BhB;AACE;AACG;AACH;AACA;AACA;AACE;AACH;;;;;;;;;;;;;;;;;;;;ACPzB;AACmC;AACwB;AACf;AACF;AACJ;AACtC;AACA;AACA;AACA,2EAA2E,qDAAW;AACtF;AACA;AACA;AACA,CAAC,UAAU,yDAAgB,aAAa,sDAAe;AACvD;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,CAAC;AACD,wCAAwC,iDAAU,EAAE,oEAAkB;;;;;;;;;;;;;;;;;;ACtBtE;AACmC;AACL;AAC6B;AAC3D;AACA;AACA;AACA,sDAAsD,uCAAI;AAC1D;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,CAAC;AACD,0BAA0B,iDAAU,EAAE,oEAAkB;;;;;;;;;;;;;;;;;;;;ACpBxD;AACmC;AACwB;AACf;AACJ;AACF;AACtC;AACA;AACA;AACA,oFAAoF,qDAAW;AAC/F;AACA;AACA;AACA,CAAC,UAAU,wDAAgB,aAAa,sDAAe;AACvD,sFAAsF,wDAAgB;AACtG;AACA;AACA;AACA,CAAC;AACD,sFAAsF,sDAAe;AACrG;AACA;AACA;AACA,CAAC;AACD,sFAAsF,wDAAgB,EAAE,sDAAe;AACvH;AACA;AACA;AACA,CAAC;AACD,8CAA8C,iDAAU,EAAE,oEAAkB;;;;;;;;;;;;;;;;;;AC7BzC;AACL;AAC6B;AAC3D;AACA;AACA;AACA;AACA;AACA,4CAA4C,uCAAI;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,cAAc;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,iDAAc;AACtB,aAAa,iDAAc;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,KAAK;AACL;AACA,WAAW,oDAAiB;AAC5B;AACA;AACA,cAAc,iDAAU,EAAE,oEAAkB;;;;;;;;;;;;;;;;;;;;ACxD5C;AACmC;AACwB;AACjB;AACF;AACV;AAC9B;AACA;AACA;AACA,oCAAoC,uCAAI;AACxC;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,mGAAmG;AAClH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,kDAAO,CAAC,gEAAwB,UAAU,wDAAgB,GAAG,gEAAwB,QAAQ,wDAAgB;AAC9H,KAAK;AACL;AACA;AACA,kBAAkB,gEAAwB,UAAU,wDAAgB;AACpE,qBAAqB,gEAAwB,UAAU,wDAAgB;AACvE;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,kDAAO;AACxB;AACA,GAAG;AACH,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,kDAAO;AACxB,KAAK;AACL;AACA,iBAAiB,kDAAO;AACxB;AACA,GAAG;AACH,CAAC;AACD,cAAc,iDAAU,EAAE,oEAAkB;;;;;;;;;;;;;;;;;;;ACpF5C;AACmC;AACL;AAC6B;AACjB;AAC1C;AACA;AACA;AACA,yDAAyD,uCAAI;AAC7D;AACA;AACA;AACA;AACA,CAAC;AACD,qDAAqD,yDAAgB;AACrE,qDAAqD,yDAAgB;AACrE,oDAAoD,wDAAe;AACnE;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,CAAC;AACD,4BAA4B,iDAAU,EAAE,oEAAkB;;;;;;;;;;;;;;;;;;;;ACzB1D;AACmC;AACwB;AACf;AACF;AACJ;AACtC;AACA;AACA;AACA,iFAAiF,qDAAW;AAC5F;AACA;AACA;AACA,CAAC,UAAU,yDAAgB,aAAa,sDAAe;AACvD,uFAAuF,8DAAqB;AAC5G;AACA;AACA;AACA,CAAC;AACD,4CAA4C,iDAAU,EAAE,oEAAkB;;;;;;;;;;;;;;;;;;ACnB1E;AACmC;AACL;AAC6B;AAC3D;AACA;AACA;AACA,6FAA6F,uCAAI;AACjG;AACA;AACA;AACA,CAAC;AACD,oDAAoD,iDAAU,EAAE,oEAAkB;;;;;;;;;;;;;;;;;;ACZlF;AACmC;AACL;AAC6B;AAC3D;AACA;AACA;AACA,kEAAkE,uCAAI;AACtE;AACA;AACA;AACA;AACA,CAAC;AACD,kCAAkC,iDAAU,EAAE,oEAAkB;;;;;;;;;;;;;;;;;;;ACbhE;AACmC;AACL;AAC6B;AACjB;AAC1C;AACA;AACA;AACA,kEAAkE,uCAAI;AACtE;AACA;AACA;AACA;AACA,CAAC;AACD,2DAA2D,yDAAgB;AAC3E,kCAAkC,iDAAU,EAAE,oEAAkB;;;;;;;;;;;;;;;;;;ACfhE;AACmC;AACL;AAC6B;AAC3D;AACA;AACA;AACA,+DAA+D,uCAAI;AACnE;AACA;AACA;AACA;AACA,CAAC;AACD,gCAAgC,iDAAU,EAAE,oEAAkB;;;;;;;;;;;;;;;;;;ACb9D;AACmC;AACL;AAC6B;AAC3D;AACA;AACA;AACA,wEAAwE,uCAAI;AAC5E;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,CAAC;AACD,sCAAsC,iDAAU,EAAE,oEAAkB;;;;;;;;;;;;;;;;;;;ACjCpE;AACmC;AACL;AAC6B;AACjB;AAC1C;AACA;AACA;AACA,mDAAmD,uCAAI;AACvD;AACA;AACA;AACA;AACA,CAAC;AACD,mDAAmD,yDAAgB;AACnE,mDAAmD,yDAAgB;AACnE,kDAAkD,wDAAe;AACjE;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH,CAAC;AACD,wBAAwB,iDAAU,EAAE,oEAAkB;;;;;;;;;;;;;;;;;;;;;ACpCtD;AAC+C;AACrB;AACqD;AACrC;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,aAAa,aAAa;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,KAAK;AAClB,eAAe,MAAM;AACrB;AACA;AACA;AACA;AACA;AACA,2CAA2C,UAAU;AACrD;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,UAAU;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,2DAAkB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,wBAAwB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,YAAY;AACzB,eAAe,MAAM;AACrB;AACA;AACA;AACA,wBAAwB,YAAY,EAAE,UAAU;AAChD;AACA;AACA;AACA;AACA,oEAAoE,YAAY;AAChF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,YAAY,EAAE,MAAM;AAC1C,sBAAsB,mBAAmB,EAAE,MAAM;AACjD,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,eAAe,kBAAkB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB,eAAe,kBAAkB;AACjC;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,eAAe;AAC5B,aAAa,eAAe;AAC5B,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D,UAAU,QAAQ,gBAAgB;AAChG,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,eAAe;AAC5B,aAAa,eAAe;AAC5B,aAAa,eAAe;AAC5B,eAAe,eAAe;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,MAAM;AACnB,aAAa,SAAS;AACtB,eAAe,MAAM;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAU,EAAE,oEAAkB,IAAI,iDAAU,yBAAyB,iDAAU;AAC/E,gBAAgB,iDAAU,EAAE,oEAAkB;AAC9C;AACA,CAAC,GAAG,iDAAU;;;;;;;;;;;;;;;ACnXd;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,UAAU;AACrC;AACA;AACA,2BAA2B,iBAAiB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACpC+C;AACgC;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,MAAM;AACnB,eAAe,WAAW;AAC1B;AACA;AACA;AACA,yBAAyB,uBAAuB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,MAAM;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAU,EAAE,oEAAkB;AAC9B;AACA,CAAC,GAAG,iDAAU;AACd,iDAAU,EAAE,oEAAkB;AAC9B;AACA,CAAC,GAAG,iDAAU;AACd,YAAY,iDAAU,EAAE,oEAAkB,IAAI,iDAAU;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC9EjC;AACU;AACJ;AACC;AACA;AACF;AACA;AACU;AACX;AACE;AACQ;AACF;AACH;AACV;AACY;AACO;AACT;;;;;;;;;;;;;;;;;;;;;;;AChBc;AACU;AACH;AACc;AACA;AACJ;AACR;AAChD,4BAA4B,0EAAiB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,KAA2C,EAAE,EAMhD;AACP,mBAAmB,6CAAI;AACvB;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,sBAAsB,0EAAwB;AAC9C,OAAO;AACP;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,eAAe,iBAAiB;AAChC;AACA;AACA;AACA;AACA,yBAAyB,2CAAM;AAC/B,MAAM,8CAAK;AACX;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,SAAS;AACxD;AACA;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,6DAAW;AAChD;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,yBAAyB,+EAA6B;AACtD,6BAA6B,uEAAgB,6BAA6B,2EAAkB;AAC5F;AACA;AACA,SAAS;AACT,QAAQ;AACR,6BAA6B,+DAAY,mBAAmB,2EAAkB;AAC9E;AACA;AACA,SAAS;AACT;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,4EAA0B;AAChD,UAAU;AACV;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,wBAAwB,0EAAwB;AAChD,WAAW;AACX;AACA;AACA;AACA;AACA,WAAW;AACX,UAAU;AACV,yBAAyB,0EAAwB;AACjD;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,aAAa;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,KAAK;AAClB,aAAa,aAAa;AAC1B;AACA;AACA,8BAA8B,4EAA0B;AACxD;AACA;AACA;;;;;;;;;;;;;;;AC5NgC;;;;;;;;;;;ACAhC;;AAEA;AACA;AACA;;AAEA,kBAAkB;AAClB,YAAY;AACZ,YAAY;AACZ,iBAAiB;AACjB,eAAe;AACf,eAAe;AACf;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;;AAEA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,4CAA4C;;AAEvD;AACA;AACA;AACA,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA,iBAAiB,mBAAO,CAAC,oDAAU;;AAEnC,OAAO,YAAY;;AAEnB;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;;;;;;;;;;;AC3QA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,mBAAO,CAAC,sCAAI;AACpC;;AAEA;AACA;AACA,EAAE;;AAEF;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,QAAQ;AACnB,YAAY,eAAe;AAC3B;AACA;AACA;AACA;;AAEA,kBAAkB,sBAAsB;AACxC;AACA,cAAc;AACd;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAI;;AAEJ;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,uCAAuC;;AAEvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,IAAI;AACJ;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,cAAc,SAAS;AACvB;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,8CAA8C,SAAS;AACvD;AACA;AACA;AACA;;AAEA,8CAA8C,SAAS;AACvD;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;;;;;;;;;;;ACjRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEa;;AAEb;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,mBAAmB;;AAEnB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,kBAAkB,sBAAsB;AACxC;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA,eAAe;AACf;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA,oBAAoB,SAAS;AAC7B;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;;AAEA,kCAAkC,QAAQ;AAC1C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,oBAAoB,iBAAiB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,QAAQ;AACR;AACA,uCAAuC,QAAQ;AAC/C;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,kBAAkB,OAAO;AACzB;AACA;AACA;;AAEA;AACA,SAAS,yBAAyB;AAClC;AACA;AACA;;AAEA;AACA;AACA,kBAAkB,gBAAgB;AAClC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,8DAA8D,YAAY;AAC1E;AACA,8DAA8D,YAAY;AAC1E;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,qCAAqC,YAAY;AACjD;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,IAAI;AACJ;AACA;AACA;;;;;;;;;;;;AChfa;;AAEb;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;;;;;;;;;;;AClBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,oCAAoC;;AAEpC;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,wBAAwB,qBAAM,gBAAgB,qBAAM,IAAI,qBAAM,sBAAsB,qBAAM;;AAE1F;AACA;;AAEA;AACA;;AAEA;AACA,kBAAkB,KAA0B;;AAE5C;AACA,gCAAgC,QAAa;;AAE7C;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,OAAO;AAClB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,GAAG;AACd,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,UAAU;AACrB,aAAa,OAAO;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,UAAU;AACrB,WAAW,GAAG;AACd,WAAW,SAAS;AACpB;AACA,aAAa,GAAG;AAChB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,UAAU;AACrB,aAAa,OAAO;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,aAAa,GAAG;AAChB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,OAAO;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,UAAU;AACrB,WAAW,UAAU;AACrB,aAAa,UAAU;AACvB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,OAAO;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,aAAa,SAAS;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,GAAG;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,GAAG;AACd,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,SAAS;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,GAAG;AAChB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,SAAS;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,GAAG;AACd,aAAa,QAAQ;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,SAAS;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,GAAG;AAChB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,SAAS;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,GAAG;AACd,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,SAAS;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,GAAG;AAChB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,SAAS;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,GAAG;AACd,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,WAAW,SAAS;AACpB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,GAAG;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,GAAG;AACd,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,WAAW,SAAS;AACpB,WAAW,SAAS;AACpB,WAAW,UAAU;AACrB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,aAAa,GAAG;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C;AAC3C;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,UAAU;AACrB,WAAW,UAAU;AACrB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa,QAAQ;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,SAAS;AACpB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,aAAa;AACxB,aAAa,aAAa;AAC1B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,SAAS;AACpB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,UAAU;AACrB,WAAW,SAAS;AACpB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,UAAU;AACrB,WAAW,SAAS;AACpB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,SAAS;AACpB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,aAAa,OAAO;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,OAAO;AAClB,WAAW,QAAQ,UAAU;AAC7B,WAAW,UAAU;AACrB,aAAa,QAAQ;AACrB;AACA;AACA,wBAAwB;;AAExB;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ,UAAU;AAC7B,aAAa,QAAQ;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,OAAO;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,aAAa,GAAG;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,aAAa,GAAG;AAChB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,OAAO;AACpB;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa,QAAQ;AACrB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa,OAAO;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,UAAU;AACrB,WAAW,SAAS;AACpB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,WAAW,QAAQ;AACnB,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,UAAU;AACrB,aAAa,SAAS;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa,SAAS;AACtB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,UAAU;AACrB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa,GAAG;AAChB;AACA;AACA;AACA,oBAAoB,QAAQ,IAAI,QAAQ;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,WAAW,GAAG;AACd,aAAa,SAAS;AACtB;AACA;AACA,kBAAkB;AAClB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa,SAAS;AACtB;AACA;AACA;AACA,8BAA8B,mBAAmB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa,SAAS;AACtB;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa,SAAS;AACtB;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;ACntDA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,eAAe;AAC1B,WAAW,QAAQ;AACnB,YAAY,OAAO;AACnB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACjKA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;;;;;;;;;;;;;;;;;ACzCO;AACA;AACA;AACA;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACVA;AACuC;AAChC;AACP,oBAAoB,mDAAS;AAC7B;AACO;AACP,oBAAoB,mDAAS;AAC7B;;;;;;;;;;;;;;;;;;ACPA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACoD;AACd;AACE;AACxC;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,mDAAU;AAC7B,kCAAkC,4DAAoB;AACtD;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,aAAa;AACb,yBAAyB,wDAAW;AACpC,SAAS;AACT;AACA;AACA,iEAAe,MAAM,EAAC;;;;;;;;;;;;;;;;;;;ACvCtB,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACA,qBAAqB,SAAI,IAAI,SAAI;AACjC;AACA;AACA,2GAA2G,uFAAuF,cAAc;AAChN,uBAAuB,8BAA8B,gDAAgD,wDAAwD;AAC7J,6CAA6C,sCAAsC,UAAU,mBAAmB,IAAI;AACpH;AACoD;AACE;AAChB;AACE;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,mDAAU;AAC7B,kCAAkC,4DAAoB;AACtD;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,4BAA4B,iDAAU,YAAY,sDAAe;AACjE;AACA,uFAAuF,qDAAqD;AAC5I;AACA;AACA;AACA;AACA,4CAA4C,QAAQ;AACpD;AACA;AACA;AACA;AACA,0CAA0C;AAC1C;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,aAAa;AACb,yBAAyB,wDAAW;AACpC,SAAS;AACT;AACA;AACA,iEAAe,OAAO,EAAC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACnEsB;AACE;AACE;AACV;AACI;AACQ;AACE;AACZ;AACM;AACQ;;;;;;;;;;;;;;;;ACTb;AAC1C;AACA;AACA;AACA;AACA;AACe;AACf,eAAe,mDAAU;AACzB;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;;ACdA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACoD;AACd;AACE;AACxC;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,mDAAU;AAC7B,kCAAkC,4DAAoB;AACtD;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,aAAa;AACb,yBAAyB,wDAAW;AACpC,SAAS;AACT;AACA;AACA,iEAAe,GAAG,EAAC;;;;;;;;;;;;;;;;;ACtCuB;AACF;AACxC;AACA;AACA,eAAe,wDAAe;AAC9B;AACA,eAAe,mDAAU;AACzB;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA,kDAAkD,wDAAW;AAC7D;AACA;AACA,KAAK;AACL;AACA,iEAAe,KAAK,EAAC;;;;;;;;;;;;;;;;;;AC/BiB;AACN;AACQ;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,gDAAO;AAC/B;AACA;AACA,eAAe,mDAAU;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,wDAAW;AAC3B;AACA;AACA;AACA,KAAK;AACL;AACA,iEAAe,SAAS,EAAC;;;;;;;;;;;;;;;;;;AC5CzB;AACA;AACA;AACA;AACmB;AAC2C;AAC9D,uBAAuB,mDAAS;AAChC,yBAAyB,mDAAS;AAClC,sBAAsB,mDAAS;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,cAAc;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,aAAa;AAChD;AACA;AACA;AACA;AACA,iCAAiC,aAAa;AAC9C;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,gCAAgC;AAChC,mBAAmB;AACnB,kBAAkB;AAClB,mBAAmB;AACnB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,uBAAuB,oBAAoB;AAC3C,yBAAyB,sBAAsB;AAC/C,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,uBAAuB,oBAAoB;AAC3C,yBAAyB,sBAAsB;AAC/C,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,uBAAuB,oBAAoB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,mBAAmB;AACjD,+BAA+B,oBAAoB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,4BAA4B;AACvE,mCAAmC,oBAAoB;AACvD;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB,qBAAqB;AACrB;AACA,iBAAiB;AACjB,2BAA2B,oBAAoB;AAC/C,6BAA6B,mBAAmB;AAChD,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,gDAAgD;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,mDAAS;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA,mCAAmC;AACnC;AACA,IAAI,oDAAU;AACd;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK;AACL;AACA,iEAAe,UAAU,EAAC;;;;;;;;;;;;;;;;;;ACjf1B,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACoD;AACd;AACE;AACxC;AACA;AACA,mBAAmB,mDAAU;AAC7B;AACA;AACA,kCAAkC,4DAAoB;AACtD;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,aAAa;AACb,yBAAyB,wDAAW;AACpC,SAAS;AACT;AACA;AACA,iEAAe,IAAI,EAAC;;;;;;;;;;;;;;;;ACvCkB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,mDAAU;AACzC;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAe,gBAAgB,EAAC;;;;;;;;;;;;;;;ACrChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAe,WAAW,EAAC;;;;;;;;;;;ACZ3B;AACA;AACA,gEAAgE;AAChE;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,qBAAM,gBAAgB,qBAAM;AACtD;AACA;AACA,0CAA0C;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,kDAAkD;AAC3G;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,kEAAkE;AAClE,8BAA8B,gBAAgB,kBAAkB;AAChE;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA,oCAAoC,wBAAwB,iBAAiB;AAC7E,oCAAoC,wBAAwB,IAAI;AAChE;AACA,wCAAwC;AACxC,wCAAwC,oBAAoB;AAC5D;AACA,wCAAwC;AACxC,wCAAwC,kBAAkB;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wGAAwG;AACxG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iFAAiF;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sEAAsE;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sEAAsE;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wEAAwE;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,QAAQ;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,QAAQ;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,uBAAuB;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,0BAA0B;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oEAAoE;AACpE,sEAAsE;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,2BAA2B;AAClE;AACA;AACA,iBAAiB;AACjB,qDAAqD;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,UAAU;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD;AACnD,qDAAqD;AACrD,sDAAsD;AACtD,4DAA4D;AAC5D,8DAA8D;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,wBAAwB;AAC/D;AACA;AACA,iBAAiB;AACjB,uDAAuD;AACvD,uDAAuD;AACvD,0DAA0D;AAC1D,oDAAoD;AACpD,mDAAmD;AACnD,qDAAqD;AACrD,sDAAsD;AACtD,4DAA4D;AAC5D,8DAA8D;AAC9D;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D,yBAAyB;AACtF;AACA;AACA;AACA;AACA,gCAAgC,UAAU;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,oBAAoB;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,CAAC,0BAA0B;;;;;;;;;;;;AC1mCd;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,iBAAiB,GAAG,mBAAmB,GAAG,0BAA0B;AACpE,sBAAsB,mBAAO,CAAC,iEAAe;AAC7C;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA,iBAAiB;;;;;;;;;;;;AChBJ;AACb;AACA;AACA,mCAAmC,oCAAoC,gBAAgB;AACvF,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,gBAAgB,GAAG,yBAAyB,GAAG,cAAc,GAAG,0BAA0B;AAC1F,eAAe,mBAAO,CAAC,uDAAU;AACjC,sDAAqD,EAAE,qCAAqC,uCAAuC,EAAC;AACpI,aAAa,mBAAO,CAAC,mEAAgB;AACrC,cAAc,mBAAO,CAAC,mEAAgB;AACtC,0CAAyC,EAAE,qCAAqC,0BAA0B,EAAC;AAC3G,oBAAoB,mBAAO,CAAC,iEAAe;AAC3C,qDAAoD,EAAE,qCAAqC,2CAA2C,EAAC;AACvI,qBAAqB,mBAAO,CAAC,mEAAgB;AAC7C,4CAA2C,EAAE,qCAAqC,mCAAmC,EAAC;;;;;;;;;;;;ACrBzG;AACb;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,oBAAoB,GAAG,kBAAkB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;;;;;;;;;;;;AC5BL;AACb;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,uBAAuB,GAAG,+BAA+B,GAAG,uBAAuB;AACnF,iCAAiC,mBAAO,CAAC,8FAA0B;AACnE,uBAAuB;AACvB;AACA;AACA;AACA;AACA,oCAAoC,gCAAgC;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D,oBAAoB,EAAE;AACrF;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D,oBAAoB,EAAE;AACrF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,yBAAyB;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA,uBAAuB;;;;;;;;;;;;ACxEV;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,cAAc,GAAG,kBAAkB,GAAG,uBAAuB,GAAG,cAAc,GAAG,aAAa,GAAG,YAAY;AAC7G,yBAAyB,mBAAO,CAAC,sFAAkB;AACnD,mDAAkD,EAAE,qCAAqC,4CAA4C,EAAC;AACtI,aAAa,mBAAO,CAAC,0DAAQ;AAC7B,wCAAuC,EAAE,qCAAqC,uBAAuB,EAAC;AACtG,cAAc,mBAAO,CAAC,4DAAS;AAC/B,yCAAwC,EAAE,qCAAqC,yBAAyB,EAAC;AACzG,eAAe,mBAAO,CAAC,8DAAU;AACjC,0CAAyC,EAAE,qCAAqC,2BAA2B,EAAC;AAC5G;AACA,kBAAkB;AAClB;AACA,cAAc;;;;;;;;;;;;ACdD;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C;AAC7C;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,yBAAyB,GAAG,2BAA2B;AACvD,gCAAgC,mBAAO,CAAC,kDAAO;AAC/C,yBAAyB,mBAAO,CAAC,uEAAgB;AACjD,iBAAiB,mBAAO,CAAC,wDAAW;AACpC,6BAA6B,mBAAO,CAAC,gFAAuB;AAC5D,uBAAuB,mBAAO,CAAC,oEAAiB;AAChD,mBAAmB,mBAAO,CAAC,wEAAmB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,sBAAsB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;;;;;;;;;;;;AChIZ;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,4CAA4C,qBAAqB,KAAK;;;;;;;;;;;;ACd1D;AACb;AACA,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACA;AACA,6CAA6C;AAC7C;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,YAAY,GAAG,cAAc,GAAG,qBAAqB;AACrD,gCAAgC,mBAAO,CAAC,kDAAO;AAC/C,yBAAyB,mBAAO,CAAC,uEAAgB;AACjD,oBAAoB,mBAAO,CAAC,8DAAc;AAC1C,yBAAyB,mBAAO,CAAC,sFAAkB;AACnD,qBAAqB,mBAAO,CAAC,sEAAc;AAC3C,iDAAgD,EAAE,qCAAqC,sCAAsC,EAAC;AAC9H,iBAAiB,mBAAO,CAAC,8DAAU;AACnC,0CAAyC,EAAE,qCAAqC,2BAA2B,EAAC;AAC5G;AACA;AACA;AACA,wBAAwB,cAAc;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA,gBAAgB,0CAA0C;AAC1D,qDAAqD,8CAA8C;AACnG;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,gBAAgB,kBAAkB;AAClC;AACA;AACA;AACA;AACA;AACA,wCAAwC,SAAS,aAAa,SAAS;AACvE;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,oCAAoC,SAAS;AAC7C;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,oCAAoC,SAAS;AAC7C;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,mDAAmD;AACxF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,gBAAgB,2BAA2B;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,QAAQ;AACxC,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,QAAQ;AAC7C;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,0GAA0G,sDAAsD;AAChK,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;;;;;;;;;;;;ACjSC;AACb;AACA,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACA;AACA,6CAA6C;AAC7C;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,aAAa;AACb,gCAAgC,mBAAO,CAAC,kDAAO;AAC/C,yBAAyB,mBAAO,CAAC,uEAAgB;AACjD,iBAAiB,mBAAO,CAAC,wDAAW;AACpC,kBAAkB,mBAAO,CAAC,0DAAY;AACtC,kBAAkB,mBAAO,CAAC,0DAAY;AACtC,iBAAiB,mBAAO,CAAC,oEAAiB;AAC1C,2BAA2B,mBAAO,CAAC,kFAAoB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iJAAiJ,QAAQ;AACzJ;AACA,gBAAgB,yBAAyB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mFAAmF,KAAK;AACxF;AACA,KAAK;AACL;AACA,aAAa;;;;;;;;;;;;AC/IA;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,cAAc;AACd,kBAAkB,mBAAO,CAAC,0DAAY;AACtC;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACrBa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,yBAAyB;AACzB,yBAAyB,mBAAO,CAAC,uEAAgB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,uBAAuB;AAClF;AACA;AACA,iBAAiB;AACjB;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,0BAA0B;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;;;;;;;;;;;;ACjJZ;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,kBAAkB;AAClB;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,kBAAkB;;;;;;;;;;;;ACrBL;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;;;;;;;;;;;;AC3BpB;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,yBAAyB,GAAG,wBAAwB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AClDa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,eAAe,GAAG,qBAAqB,GAAG,kBAAkB,GAAG,eAAe,GAAG,eAAe;AAChG,eAAe;AACf,eAAe;AACf,kBAAkB;AAClB,qBAAqB;AACrB,eAAe;;;;;;;;;;;;ACPF;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,gBAAgB,GAAG,4BAA4B;AAC/C,kBAAkB,mBAAO,CAAC,yDAAW;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;;;;;;;;;;;;AC1BH;AACb;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,uBAAuB;AACvB,kBAAkB,mBAAO,CAAC,0DAAY;AACtC;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,gDAAgD,uBAAuB,KAAK;;;;;;;;;;;;ACZhE;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,yBAAyB,GAAG,yBAAyB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,oDAAoD,yBAAyB,KAAK;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,oDAAoD,yBAAyB,KAAK;;;;;;;;;;;;ACnBtE;AACb;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAe;AACf;AACA;AACA;AACA;;;;;;;;;;;;ACzBa;AACb;AACA,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACA;AACA,6CAA6C;AAC7C;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,cAAc,GAAG,uBAAuB,GAAG,gBAAgB,GAAG,0BAA0B;AACxF,wCAAwC,mBAAO,CAAC,4DAAe;AAC/D,iBAAiB,mBAAO,CAAC,wDAAW;AACpC,uBAAuB,mBAAO,CAAC,oEAAiB;AAChD,mBAAmB,mBAAO,CAAC,wEAAmB;AAC9C,yCAAyC,mBAAO,CAAC,sFAAkB;AACnE,eAAe,mBAAO,CAAC,wDAAW;AAClC,sDAAqD,EAAE,qCAAqC,uCAAuC,EAAC;AACpI,qBAAqB,mBAAO,CAAC,oEAAiB;AAC9C,4CAA2C,EAAE,qCAAqC,mCAAmC,EAAC;AACtH;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,gCAAgC;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,yBAAyB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,mGAAmG,QAAQ;AAC3G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;;;;;AC/MA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,gBAAgB,sCAAsC,kBAAkB;AACnF,0BAA0B;AAC1B;AACA;AACA;AACO;AACP;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACO;AACP;AACA,iDAAiD,OAAO;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA,6DAA6D,cAAc;AAC3E;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,6CAA6C,QAAQ;AACrD;AACA;AACA;AACO;AACP,oCAAoC;AACpC;AACA;AACO;AACP;AACA;AACA;AACO;AACP,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACA;AACO;AACP,cAAc,6BAA6B,0BAA0B,cAAc,qBAAqB;AACxG,iBAAiB,oDAAoD,qEAAqE,cAAc;AACxJ,uBAAuB,sBAAsB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC;AACxC,mCAAmC,SAAS;AAC5C,mCAAmC,WAAW,UAAU;AACxD,0CAA0C,cAAc;AACxD;AACA,8GAA8G,OAAO;AACrH,iFAAiF,iBAAiB;AAClG,yDAAyD,gBAAgB,QAAQ;AACjF,+CAA+C,gBAAgB,gBAAgB;AAC/E;AACA,kCAAkC;AAClC;AACA;AACA,UAAU,YAAY,aAAa,SAAS,UAAU;AACtD,oCAAoC,SAAS;AAC7C;AACA;AACA;AACO;AACP;AACA,mCAAmC,oCAAoC,gBAAgB;AACvF,CAAC;AACD;AACA;AACA,CAAC;AACD;AACO;AACP;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,MAAM;AAC1B;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACO;AACP,6BAA6B,sBAAsB;AACnD;AACA;AACA;AACA;AACA;AACO;AACP,kDAAkD,QAAQ;AAC1D,yCAAyC,QAAQ;AACjD,yDAAyD,QAAQ;AACjE;AACA;AACA;AACA;AACO;AACP,6EAA6E,OAAO;AACpF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACO;AACP;AACA;AACA,iBAAiB,uFAAuF,cAAc;AACtH,uBAAuB,gCAAgC,qCAAqC,2CAA2C;AACvI,4BAA4B,MAAM,iBAAiB,YAAY;AAC/D,uBAAuB;AACvB,8BAA8B;AAC9B,6BAA6B;AAC7B,4BAA4B;AAC5B;AACA;AACO;AACP;AACA,iBAAiB,6CAA6C,UAAU,sDAAsD,cAAc;AAC5I,0BAA0B,6BAA6B,oBAAoB,gDAAgD,kBAAkB;AAC7I;AACA;AACO;AACP;AACA;AACA,2GAA2G,uFAAuF,cAAc;AAChN,uBAAuB,8BAA8B,gDAAgD,wDAAwD;AAC7J,6CAA6C,sCAAsC,UAAU,mBAAmB,IAAI;AACpH;AACA;AACO;AACP,iCAAiC,uCAAuC,YAAY,KAAK,OAAO;AAChG;AACA;AACA;AACA;AACA,0CAA0C,4BAA4B;AACtE,CAAC;AACD;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,6CAA6C;AAC7C;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;AC9OoF;AACpC;AACc;AACqF;AAC5I;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,8CAAQ;AACpC;AACA,aAAa,uDAAS,EAAE,8CAAQ;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA,kBAAkB,wDAAc;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAiE;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,uBAAuB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,4EAAqC;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,eAAe,6DAAc,iBAAiB,2DAAY;AAC1D;AACA;AACA,CAAC;AACuB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,gDAAM;AAChB;AACA,4DAA4D,gDAAM;AAClE;AACA;AACA;AACA;AACA,gDAAgD,gDAAM;AACtD;AACA;AACA;AACA,iDAAiD,gDAAM;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,4EAAqC;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,qDAAW;AACvB;AACA,mCAAmC,4EAAqC;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,2DAAY;AACzC;AACA;AACA,qCAAqC,gDAAM;AAC3C,mCAAmC,2DAAY;AAC/C;AACA;AACA;AACA,kDAAkD,2CAA2C,sEAAoB,oBAAoB;AACrI,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,wDAAc;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,gDAAM;AAC7C;AACA;AACA;AACA,wDAAwD,gDAAM;AAC9D,uCAAuC,gDAAM;AAC7C,uCAAuC,gDAAM;AAC7C,kCAAkC,gDAAM;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,gDAAM;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qGAAqG,oEAAsB;AAC3H,SAAS;AACT;AACA;AACA;AACA;AACA,oCAAoC,iEAAmB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,oCAAoC,+DAAiB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,+DAAiB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,wDAAc;AAClC;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,oBAAoB,wDAAc;AAClC;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,YAAY;AACvD;AACA;AACA;AACA;AACA;AACA;AACA,4EAA4E,sBAAsB;AAClG;AACA;AACA;AACA;AACA;AACA;AACA,4EAA4E,sBAAsB;AAClG,mEAAmE,iBAAiB;AACpF;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACpZuC;AACE;AAClC;AACA;AACP;AACO;AACP;AACA;AACO;AACP;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACO;AACP;AACA,qBAAqB,uBAAuB;AAC5C;AACA;AACA;AACA,qCAAqC,qDAAc;AACnD;AACA;AACA,mCAAmC,qDAAc;AACjD;AACA;AACO;AACP;AACA,qBAAqB,uBAAuB;AAC5C;AACA;AACA;AACA,mCAAmC,qDAAc;AACjD;AACA;AACO;AACP;AACA,qBAAqB,uBAAuB;AAC5C;AACA;AACA;AACA,oCAAoC,qDAAc;AAClD;AACA;AACA,mCAAmC,qDAAc;AACjD;AACA;AACO;AACP;AACA;AACO;AACP,wBAAwB,uDAAS;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACA;AACP;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;;;;;;;;;;;;;;;;;;;ACjHmG;AAC3C;AACL;AAC6C;AACzF;AACP,8BAA8B;AAC9B;AACA;AACA,qDAAqD,gDAAM;AAC3D,wBAAwB,iEAAe;AACvC;AACA;AACA,YAAY,kDAAQ;AACpB;AACA;AACA,4BAA4B,gEAA0B;AACtD;AACA;AACA;AACA,YAAY,kDAAQ,kDAAkD,8DAAwB;AAC9F;AACA;AACA,QAAQ,oEAAyB;AACjC,gCAAgC,uBAAuB,sEAAoB,6BAA6B;AACxG;AACA;AACA,qBAAqB,gEAAiB;AACtC;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACO;AACP,mBAAmB,iEAAmB;AACtC,oBAAoB,gBAAgB;AACpC,mBAAmB,iEAAmB;AACtC;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;ACzCmG;AAC3C;AACL;AACO;AACnD;AACP,8BAA8B;AAC9B;AACA;AACA,mDAAmD,gDAAM;AACzD,uBAAuB,iEAAe;AACtC,yBAAyB,iEAAe;AACxC,4BAA4B,gEAA0B;AACtD;AACA;AACA;AACA,YAAY,kDAAQ,+CAA+C,8DAAwB;AAC3F;AACA;AACA,QAAQ,oEAAyB;AACjC,gCAAgC,OAAO,sDAAI,6BAA6B,sBAAsB,IAAI;AAClG;AACA;AACA,qBAAqB,gEAAiB;AACtC;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;;;;;;;;;;;;;;;;;AC9BoK;AAC5G;AACL;AAC4H;AACxK;AACP;AACA;AACA;AACA,gDAAgD,gDAAM;AACtD,aAAa,gEAA0B;AACvC,YAAY,kDAAQ;AACpB;AACA;AACA;AACA;AACA,YAAY,kDAAQ,6GAA6G,2DAAqB,aAAa,8DAAwB;AAC3L;AACA;AACA,+BAA+B,sEAAoB;AACnD;AACA;AACA;AACA,QAAQ,oEAAyB;AACjC,gCAAgC,0BAA0B;AAC1D;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,gDAAM;AACtD;AACA,YAAY,4DAAU,mBAAmB,6DAAW;AACpD,wBAAwB,iEAAe;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,wDAAc;AAC/B,gBAAgB,kDAAQ,kFAAkF,2DAAqB;AAC/H;AACA;AACA,sCAAsC,sEAAoB;AAC1D,sCAAsC;AACtC,gBAAgB,gEAA0B,KAAK,qDAAW;AAC1D,gBAAgB,oDAAU;AAC1B;AACA;AACA;AACA;AACA;AACA,iBAAiB,gEAA0B;AAC3C;AACA;AACA,gBAAgB,kDAAQ,iFAAiF,2DAAqB;AAC9H;AACA;AACA,sCAAsC,OAAO,sEAAoB;AACjE;AACA;AACA,YAAY,kDAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,oEAAyB;AACjC;AACA;AACA,gCAAgC,OAAO,sEAAoB,gBAAgB;AAC3E;AACA;AACA,qBAAqB,gEAAiB;AACtC;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,2BAA2B,4DAAc;AACzC;AACA;AACA,oCAAoC,iEAAmB;AACvD;AACA,QAAQ,kDAAQ;AAChB;AACA;AACA;AACA,oCAAoC,+DAAiB;AACrD,QAAQ,kDAAQ;AAChB;AACA;AACA;AACA,oCAAoC,+DAAiB;AACrD,QAAQ,kDAAQ;AAChB;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AChHgD;AACG;AAC5C;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,kFAA2C;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,gEAAiB;AAC3C;AACA;AACA;AACA;AACA;AACA,+CAA+C,4BAA4B;AAC3E,gDAAgD,kDAAkD;AAClG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;AC1CmG;AAC3C;AACL;AACO;AACnD;AACP,8BAA8B;AAC9B;AACA;AACA,mDAAmD,gDAAM;AACzD,wBAAwB,iEAAe;AACvC,4BAA4B,gEAA0B;AACtD;AACA;AACA;AACA,YAAY,kDAAQ,+CAA+C,8DAAwB;AAC3F;AACA;AACA,QAAQ,oEAAyB;AACjC,gCAAgC,OAAO,sDAAI,gBAAgB;AAC3D;AACA;AACA,qBAAqB,gEAAiB;AACtC;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;;;;;;;;;;;;;;;;AC7BiG;AAC1F;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,gDAAM,SAAS,gDAAM;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,wCAAwC,gDAAM,gBAAgB,gDAAM;AACpE;AACA;AACA,eAAe,0EAAgC,UAAU,0DAAgB;AACzE;AACA;AACA;AACA;AACA;AACA,6DAA6D,oCAAoC;AACjG,SAAS;AACT;AACA;AACA;AACA,CAAC;AAC6B;AACvB;AACP,4CAA4C,gDAAM;AAClD;AACA,QAAQ,kDAAQ;AAChB;AACA;AACA;AACA,QAAQ,kDAAQ;AAChB;AACA;AACA;AACA;AACA,QAAQ,kDAAQ;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,+DAA+D;AACjG;AACA;AACA;;;;;;;;;;;;;;;;;;AClGiC;AACjC;AACA;AACA;AACO;AACP;AACA,iCAAiC,uCAAuC;AACxE;AACA;AACA;AACA,KAAK,IAAI;AACT;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,UAAU,+CAAQ,CAAC,+CAAQ,GAAG;AAC9B;AACA;;;;;;;;;;;;;;;;;;;;AC/BiC;AACqD;AACtC;AACc;AAC6D;AACpH;AACP;AACA;AACA,sKAAsK,gDAAM;AAC5K;AACA;AACA;AACA;AACA;AACA,4BAA4B,8CAAQ;AACpC;AACA,aAAa,uDAAS,EAAE,8CAAQ;AAChC,mBAAmB,8CAAQ;AAC3B,qBAAqB,8CAAQ;AAC7B,qBAAqB,8CAAQ;AAC7B,sBAAsB,8CAAQ;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,6DAAc,iBAAiB,2DAAY;AAC1D;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA,aAAa,wDAAc;AAC3B;AACA;AACA,aAAa,sDAAY;AACzB,+BAA+B,gDAAM;AACrC,6BAA6B,gDAAM;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACqB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,4EAAqC;AAClE;AACA;AACA,6BAA6B,4EAAqC;AAClE;AACA;AACA,uBAAuB,+CAAQ,GAAG;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,gDAAM;AAC7B;AACA;AACA;AACA;AACA;AACA,6BAA6B,2DAAY;AACzC;AACA;AACA;AACA;AACA,mCAAmC,2DAAY;AAC/C;AACA;AACA;AACA,kDAAkD,yCAAyC,sEAAoB,QAAQ;AACvH,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,0HAA0H,gDAAM;AAChI;AACA;AACA,mBAAmB,wDAAc;AACjC;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,oCAAoC,iEAAmB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,sDAAY;AAC5B,mCAAmC,gDAAM;AACzC,4CAA4C,gDAAM;AAClD;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,oCAAoC,+DAAiB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,wDAAc,aAAa,wDAAc;AACtD;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,oCAAoC,+DAAiB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC;AACxC;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,wDAAc;AACvC;AACA,eAAe,wDAAc;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,uCAAuC;AAC1E;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC5OkC;AACgB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACyB;AAC1B;AACA,IAAI,gDAAS;AACb;AACA;AACA;AACA;AACA,CAAC;AACiC;AAClC;AACA,IAAI,gDAAS;AACb;AACA;AACA;AACA;AACA,CAAC;AACgC;AACjC;AACA,IAAI,gDAAS;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AAC8B;AACxB;AACP;AACA;AACA;AACA,IAAI,gDAAS;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AAC4B;AACtB;AACP;AACA;AACA;AACA,IAAI,gDAAS;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AAC4B;AACtB;AACP;AACA;AACO,oDAAoD,mBAAmB;AACvE;AACP;AACA;AACO;AACP;AACA;AACO;AACP;AACA;AACO;AACP;AACA,qEAAqE,2DAAqB;AAC1F;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;;;;;;;;;;;;;;AC1GA;AACA,iEAAe;AACf;AACA,CAAC;;;;;;;;;;;;;;;ACHoC;;AAErC;AACA,OAAO,wDAAQ;AACf;AACA;;AAEA;AACA,kCAAkC;;AAElC;AACA;AACA;AACA,qBAAqB;;AAErB;AACA,qBAAqB;;AAErB;AACA,qBAAqB;;AAErB;AACA,qBAAqB;AACrB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,iEAAe,KAAK;;;;;;;;;;;;;;AClCpB,iEAAe,cAAc,EAAE,UAAU,EAAE,eAAe,EAAE,gBAAgB,EAAE,UAAU,GAAG,yCAAyC;;;;;;;;;;;;;;ACApI;AACA;AACA;AACA;AACA;AACe;AACf;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;;;;;;;ACjBA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,qDAAqD;;AAErD;;AAEA,oBAAoB,gBAAgB;AACpC;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,kBAAkB,OAAO;AACzB;;AAEA,oBAAoB,QAAQ;AAC5B;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,kBAAkB,OAAO;AACzB;;AAEA,oBAAoB,QAAQ;AAC5B;AACA;;AAEA,qBAAqB,QAAQ;AAC7B;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,oBAAoB,QAAQ;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,iEAAe,IAAI;;;;;;;;;;;;;;;AC/FkB;AACrC;AACA;AACA;AACA;;AAEA;;AAEA,gBAAgB,SAAS;AACzB;AACA;;AAEO;AACP;AACA;AACA;AACA;;AAEA;AACA,6CAA6C;AAC7C;AACA;AACA;AACA;;AAEA,OAAO,wDAAQ;AACf;AACA;;AAEA;AACA;;AAEA,sEAAe,SAAS;;;;;;;;;;;;;;;;;AChCyB;AAClB;;AAE/B;AACA,2CAA2C;;AAE3C;;AAEA,kBAAkB,gBAAgB;AAClC;AACA;;AAEA;AACA;;AAEO;AACA;AACQ;AACf;AACA;;AAEA;AACA;AACA;;AAEA;AACA,kBAAkB,qDAAK;AACvB;;AAEA;AACA;AACA,MAAM;AACN;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,sBAAsB,QAAQ;AAC9B;AACA;;AAEA;AACA;;AAEA,WAAW,8DAAe;AAC1B,IAAI;;;AAGJ;AACA,8BAA8B;AAC9B,IAAI,eAAe;;;AAGnB;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACjEiC;AACN;AACsB;;AAEjD;AACA,MAAM,6DAAiB;AACvB,WAAW,6DAAiB;AAC5B;;AAEA;AACA,iDAAiD,+CAAG,KAAK;;AAEzD;AACA,mCAAmC;;AAEnC;AACA;;AAEA,oBAAoB,QAAQ;AAC5B;AACA;;AAEA;AACA;;AAEA,SAAS,8DAAe;AACxB;;AAEA,iEAAe,EAAE;;;;;;;;;;;;;;;;AC5BU;AACE;AAC7B,WAAW,mDAAG,aAAa,gDAAI;AAC/B,iEAAe,EAAE;;;;;;;;;;;;;;;ACHc;;AAE/B;AACA,qCAAqC,sDAAU;AAC/C;;AAEA,iEAAe,QAAQ;;;;;;;;;;ACNvB;;;;;;;;;;ACAA;;;;;;;;;;;;;;;;;;ACAqC;;AAE9B,2BAA2B,8DAA0B;AACrD,cAAc,iDAAa;AAC3B,mBAAmB,sDAAkB;AACrC,0BAA0B,6DAAyB;AACnD,aAAa,gDAAY;AACzB,eAAe,kDAAc;AAC7B,iBAAiB,oDAAgB;AACjC,eAAe,kDAAc;;;;;;;UCTpC;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;UAEA;UACA;;;;;WC5BA;WACA;WACA;WACA;WACA;WACA,iCAAiC,WAAW;WAC5C;WACA;;;;;WCPA;WACA;WACA;WACA;WACA,yCAAyC,wCAAwC;WACjF;WACA;WACA;;;;;WCPA;WACA;WACA;WACA;WACA,GAAG;WACH;WACA;WACA,CAAC;;;;;WCPD;;;;;WCAA;WACA;WACA;WACA,uDAAuD,iBAAiB;WACxE;WACA,gDAAgD,aAAa;WAC7D;;;;;WCNA;WACA;WACA;WACA;WACA;;;;;UEJA;UACA;UACA;UACA","sources":["webpack://OpenHPS.core/webpack/universalModuleDefinition","webpack://OpenHPS.core/./dist/esm5/ModelBuilder.js","webpack://OpenHPS.core/./dist/esm5/ModelSerializer.js","webpack://OpenHPS.core/./dist/esm5/Node.js","webpack://OpenHPS.core/./dist/esm5/_internal/AsyncEventEmitter.js","webpack://OpenHPS.core/./dist/esm5/data/DataFrame.js","webpack://OpenHPS.core/./dist/esm5/data/DataSerializer.js","webpack://OpenHPS.core/./dist/esm5/data/DataSerializerUtils.js","webpack://OpenHPS.core/./dist/esm5/data/Deserializer.js","webpack://OpenHPS.core/./dist/esm5/data/Serializer.js","webpack://OpenHPS.core/./dist/esm5/data/decorators/SerializableArrayMember.js","webpack://OpenHPS.core/./dist/esm5/data/decorators/SerializableMapMember.js","webpack://OpenHPS.core/./dist/esm5/data/decorators/SerializableMember.js","webpack://OpenHPS.core/./dist/esm5/data/decorators/SerializableMemberFunction.js","webpack://OpenHPS.core/./dist/esm5/data/decorators/SerializableObject.js","webpack://OpenHPS.core/./dist/esm5/data/decorators/SerializableSetMember.js","webpack://OpenHPS.core/./dist/esm5/data/decorators/index.js","webpack://OpenHPS.core/./dist/esm5/data/decorators/options.js","webpack://OpenHPS.core/./dist/esm5/data/decorators/utils.js","webpack://OpenHPS.core/./dist/esm5/data/index.js","webpack://OpenHPS.core/./dist/esm5/data/object/DataObject.js","webpack://OpenHPS.core/./dist/esm5/data/object/SensorObject.js","webpack://OpenHPS.core/./dist/esm5/data/object/index.js","webpack://OpenHPS.core/./dist/esm5/data/object/sensors/AbsoluteOrientationSensor.js","webpack://OpenHPS.core/./dist/esm5/data/object/sensors/Accelerometer.js","webpack://OpenHPS.core/./dist/esm5/data/object/sensors/GravitySensor.js","webpack://OpenHPS.core/./dist/esm5/data/object/sensors/Gyroscope.js","webpack://OpenHPS.core/./dist/esm5/data/object/sensors/LinearAccelerationSensor.js","webpack://OpenHPS.core/./dist/esm5/data/object/sensors/LinearVelocitySensor.js","webpack://OpenHPS.core/./dist/esm5/data/object/sensors/Magnetometer.js","webpack://OpenHPS.core/./dist/esm5/data/object/sensors/RelativeOrientationSensor.js","webpack://OpenHPS.core/./dist/esm5/data/object/sensors/index.js","webpack://OpenHPS.core/./dist/esm5/data/object/space/ReferenceSpace.js","webpack://OpenHPS.core/./dist/esm5/data/object/space/index.js","webpack://OpenHPS.core/./dist/esm5/data/position/Absolute2DPosition.js","webpack://OpenHPS.core/./dist/esm5/data/position/Absolute3DPosition.js","webpack://OpenHPS.core/./dist/esm5/data/position/AbsolutePosition.js","webpack://OpenHPS.core/./dist/esm5/data/position/GeographicalPosition.js","webpack://OpenHPS.core/./dist/esm5/data/position/Orientation.js","webpack://OpenHPS.core/./dist/esm5/data/position/Pose.js","webpack://OpenHPS.core/./dist/esm5/data/position/RelativeAngle.js","webpack://OpenHPS.core/./dist/esm5/data/position/RelativeAngularVelocity.js","webpack://OpenHPS.core/./dist/esm5/data/position/RelativeDistance.js","webpack://OpenHPS.core/./dist/esm5/data/position/RelativeLinearVelocity.js","webpack://OpenHPS.core/./dist/esm5/data/position/RelativePosition.js","webpack://OpenHPS.core/./dist/esm5/data/position/Trajectory.js","webpack://OpenHPS.core/./dist/esm5/data/position/index.js","webpack://OpenHPS.core/./dist/esm5/data/values/Acceleration.js","webpack://OpenHPS.core/./dist/esm5/data/values/Accuracy.js","webpack://OpenHPS.core/./dist/esm5/data/values/Accuracy1D.js","webpack://OpenHPS.core/./dist/esm5/data/values/Accuracy2D.js","webpack://OpenHPS.core/./dist/esm5/data/values/Accuracy3D.js","webpack://OpenHPS.core/./dist/esm5/data/values/AngularVelocity.js","webpack://OpenHPS.core/./dist/esm5/data/values/Humidity.js","webpack://OpenHPS.core/./dist/esm5/data/values/LinearVelocity.js","webpack://OpenHPS.core/./dist/esm5/data/values/Magnetism.js","webpack://OpenHPS.core/./dist/esm5/data/values/Pressure.js","webpack://OpenHPS.core/./dist/esm5/data/values/SensorValue.js","webpack://OpenHPS.core/./dist/esm5/data/values/Temperature.js","webpack://OpenHPS.core/./dist/esm5/data/values/Velocity.js","webpack://OpenHPS.core/./dist/esm5/data/values/index.js","webpack://OpenHPS.core/./dist/esm5/graph/Edge.js","webpack://OpenHPS.core/./dist/esm5/graph/_internal/GraphNode.js","webpack://OpenHPS.core/./dist/esm5/graph/_internal/implementations/GraphShape.js","webpack://OpenHPS.core/./dist/esm5/graph/_internal/implementations/GraphValidator.js","webpack://OpenHPS.core/./dist/esm5/graph/_internal/implementations/ModelGraph.js","webpack://OpenHPS.core/./dist/esm5/graph/builders/GraphBuilder.js","webpack://OpenHPS.core/./dist/esm5/graph/builders/index.js","webpack://OpenHPS.core/./dist/esm5/graph/events/PushError.js","webpack://OpenHPS.core/./dist/esm5/graph/events/index.js","webpack://OpenHPS.core/./dist/esm5/graph/index.js","webpack://OpenHPS.core/./dist/esm5/index.js","webpack://OpenHPS.core/./dist/esm5/nodes/CallbackNode.js","webpack://OpenHPS.core/./dist/esm5/nodes/GraphShapeNode.js","webpack://OpenHPS.core/./dist/esm5/nodes/ObjectProcessingNode.js","webpack://OpenHPS.core/./dist/esm5/nodes/ProcessingNode.js","webpack://OpenHPS.core/./dist/esm5/nodes/RemoteNode.js","webpack://OpenHPS.core/./dist/esm5/nodes/SinkNode.js","webpack://OpenHPS.core/./dist/esm5/nodes/SourceNode.js","webpack://OpenHPS.core/./dist/esm5/nodes/WorkerNode.js","webpack://OpenHPS.core/./dist/esm5/nodes/_internal/PlaceholderNode.js","webpack://OpenHPS.core/./dist/esm5/nodes/index.js","webpack://OpenHPS.core/./dist/esm5/nodes/processing/AccuracyModifierNode.js","webpack://OpenHPS.core/./dist/esm5/nodes/processing/CellIdentificationNode.js","webpack://OpenHPS.core/./dist/esm5/nodes/processing/MultilaterationNode.js","webpack://OpenHPS.core/./dist/esm5/nodes/processing/ReferenceSpaceConversionNode.js","webpack://OpenHPS.core/./dist/esm5/nodes/processing/RelativePositionProcessing.js","webpack://OpenHPS.core/./dist/esm5/nodes/processing/TriangulationNode.js","webpack://OpenHPS.core/./dist/esm5/nodes/processing/dsp/EMAFilterNode.js","webpack://OpenHPS.core/./dist/esm5/nodes/processing/dsp/FilterProcessingNode.js","webpack://OpenHPS.core/./dist/esm5/nodes/processing/dsp/HPFilterNode.js","webpack://OpenHPS.core/./dist/esm5/nodes/processing/dsp/KalmanFilterNode.js","webpack://OpenHPS.core/./dist/esm5/nodes/processing/dsp/LPFilterNode.js","webpack://OpenHPS.core/./dist/esm5/nodes/processing/dsp/PropertyFilterProcessingNode.js","webpack://OpenHPS.core/./dist/esm5/nodes/processing/dsp/RelativePositionFilter.js","webpack://OpenHPS.core/./dist/esm5/nodes/processing/dsp/SMAFilterNode.js","webpack://OpenHPS.core/./dist/esm5/nodes/processing/dsp/index.js","webpack://OpenHPS.core/./dist/esm5/nodes/processing/index.js","webpack://OpenHPS.core/./dist/esm5/nodes/shapes/BalanceNode.js","webpack://OpenHPS.core/./dist/esm5/nodes/shapes/BroadcastNode.js","webpack://OpenHPS.core/./dist/esm5/nodes/shapes/BufferNode.js","webpack://OpenHPS.core/./dist/esm5/nodes/shapes/FrameChunkNode.js","webpack://OpenHPS.core/./dist/esm5/nodes/shapes/FrameCloneNode.js","webpack://OpenHPS.core/./dist/esm5/nodes/shapes/FrameDelayNode.js","webpack://OpenHPS.core/./dist/esm5/nodes/shapes/FrameFilterNode.js","webpack://OpenHPS.core/./dist/esm5/nodes/shapes/FrameFlattenNode.js","webpack://OpenHPS.core/./dist/esm5/nodes/shapes/FrameMergeNode.js","webpack://OpenHPS.core/./dist/esm5/nodes/shapes/MemoryBufferNode.js","webpack://OpenHPS.core/./dist/esm5/nodes/shapes/MergeShape.js","webpack://OpenHPS.core/./dist/esm5/nodes/shapes/ObjectMergeNode.js","webpack://OpenHPS.core/./dist/esm5/nodes/shapes/SourceMergeNode.js","webpack://OpenHPS.core/./dist/esm5/nodes/shapes/ThrottleNode.js","webpack://OpenHPS.core/./dist/esm5/nodes/shapes/TimeSyncNode.js","webpack://OpenHPS.core/./dist/esm5/nodes/shapes/TimedPullNode.js","webpack://OpenHPS.core/./dist/esm5/nodes/shapes/UnitConversionNode.js","webpack://OpenHPS.core/./dist/esm5/nodes/shapes/index.js","webpack://OpenHPS.core/./dist/esm5/nodes/sink/CallbackSinkNode.js","webpack://OpenHPS.core/./dist/esm5/nodes/sink/LoggingSinkNode.js","webpack://OpenHPS.core/./dist/esm5/nodes/sink/RemoteSinkNode.js","webpack://OpenHPS.core/./dist/esm5/nodes/sink/index.js","webpack://OpenHPS.core/./dist/esm5/nodes/source/CallbackSourceNode.js","webpack://OpenHPS.core/./dist/esm5/nodes/source/HistorySourceNode.js","webpack://OpenHPS.core/./dist/esm5/nodes/source/ListSourceNode.js","webpack://OpenHPS.core/./dist/esm5/nodes/source/RemoteSourceNode.js","webpack://OpenHPS.core/./dist/esm5/nodes/source/index.js","webpack://OpenHPS.core/./dist/esm5/service/DataFrameService.js","webpack://OpenHPS.core/./dist/esm5/service/DataObjectService.js","webpack://OpenHPS.core/./dist/esm5/service/DataService.js","webpack://OpenHPS.core/./dist/esm5/service/DataServiceDriver.js","webpack://OpenHPS.core/./dist/esm5/service/DummyDataService.js","webpack://OpenHPS.core/./dist/esm5/service/DummyService.js","webpack://OpenHPS.core/./dist/esm5/service/KeyValueDataService.js","webpack://OpenHPS.core/./dist/esm5/service/LocationBasedService.js","webpack://OpenHPS.core/./dist/esm5/service/MemoryDataService.js","webpack://OpenHPS.core/./dist/esm5/service/MemoryQueryEvaluator.js","webpack://OpenHPS.core/./dist/esm5/service/NodeDataService.js","webpack://OpenHPS.core/./dist/esm5/service/RemoteService.js","webpack://OpenHPS.core/./dist/esm5/service/Service.js","webpack://OpenHPS.core/./dist/esm5/service/TimeService.js","webpack://OpenHPS.core/./dist/esm5/service/TrajectoryService.js","webpack://OpenHPS.core/./dist/esm5/service/WorkerServiceProxy.js","webpack://OpenHPS.core/./dist/esm5/service/_internal/DataServiceProxy.js","webpack://OpenHPS.core/./dist/esm5/service/_internal/ServiceProxy.js","webpack://OpenHPS.core/./dist/esm5/service/index.js","webpack://OpenHPS.core/./dist/esm5/three/math/Euler.js","webpack://OpenHPS.core/./dist/esm5/three/math/MathUtils.js","webpack://OpenHPS.core/./dist/esm5/three/math/Matrix3.js","webpack://OpenHPS.core/./dist/esm5/three/math/Matrix4.js","webpack://OpenHPS.core/./dist/esm5/three/math/Quaternion.js","webpack://OpenHPS.core/./dist/esm5/three/math/Vector2.js","webpack://OpenHPS.core/./dist/esm5/three/math/Vector3.js","webpack://OpenHPS.core/./dist/esm5/three/math/Vector4.js","webpack://OpenHPS.core/./dist/esm5/utils/DistanceFunction.js","webpack://OpenHPS.core/./dist/esm5/utils/index.js","webpack://OpenHPS.core/./dist/esm5/utils/math/AxisAngle.js","webpack://OpenHPS.core/./dist/esm5/utils/math/Euler.js","webpack://OpenHPS.core/./dist/esm5/utils/math/Matrix3.js","webpack://OpenHPS.core/./dist/esm5/utils/math/Matrix4.js","webpack://OpenHPS.core/./dist/esm5/utils/math/Quaternion.js","webpack://OpenHPS.core/./dist/esm5/utils/math/Vector2.js","webpack://OpenHPS.core/./dist/esm5/utils/math/Vector3.js","webpack://OpenHPS.core/./dist/esm5/utils/math/Vector4.js","webpack://OpenHPS.core/./dist/esm5/utils/math/index.js","webpack://OpenHPS.core/./dist/esm5/utils/unit/AccelerationUnit.js","webpack://OpenHPS.core/./dist/esm5/utils/unit/AngleUnit.js","webpack://OpenHPS.core/./dist/esm5/utils/unit/AngularVelocityUnit.js","webpack://OpenHPS.core/./dist/esm5/utils/unit/DerivedUnit.js","webpack://OpenHPS.core/./dist/esm5/utils/unit/GCS.js","webpack://OpenHPS.core/./dist/esm5/utils/unit/LengthUnit.js","webpack://OpenHPS.core/./dist/esm5/utils/unit/LinearVelocityUnit.js","webpack://OpenHPS.core/./dist/esm5/utils/unit/LuminanceIntensityUnit.js","webpack://OpenHPS.core/./dist/esm5/utils/unit/LuminanceUnit.js","webpack://OpenHPS.core/./dist/esm5/utils/unit/MagnetismUnit.js","webpack://OpenHPS.core/./dist/esm5/utils/unit/PressureUnit.js","webpack://OpenHPS.core/./dist/esm5/utils/unit/TemperatureUnit.js","webpack://OpenHPS.core/./dist/esm5/utils/unit/TimeUnit.js","webpack://OpenHPS.core/./dist/esm5/utils/unit/Unit.js","webpack://OpenHPS.core/./dist/esm5/utils/unit/UnitPrefix.js","webpack://OpenHPS.core/./dist/esm5/utils/unit/UnitValue.js","webpack://OpenHPS.core/./dist/esm5/utils/unit/index.js","webpack://OpenHPS.core/./dist/esm5/worker/WorkerHandler.js","webpack://OpenHPS.core/./dist/esm5/worker/index.js","webpack://OpenHPS.core/./node_modules/debug/src/browser.js","webpack://OpenHPS.core/./node_modules/debug/src/common.js","webpack://OpenHPS.core/./node_modules/events/events.js","webpack://OpenHPS.core/./node_modules/is-observable/index.js","webpack://OpenHPS.core/./node_modules/lodash.clonedeep/index.js","webpack://OpenHPS.core/./node_modules/ms/index.js","webpack://OpenHPS.core/./node_modules/observable-fns/dist.esm/_scheduler.js","webpack://OpenHPS.core/./node_modules/observable-fns/dist.esm/_symbols.js","webpack://OpenHPS.core/./node_modules/observable-fns/dist.esm/_util.js","webpack://OpenHPS.core/./node_modules/observable-fns/dist.esm/filter.js","webpack://OpenHPS.core/./node_modules/observable-fns/dist.esm/flatMap.js","webpack://OpenHPS.core/./node_modules/observable-fns/dist.esm/index.js","webpack://OpenHPS.core/./node_modules/observable-fns/dist.esm/interval.js","webpack://OpenHPS.core/./node_modules/observable-fns/dist.esm/map.js","webpack://OpenHPS.core/./node_modules/observable-fns/dist.esm/merge.js","webpack://OpenHPS.core/./node_modules/observable-fns/dist.esm/multicast.js","webpack://OpenHPS.core/./node_modules/observable-fns/dist.esm/observable.js","webpack://OpenHPS.core/./node_modules/observable-fns/dist.esm/scan.js","webpack://OpenHPS.core/./node_modules/observable-fns/dist.esm/subject.js","webpack://OpenHPS.core/./node_modules/observable-fns/dist.esm/unsubscribe.js","webpack://OpenHPS.core/./node_modules/reflect-metadata/Reflect.js","webpack://OpenHPS.core/./node_modules/threads/dist/common.js","webpack://OpenHPS.core/./node_modules/threads/dist/index.js","webpack://OpenHPS.core/./node_modules/threads/dist/master/get-bundle-url.browser.js","webpack://OpenHPS.core/./node_modules/threads/dist/master/implementation.browser.js","webpack://OpenHPS.core/./node_modules/threads/dist/master/index.js","webpack://OpenHPS.core/./node_modules/threads/dist/master/invocation-proxy.js","webpack://OpenHPS.core/./node_modules/threads/dist/master/pool-types.js","webpack://OpenHPS.core/./node_modules/threads/dist/master/pool.js","webpack://OpenHPS.core/./node_modules/threads/dist/master/spawn.js","webpack://OpenHPS.core/./node_modules/threads/dist/master/thread.js","webpack://OpenHPS.core/./node_modules/threads/dist/observable-promise.js","webpack://OpenHPS.core/./node_modules/threads/dist/ponyfills.js","webpack://OpenHPS.core/./node_modules/threads/dist/promise.js","webpack://OpenHPS.core/./node_modules/threads/dist/serializers.js","webpack://OpenHPS.core/./node_modules/threads/dist/symbols.js","webpack://OpenHPS.core/./node_modules/threads/dist/transferable.js","webpack://OpenHPS.core/./node_modules/threads/dist/types/master.js","webpack://OpenHPS.core/./node_modules/threads/dist/types/messages.js","webpack://OpenHPS.core/./node_modules/threads/dist/worker/implementation.browser.js","webpack://OpenHPS.core/./node_modules/threads/dist/worker/index.js","webpack://OpenHPS.core/./node_modules/tslib/tslib.es6.js","webpack://OpenHPS.core/./node_modules/typedjson/lib/esm5/deserializer.js","webpack://OpenHPS.core/./node_modules/typedjson/lib/esm5/helpers.js","webpack://OpenHPS.core/./node_modules/typedjson/lib/esm5/json-array-member.js","webpack://OpenHPS.core/./node_modules/typedjson/lib/esm5/json-map-member.js","webpack://OpenHPS.core/./node_modules/typedjson/lib/esm5/json-member.js","webpack://OpenHPS.core/./node_modules/typedjson/lib/esm5/json-object.js","webpack://OpenHPS.core/./node_modules/typedjson/lib/esm5/json-set-member.js","webpack://OpenHPS.core/./node_modules/typedjson/lib/esm5/metadata.js","webpack://OpenHPS.core/./node_modules/typedjson/lib/esm5/options-base.js","webpack://OpenHPS.core/./node_modules/typedjson/lib/esm5/serializer.js","webpack://OpenHPS.core/./node_modules/typedjson/lib/esm5/type-descriptor.js","webpack://OpenHPS.core/./node_modules/uuid/dist/esm-browser/native.js","webpack://OpenHPS.core/./node_modules/uuid/dist/esm-browser/parse.js","webpack://OpenHPS.core/./node_modules/uuid/dist/esm-browser/regex.js","webpack://OpenHPS.core/./node_modules/uuid/dist/esm-browser/rng.js","webpack://OpenHPS.core/./node_modules/uuid/dist/esm-browser/sha1.js","webpack://OpenHPS.core/./node_modules/uuid/dist/esm-browser/stringify.js","webpack://OpenHPS.core/./node_modules/uuid/dist/esm-browser/v35.js","webpack://OpenHPS.core/./node_modules/uuid/dist/esm-browser/v4.js","webpack://OpenHPS.core/./node_modules/uuid/dist/esm-browser/v5.js","webpack://OpenHPS.core/./node_modules/uuid/dist/esm-browser/validate.js","webpack://OpenHPS.core/ignored|/home/runner/work/openhps-core/openhps-core/dist/esm5/nodes|typescript","webpack://OpenHPS.core/ignored|/home/runner/work/openhps-core/openhps-core/dist/esm5/service|microtime","webpack://OpenHPS.core/./node_modules/threads/index.mjs","webpack://OpenHPS.core/webpack/bootstrap","webpack://OpenHPS.core/webpack/runtime/compat get default export","webpack://OpenHPS.core/webpack/runtime/define property getters","webpack://OpenHPS.core/webpack/runtime/global","webpack://OpenHPS.core/webpack/runtime/hasOwnProperty shorthand","webpack://OpenHPS.core/webpack/runtime/make namespace object","webpack://OpenHPS.core/webpack/runtime/node module decorator","webpack://OpenHPS.core/webpack/before-startup","webpack://OpenHPS.core/webpack/startup","webpack://OpenHPS.core/webpack/after-startup"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"OpenHPS\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"OpenHPS\"] = factory();\n\telse\n\t\troot[\"OpenHPS\"] = root[\"OpenHPS\"] || {}, root[\"OpenHPS\"][\"core\"] = factory();\n})((typeof self !== 'undefined' ? self : this), () => {\nreturn ","import 'reflect-metadata';\nimport { DataObject, ReferenceSpace } from './data';\nimport { GraphValidator, ModelGraph } from './graph/_internal/implementations';\nimport { GraphBuilder } from './graph/builders/GraphBuilder';\nimport { NodeData, TimeService, DataObjectService, MemoryDataService, NodeDataService } from './service';\n/**\n * Model builder to construct and build a {@link Model} consisting of graph shapes and services.\n *\n * ## Usage\n * Models can be created using the {@link ModelBuilder}. Once you have added all services and constructed the graph, you can build the model using the ```build()``` function. A promise will be returned with the created model.\n *\n * ```typescript\n * import { ModelBuilder } from '@openhps/core';\n *\n * ModelBuilder.create()\n *     .build().then(model => {\n *         // ...\n *     });\n * ```\n * The graph shape of a model is immutable and can not be altered after building.\n *\n * ### Shape Builder\n * Shapes can be created by starting with the ```from()``` function. This function takes an optional\n * parameter of one or multiple [source nodes](#sourcenode).\n *\n * In order to end a shape, the ```to()``` function needs to be called with one or more optional [sink nodes](#sinknode).\n * ```typescript\n * import { ModelBuilder } from '@openhps/core';\n *\n * ModelBuilder.create()\n *     .from()\n *     .to()\n *     .build().then(model => {\n *         // ...\n *     });\n * ```\n *\n * Alternatively for readability with multiple shapes, the shapes can individually be created using the ```addShape()``` function as shown below.\n * ```typescript\n * import { ModelBuilder, GraphBuilder } from '@openhps/core';\n *\n * ModelBuilder.create()\n *     .addShape(\n *       GraphBuilder.create()\n *         .from()\n *         .to())\n *     .build().then(model => {\n *         // ...\n *     });\n * ```\n *\n * #### Building Source Processors\n * It is possible to have multiple processing nodes between the source and sink. These processing nodes can manipulate the data frame\n * when it traverses from node to node.\n * ```typescript\n * import { ModelBuilder } from '@openhps/core';\n *\n * ModelBuilder.create()\n *     .from(...)\n *     .via(new ComputingNode())\n *     .via(new AnotherComputingNode())\n *     .to(...)\n *     .build().then(model => {\n *         // ...\n *     });\n * ```\n *\n * #### Helper Functions\n * Helper functions can replace the ```via()``` function. Commonly used nodes such as frame filters, merging of data frames from\n * multiple sources, ... can be replaced with simple functions as ```filter()``` or ```merge()``` respectively.\n * ```typescript\n * import { ModelBuilder } from '@openhps/core';\n * import { CSVSourceNode, CSVSinkNode } from '@openhps/csv';\n *\n * ModelBuilder.create()\n *     .from(\n *         new CSVSourceNode('scanner1.csv', ...),\n *         new CSVSourceNode('scanner2.csv', ...),\n *         new CSVSourceNode('scanner3.csv', ...)\n *     )\n *     .filter((frame: DataFrame) => true)\n *     .merge((frame: DataFrame) => frame.source.uid)\n *     .via(new ComputingNode())\n *     .via(new AnotherComputingNode())\n *     .to(new CSVSinkNode('output.csv', ...))\n *     .build().then(model => {\n *         // ...\n *     });\n * ```\n *\n * ### Debug Logging\n * When building the model, you can provide a logger callback that has two arguments. An error level complying\n * with normal log levels and a log object that represents an object.\n * ```typescript\n * import { ModelBuilder } from '@openhps/core';\n *\n * ModelBuilder.create()\n *     // Set the logger that will be used by all nodes and services\n *     .withLogger((level: string, log: any) => {\n *         console.log(log);\n *     })\n *     // ...\n *     .build().then(model => {\n *      // ...\n *     });\n * ```\n *\n * ### Adding Services\n * Adding services can be done using the ```addService()``` function in the model builder.\n * ```typescript\n * import { ModelBuilder } from '@openhps/core';\n *\n * ModelBuilder.create()\n *     .addService(...)\n *     // ...\n *     .build().then(model => {\n *\n *     });\n * ```\n */\nexport class ModelBuilder extends GraphBuilder {\n  constructor() {\n    super(new ModelGraph());\n    this.graph.name = 'model';\n    // Store data objects\n    this.graph.addService(new DataObjectService(new MemoryDataService(DataObject)));\n    // Store spaces in their own memory data object service\n    this.graph.addService(new DataObjectService(new MemoryDataService(ReferenceSpace)));\n    // Store node data\n    this.graph.addService(new NodeDataService(new MemoryDataService(NodeData)));\n    // Default time service using system time\n    this.graph.addService(new TimeService());\n  }\n  static create() {\n    return new ModelBuilder();\n  }\n  /**\n   * Model logger\n   *\n   * @param {Function} logger Logging function\n   * @returns {ModelBuilder} Model builder instance\n   */\n  withLogger(logger) {\n    this.graph.logger = logger;\n    return this;\n  }\n  withReferenceSpace(space) {\n    this.graph.referenceSpace = space;\n    return this;\n  }\n  /**\n   * Add a service to the model\n   *\n   * @param {Service} service Service to add\n   * @param {ProxyHandler} [proxy] Proxy handler\n   * @returns {ModelBuilder} Model builder instance\n   */\n  addService(service, proxy) {\n    this.graph.addService(service, proxy);\n    return this;\n  }\n  /**\n   * Add multiple services to the model\n   *\n   * @param {Service[]} services Services to add\n   * @returns {ModelBuilder} Model builder instance\n   */\n  addServices(...services) {\n    services.forEach(service => this.addService(service));\n    return this;\n  }\n  /**\n   * Add graph shape to graph\n   *\n   * @param {GraphBuilder | GraphShape | Model} shape Graph builder or abstract graph\n   * @returns {GraphBuilder} Current graph builder instance\n   */\n  addShape(shape) {\n    if (shape instanceof ModelGraph) {\n      // Add services\n      shape.findAllServices().forEach(service => {\n        this.addService(service);\n      });\n    } else if (shape instanceof ModelBuilder) {\n      shape.graph.findAllServices().forEach(service => {\n        this.addService(service);\n      });\n    }\n    return super.addShape(shape);\n  }\n  build() {\n    return new Promise((resolve, reject) => {\n      GraphValidator.validate(this.graph);\n      this.graph.once('ready', () => {\n        resolve(this.graph);\n      });\n      this.graph.emitAsync('build', this).catch(ex => {\n        // Destroy model\n        this.graph.emit('destroy');\n        reject(ex);\n      });\n    });\n  }\n}","import { DataSerializer } from './data';\nimport { Node } from './Node';\nimport { Service } from './service';\nexport class ModelSerializer {\n  static serialize(model) {\n    return this.serializeNode(model);\n  }\n  static serializeNode(node) {\n    this._initialize();\n    return DataSerializer.serialize(node);\n  }\n  static deserialize(model) {\n    const deserializedModel = this.deserializeNode(model);\n    deserializedModel.nodes.forEach(node => {\n      node.graph = deserializedModel;\n    });\n    return deserializedModel;\n  }\n  static deserializeNode(node) {\n    this._initialize();\n    return DataSerializer.deserialize(node);\n  }\n  static _loadClasses(module = require.main) {\n    if (module === undefined) {\n      // Use cache instead\n      Object.values(require.cache).map(m => this._loadClasses(m));\n      return;\n    }\n    this._modules.add(module.id);\n    Object.keys(module.exports).forEach(key => {\n      const childModule = module.exports[key];\n      if (childModule && childModule.prototype instanceof Node) {\n        this.NODES.set(key, {\n          constructor: childModule\n        });\n      } else if (childModule && childModule.prototype instanceof Service) {\n        this.SERVICES.set(key, {\n          constructor: childModule\n        });\n      }\n    });\n    module.children.forEach(module => {\n      if (!this._modules.has(module.id)) {\n        this._loadClasses(module);\n      }\n    });\n  }\n  static _initialize() {\n    if (this.SERVICES.size === 0 || this.NODES.size === 0) {\n      this._loadClasses();\n      this._modules.clear();\n      this.SERVICES.forEach(service => DataSerializer.registerType(service.constructor));\n      this.NODES.forEach(node => DataSerializer.registerType(node.constructor));\n    }\n  }\n}\nModelSerializer.NODES = new Map();\nModelSerializer.SERVICES = new Map();\nModelSerializer._modules = new Set();","import { __decorate, __metadata } from \"tslib\";\nimport { GraphNode } from './graph/_internal/GraphNode';\nimport { SerializableMember, SerializableObject } from './data';\n/**\n * The graph node has an input and output {@link DataFrame}\n *\n * ## Usage\n *\n * ### Creating a Node\n * Default nodes require you to specify the input and output data frame type. In general, nodes have the ability\n * to process an input data frame and output a different (processed) data frame.\n * ```typescript\n * import { DataFrame, Node } from '@openhps/core';\n *\n * export class CustomNode<In extends DataFrame, Out extends DataFrame> extends Node<In, Out> {\n *     // ...\n * }\n * ```\n * Abstract implementations such as a {@link SourceNode} and {@link SinkNode} only take one input or output\n * data frame type as they do not process or change the frame.\n *\n * @category Node\n */\nlet Node = class Node extends GraphNode {\n  constructor(options) {\n    super();\n    this.setOptions(options || {});\n    // Set the uid of the node if manually set\n    this.uid = this.options.uid || this.uid;\n  }\n  /**\n   * Set the node options\n   *\n   * @param {NodeOptions} options Node options to set\n   * @returns {Node} Node instance\n   */\n  setOptions(options) {\n    this.options = Object.assign(Object.assign({}, options), this.options || []);\n    // Set the display name of the node to the type name\n    this.name = this.options.name || this.constructor.name;\n    return this;\n  }\n  /**\n   * Get the node options\n   *\n   * @returns {NodeOptions} Node options\n   */\n  getOptions() {\n    return this.options;\n  }\n  /**\n   * Graph this model is part of\n   *\n   * @returns {Model} Positioning model\n   */\n  get model() {\n    return this.graph;\n  }\n};\n__decorate([SerializableMember(), __metadata(\"design:type\", Object)], Node.prototype, \"options\", void 0);\nNode = __decorate([SerializableObject(), __metadata(\"design:paramtypes\", [Object])], Node);\nexport { Node };","import { EventEmitter } from 'events';\n/**\n * Asynchronous event emitter that adds\n * the function ```emitAsync()```.\n */\nexport class AsyncEventEmitter extends EventEmitter {\n  emitAsync(type, ...args) {\n    return new Promise((resolve, reject) => {\n      // eslint-disable-next-line\n      const handlers = this.listeners(type);\n      if (handlers.length === 0) {\n        return resolve(false);\n      }\n      const promises = [];\n      handlers.forEach(handler => {\n        promises.push(handler(...args));\n      });\n      Promise.all(promises).then(() => {\n        resolve(true);\n      }).catch(reject);\n    });\n  }\n}","var DataFrame_1;\nimport { __decorate, __metadata } from \"tslib\";\nimport { v4 as uuidv4 } from 'uuid';\nimport { DataObject } from './object/DataObject';\nimport { SerializableObject, SerializableMember, SerializableMapMember } from './decorators';\nimport { TimeService } from '../service/TimeService';\nimport { DataSerializer } from './DataSerializer';\n/**\n * A data frame is information that is passed through each node in a positioning model.\n *\n * ![DataFrame content](media://images/dataframe.svg)\n *\n * ## Usage\n *\n * ### Creation\n * A data frame can be created with an optional source {@link DataObject} that represents\n * the object responsible for generating the frame.\n * ```typescript\n * const dataFrame = new DataFrame(new DataObject(\"phone\"));\n * ```\n *\n * ### Creating a custom DataFrame\n * Custom data frames can be created by extending the default {@link DataFrame} class. Important when handling\n * data frames (and objects) is to add serializable decorators.\n * ```typescript\n * import { DataFrame, SerializableObject, SerializableArrayMember } from '@openhps/core';\n *\n * @SerializableObject()\n * export class CustomDataFrame extends DataFrame {\n *     @SerialisableArrayMember(Number)\n *     public customFrameAttribute: number[];\n * }\n * ```\n *\n * ### Adding {@link DataObject}s\n * Adding data object will clone the data objects to the data frame. Any changes made to the object after cloning will not\n * be applied to the data frame.\n */\nlet DataFrame = DataFrame_1 = class DataFrame {\n  constructor(data) {\n    var _a;\n    /**\n     * Data frame unique identifier\n     */\n    this.uid = uuidv4();\n    this._objects = new Map();\n    this.createdTimestamp = TimeService.now();\n    if (data instanceof DataFrame_1) {\n      // Copy data frame\n      this.createdTimestamp = data.createdTimestamp;\n      this.phenomenonTimestamp = data.phenomenonTimestamp;\n      this.uid = data.uid;\n      this._objects = data._objects;\n      this.source = data.source;\n    } else if (data instanceof DataObject) {\n      this.source = data;\n    }\n    this.phenomenonTimestamp = (_a = this.phenomenonTimestamp) !== null && _a !== void 0 ? _a : this.createdTimestamp;\n  }\n  /**\n   * Source object clone that captured the data frame\n   *\n   * @returns {DataObject} Source data object\n   */\n  get source() {\n    return this.getObjectByUID(this._source);\n  }\n  /**\n   * Set the source object clone that captured the data frame\n   *\n   * @param {DataObject} object Source data object\n   */\n  set source(object) {\n    if (object === undefined) return;\n    this.addObject(object.clone());\n    this._source = object.uid;\n  }\n  /**\n   * Get known sensor objects used in this data frame\n   *\n   * @param {typeof SensorObject} type Sensor type\n   * @param {string} [defaultUID] Default UID. When sensor is not added, it will be created\n   * @returns {SensorObject} Found data objects\n   */\n  getSensor(type, defaultUID) {\n    let sensor = this.getObjects(type)[0];\n    if (!sensor && defaultUID !== undefined) {\n      sensor = new type(defaultUID);\n      this.addObject(sensor);\n    }\n    return sensor;\n  }\n  /**\n   * Get known objects used in this data frame\n   *\n   * @param {typeof DataObject} dataType Data object type\n   * @returns {DataObject[]} Array of found data objects\n   */\n  getObjects(dataType) {\n    if (dataType === undefined) {\n      const filteredObjects = [];\n      this._objects.forEach(object => {\n        filteredObjects.push(object);\n      });\n      return filteredObjects;\n    } else {\n      const filteredObjects = [];\n      this._objects.forEach(object => {\n        if (object.constructor.name === dataType.name) filteredObjects.push(object);\n      });\n      return filteredObjects;\n    }\n  }\n  /**\n   * Get a specific object by its identifier\n   *\n   * @param {string} uid Object UID\n   * @returns {DataObject} Data object if found\n   */\n  getObjectByUID(uid) {\n    return this._objects.get(uid);\n  }\n  /**\n   * Check if the data frame has an object\n   *\n   * @param {DataObject} object Data object to find\n   * @returns {boolean} Object exist\n   */\n  hasObject(object) {\n    return this._objects.has(object.uid);\n  }\n  /**\n   * Add a new object relevant to this data frame\n   *\n   * @param {DataObject} object Relevant object\n   * @returns {DataFrame} instance\n   */\n  addObject(object) {\n    if (object === undefined) return this;\n    this._objects.set(object.uid, object);\n    return this;\n  }\n  /**\n   * Add a new sensor relevant to this data frame\n   *\n   * @param {SensorObject} object Relevant sensor\n   * @returns {DataFrame} instance\n   */\n  addSensor(object) {\n    return this.addObject(object);\n  }\n  /**\n   * Add a new reference space relevant to this data frame.\n   *\n   * @alias addObject Alias for addObject\n   * @param {ReferenceSpace} referenceSpace Relevant reference space\n   */\n  addReferenceSpace(referenceSpace) {\n    this.addObject(referenceSpace);\n  }\n  /**\n   * Remove an object from the data frame\n   *\n   * @param {DataObject} object Object to remove\n   */\n  removeObject(object) {\n    this._objects.delete(object.uid);\n  }\n  /**\n   * Clone the data frame\n   *\n   * @returns {DataFrame} Cloned data frame\n   */\n  clone() {\n    return DataSerializer.clone(this);\n  }\n};\n__decorate([SerializableMember({\n  primaryKey: true\n}), __metadata(\"design:type\", String)], DataFrame.prototype, \"uid\", void 0);\n__decorate([SerializableMember({\n  index: true\n}), __metadata(\"design:type\", Number)], DataFrame.prototype, \"createdTimestamp\", void 0);\n__decorate([SerializableMember({\n  index: true\n}), __metadata(\"design:type\", Number)], DataFrame.prototype, \"phenomenonTimestamp\", void 0);\n__decorate([SerializableMember({\n  name: 'source'\n}), __metadata(\"design:type\", String)], DataFrame.prototype, \"_source\", void 0);\n__decorate([SerializableMapMember(String, DataObject, {\n  name: 'objects'\n}), __metadata(\"design:type\", Map)], DataFrame.prototype, \"_objects\", void 0);\nDataFrame = DataFrame_1 = __decorate([SerializableObject(), __metadata(\"design:paramtypes\", [Object])], DataFrame);\nexport { DataFrame };","var _a;\nimport { EventEmitter } from 'events';\nimport { JsonObjectMetadata } from 'typedjson';\nimport { DataSerializerUtils } from './DataSerializerUtils';\nimport { Deserializer } from './Deserializer';\nimport { Serializer } from './Serializer';\nJsonObjectMetadata.getFromConstructor = function (ctor) {\n  if (!ctor) {\n    return;\n  }\n  const prototype = ctor.prototype;\n  if (prototype == null) {\n    return;\n  }\n  let metadata;\n  if (Object.prototype.hasOwnProperty.call(prototype, DataSerializerUtils.META_FIELD)) {\n    // The class prototype contains own jsonObject metadata\n    metadata = prototype[DataSerializerUtils.META_FIELD];\n  } else {\n    const parent = Object.getPrototypeOf(ctor.prototype);\n    if (!parent) {\n      return;\n    }\n    metadata = JsonObjectMetadata.getFromConstructor(parent.constructor);\n  }\n  // Ignore implicitly added jsonObject (through jsonMember)\n  if ((metadata === null || metadata === void 0 ? void 0 : metadata.isExplicitlyMarked) === true) {\n    return metadata;\n  }\n  // In the end maybe it is something which we can handle directly\n  if (JsonObjectMetadata['doesHandleWithoutAnnotation'](ctor)) {\n    const primitiveMeta = new JsonObjectMetadata(ctor);\n    primitiveMeta.isExplicitlyMarked = true;\n    // we do not store the metadata here to not modify builtin prototype\n    return primitiveMeta;\n  }\n};\n/**\n * Allows the serialization and deserialization of objects using the {@link SerializableObject} decorator.\n *\n * ## Usage\n *\n * ### Registration\n * Objects are registered upon loading with the {@link SerializableObject} decorator.\n * Manual registration is possible using:\n * ```typescript\n * DataSerializer.registerType(MyObjectClass);\n * ```\n */\nexport class DataSerializer {\n  /**\n   * Manually register a new type\n   *\n   * @param {typeof any} type Type to register\n   * @param {MappedTypeConverters} [converters] Optional converters\n   */\n  static registerType(type, converters) {\n    this.knownTypes.set(type.name, type);\n    if (converters) {\n      this.serializer.setSerializationStrategy(type, value => {\n        return converters.serializer(value, {\n          fallback: (so, td) => this.serializer.convertSingleValue(so, td)\n        });\n      });\n      this.deserializer.setDeserializationStrategy(type, value => {\n        return converters.deserializer(value, {\n          fallback: (so, td) => this.deserializer.convertSingleValue(so, td, this.knownTypes)\n        });\n      });\n      if (type.name !== 'Object') {\n        const objectMetadata = new JsonObjectMetadata(type);\n        objectMetadata.isExplicitlyMarked = true;\n        type.prototype[DataSerializerUtils.META_FIELD] = objectMetadata;\n      }\n    }\n    this.eventEmitter.emit('registerType', type, converters);\n  }\n  /**\n   * Get the TypedJSON metadata\n   *\n   * @deprecated use {@link DataSerializerUtils.getMetadata}\n   * @see {@link https://gist.github.com/krizka/c83fb1966dd57997a1fc02625719387d}\n   * @param {any} proto Prototype of target\n   * @returns {ObjectMetadata} Root object metadata\n   */\n  static getMetadata(proto) {\n    return DataSerializerUtils.getMetadata(proto);\n  }\n  /**\n   * Get the root TypedJSON metadata\n   *\n   * @deprecated use {@link DataSerializerUtils.getRootMetadata}\n   * @see {@link https://gist.github.com/krizka/c83fb1966dd57997a1fc02625719387d}\n   * @param {any} proto Prototype of target\n   * @returns {ObjectMetadata} Root object metadata\n   */\n  static getRootMetadata(proto) {\n    return DataSerializerUtils.getRootMetadata(proto);\n  }\n  /**\n   * Find the root TypedJSON metadata\n   *\n   * @deprecated use {@link DataSerializerUtils.getRootMetadata}\n   * @param {any} proto Prototype of target\n   * @returns {ObjectMetadata} Root object metadata\n   */\n  static findRootMetaInfo(proto) {\n    return DataSerializerUtils.getRootMetadata(proto);\n  }\n  /**\n   * Unregister a type\n   *\n   * @param {typeof any} type Type to unregister\n   */\n  static unregisterType(type) {\n    this.knownTypes.delete(type.name);\n    this.eventEmitter.emit('unregisterType', type);\n  }\n  static findTypeByName(name) {\n    return this.knownTypes.get(name);\n  }\n  /**\n   * Clone a serializable object\n   *\n   * @param {any} object Serializable object\n   * @returns {any} Cloned object\n   */\n  static clone(object) {\n    return this.deserialize(this.serialize(object));\n  }\n  /**\n   * Serialize data\n   *\n   * @param {any} data Data to serialize\n   * @param {DataSerializerConfig} [config] Data serializer configuration\n   * @returns {any} Serialized data\n   */\n  static serialize(data, config = {}) {\n    var _b;\n    if (data === null || data === undefined) {\n      return undefined;\n    }\n    const globalDataType = Object.getPrototypeOf(data).constructor;\n    // First check if it is a registered type\n    // this is important as some serializable classes\n    // may extend an array\n    if (!this.findTypeByName(globalDataType.name) && Array.isArray(data)) {\n      return data.map(this.serialize.bind(this));\n    }\n    const serializer = (_b = config.serializer) !== null && _b !== void 0 ? _b : this.serializer;\n    return serializer.convertSingleValue(data, DataSerializerUtils.ensureTypeDescriptor(globalDataType), undefined, undefined, config);\n  }\n  static deserialize(serializedData, dataType, config = {}) {\n    var _b;\n    if (typeof serializedData !== 'object' && typeof serializedData !== 'function' || !serializedData) {\n      return serializedData;\n    }\n    if (Array.isArray(serializedData)) {\n      return serializedData.map(serializedObject => this.deserialize(serializedObject));\n    }\n    const deserializer = (_b = config.deserializer) !== null && _b !== void 0 ? _b : this.deserializer;\n    const finalType = dataType !== null && dataType !== void 0 ? dataType : deserializer.getTypeResolver()(serializedData, this.knownTypes);\n    return deserializer.convertSingleValue(serializedData, DataSerializerUtils.ensureTypeDescriptor(finalType), this.knownTypes, undefined, undefined, config);\n  }\n}\n_a = DataSerializer;\nDataSerializer.knownTypes = new Map();\nDataSerializer.serializer = new Serializer();\nDataSerializer.deserializer = new Deserializer();\n/* Event emitter used to listen for registrations and unregister of data types */\nDataSerializer.eventEmitter = new EventEmitter();\n(() => {\n  _a.registerType(Object, {\n    serializer: object => Object.assign(Object.assign({}, Object.keys(object).map(key => {\n      return {\n        [key]: typeof object[key] === 'function' ? {\n          function: object[key].toString(),\n          __type: 'Function'\n        } : DataSerializer.serialize(object[key])\n      };\n    }).reduce((a, b) => Object.assign(Object.assign({}, a), b), {})), {\n      __type: 'Object'\n    }),\n    deserializer: objectJson => Object.keys(objectJson).map(key => {\n      if (key === '__type') {\n        return {};\n      }\n      return {\n        [key]: typeof objectJson[key] === 'object' && objectJson[key].__type === 'Function' ? eval(objectJson[key].function) : DataSerializer.deserialize(objectJson[key])\n      };\n    }).reduce((a, b) => Object.assign(Object.assign({}, a), b), {})\n  });\n})();","import { JsonObjectMetadata } from 'typedjson';\n/**\n * Data serializer utilities for managing the ORM mapping\n */\nexport class DataSerializerUtils {\n  static get META_FIELD() {\n    return '__typedJsonJsonObjectMetadataInformation__';\n  }\n  /**\n   * Get the own TypedJSON metadata of the prototype\n   *\n   * @see {@link https://gist.github.com/krizka/c83fb1966dd57997a1fc02625719387d}\n   * @param {any} proto Prototype of target\n   * @returns {ObjectMetadata} Root object metadata\n   */\n  static getOwnMetadata(proto) {\n    return JsonObjectMetadata.getFromConstructor(proto instanceof Function ? proto : proto.constructor);\n  }\n  /**\n   * Get the TypedJSON metadata\n   *\n   * @see {@link https://gist.github.com/krizka/c83fb1966dd57997a1fc02625719387d}\n   * @param {any} proto Prototype of target\n   * @returns {ObjectMetadata} Root object metadata\n   */\n  static getMetadata(proto) {\n    var _a;\n    return (_a = DataSerializerUtils.getOwnMetadata(proto)) !== null && _a !== void 0 ? _a : DataSerializerUtils.getRootMetadata(proto);\n  }\n  /**\n   * Get the root TypedJSON metadata\n   *\n   * @see {@link https://gist.github.com/krizka/c83fb1966dd57997a1fc02625719387d}\n   * @param {any} proto Prototype of target\n   * @returns {ObjectMetadata} Root object metadata\n   */\n  static getRootMetadata(proto) {\n    const protoProto = proto instanceof Function ? proto.prototype : Object.getPrototypeOf(proto);\n    if (!protoProto || !protoProto[DataSerializerUtils.META_FIELD]) {\n      return proto[DataSerializerUtils.META_FIELD];\n    }\n    return DataSerializerUtils.getRootMetadata(protoProto);\n  }\n  static ensureTypeDescriptor(type) {\n    return type instanceof TypeDescriptor ? type : new ConcreteTypeDescriptor(type);\n  }\n  /**\n   * Get member options of a property in a data type\n   *\n   * @param {Constructor} dataType Data type\n   * @param {string} propertyKey Property key\n   * @returns {SerializableMemberOptions} member options\n   */\n  static getMemberOptions(dataType, propertyKey) {\n    const metadata = DataSerializerUtils.getMetadata(dataType);\n    if (!metadata) {\n      return undefined;\n    }\n    const dataMember = metadata.dataMembers.get(propertyKey);\n    if (!dataMember) {\n      return undefined;\n    }\n    return dataMember.options;\n  }\n  /**\n   * Get member options of an identifier property in a data type\n   *\n   * @param {Constructor} dataType Data type\n   * @returns {SerializableMemberOptions} identifier member options\n   */\n  static getIdentifierMemberOptions(dataType) {\n    const metadata = DataSerializerUtils.getMetadata(dataType);\n    if (!metadata) {\n      return undefined;\n    }\n    return Array.from(metadata.dataMembers.values()).filter(member => {\n      return member && member.primaryKey;\n    })[0];\n  }\n}\nexport class TypeDescriptor {\n  constructor(ctor) {\n    this.ctor = ctor;\n  }\n  getTypes() {\n    return [this.ctor];\n  }\n  hasFriendlyName() {\n    return this.ctor.name !== 'Object';\n  }\n}\nexport class ConcreteTypeDescriptor extends TypeDescriptor {\n  // eslint-disable-next-line @typescript-eslint/no-useless-constructor\n  constructor(ctor) {\n    super(ctor);\n  }\n}","import { Deserializer as JSONDeserializer } from \"typedjson/lib/esm5/deserializer\";\nexport class Deserializer extends JSONDeserializer {\n  constructor() {\n    super(...arguments);\n    this.errorHandler = e => {\n      e.message = e.message.replace('@jsonObject', '@SerializableObject()');\n      e.message = e.message.replace('@jsonMember', '@SerializableMember()');\n      e.message = e.message.replace('@jsonSetMember', '@SerializableSetMember()');\n      e.message = e.message.replace('@jsonMapMember', '@SerializableMapMember()');\n      e.message = e.message.replace('@jsonArrayMember', '@SerializableArrayMember()');\n      throw e;\n    };\n  }\n  typeResolver(sourceObject, knownTypes) {\n    var _a;\n    return sourceObject['__type'] !== undefined ? knownTypes.get(sourceObject.__type) : (_a = sourceObject.constructor) !== null && _a !== void 0 ? _a : Object;\n  }\n  convertSingleValue(sourceObject, typeDescriptor, knownTypes, memberName, memberOptions, _) {\n    return super.convertSingleValue(sourceObject, typeDescriptor, knownTypes, memberName, memberOptions);\n  }\n}","import { Serializer as JSONSerializer } from \"typedjson/lib/esm5/serializer\";\nexport class Serializer extends JSONSerializer {\n  constructor() {\n    super(...arguments);\n    this.errorHandler = e => {\n      e.message = e.message.replace('@jsonObject', '@SerializableObject()');\n      e.message = e.message.replace('@jsonMember', '@SerializableMember()');\n      e.message = e.message.replace('@jsonSetMember', '@SerializableSetMember()');\n      e.message = e.message.replace('@jsonMapMember', '@SerializableMapMember()');\n      e.message = e.message.replace('@jsonArrayMember', '@SerializableArrayMember()');\n      throw e;\n    };\n  }\n  convertSingleValue(sourceObject, typeDescriptor, memberName, memberOptions, _) {\n    const targetObject = super.convertSingleValue(sourceObject, typeDescriptor, memberName, memberOptions);\n    if (memberName === undefined && typeof targetObject === 'object') {\n      targetObject.__type = typeDescriptor.ctor.name;\n    }\n    return targetObject;\n  }\n}","import { jsonArrayMember } from 'typedjson';\nimport { mergeMemberOptions, updateSerializableMember } from './utils';\n/**\n * @param {Serializable<any>} elementConstructor Element constructor\n * @param {SerializableArrayMemberOptions} [options] Member options\n * @returns {PropertyDecorator} Property decorator\n */\nexport function SerializableArrayMember(elementConstructor, options) {\n  return (target, propertyKey) => {\n    const finalOptions = mergeMemberOptions(target, propertyKey, options);\n    jsonArrayMember(elementConstructor, finalOptions)(target, propertyKey);\n    updateSerializableMember(target, propertyKey, finalOptions);\n  };\n}","import { jsonMapMember } from 'typedjson';\nimport { mergeMemberOptions, updateSerializableMember } from './utils';\n/**\n * @param {Serializable<any>} keyConstructor Map key constructor\n * @param {Serializable<any>} valueConstructor Map value constructor\n * @param {SerializableMapMemberOptions} [options] Member options\n * @returns {PropertyDecorator} Property decorator\n */\nexport function SerializableMapMember(keyConstructor, valueConstructor, options) {\n  return (target, propertyKey) => {\n    if (valueConstructor === Object && options === undefined) {\n      options = {};\n      options.deserializer = json => {\n        const map = new Map();\n        Object.keys(json).forEach(key => {\n          map.set(key, JSON.parse(json[key]));\n        });\n        return map;\n      };\n      options.serializer = map => {\n        const json = {};\n        map.forEach((value, key) => {\n          json[key] = JSON.stringify(value);\n        });\n        return json;\n      };\n    }\n    const finalOptions = mergeMemberOptions(target, propertyKey, options);\n    jsonMapMember(keyConstructor, valueConstructor, finalOptions)(target, propertyKey);\n    updateSerializableMember(target, propertyKey, finalOptions);\n  };\n}","import 'reflect-metadata';\nimport { jsonMember } from 'typedjson';\nimport { updateSerializableMember, mergeMemberOptions } from './utils';\n/**\n * @param {SerializableMemberOptions} [options] Member options\n * @returns {PropertyDecorator} Property decorator\n */\nexport function SerializableMember(options) {\n  return (target, propertyKey) => {\n    const finalOptions = mergeMemberOptions(target, propertyKey, options);\n    jsonMember(finalOptions)(target, propertyKey);\n    updateSerializableMember(target, propertyKey, finalOptions);\n  };\n}","import { SerializableMember } from './SerializableMember';\nimport { mergeMemberOptions, updateSerializableMember } from './utils';\n/**\n * @param {SerializableMemberOptions} [options] Member options\n * @returns {PropertyDecorator} Property decorator\n */\nexport function SerializableMemberFunction(options = {}) {\n  return (target, propertyKey) => {\n    options.serializer = fn => fn.toString();\n    options.deserializer = fnStr => eval(fnStr);\n    const finalOptions = mergeMemberOptions(target, propertyKey, options);\n    SerializableMember(finalOptions)(target, propertyKey);\n    updateSerializableMember(target, propertyKey, finalOptions);\n  };\n}","import { jsonObject } from 'typedjson';\nimport { DataSerializer } from '../DataSerializer';\nimport { updateSerializableObject } from './utils';\n/**\n * Serializable object\n *\n * @param {SerializableObjectOptions} [options] Object serialization options\n * @returns {ClassDecorator} Class decorator\n */\nexport function SerializableObject(options) {\n  return target => {\n    jsonObject(options)(target);\n    DataSerializer['eventEmitter'].emit('updateSerializableObject', target, options);\n    updateSerializableObject(target, options);\n  };\n}","import { jsonSetMember } from 'typedjson';\nimport { mergeMemberOptions, updateSerializableMember } from './utils';\n/**\n * @param {Constructor} elementConstructor Element constructor\n * @param {SerializableSetMemberOptions} options Member options\n * @returns {PropertyDecorator} Property decorator\n */\nexport function SerializableSetMember(elementConstructor, options) {\n  return (target, propertyKey) => {\n    const finalOptions = mergeMemberOptions(target, propertyKey, options);\n    jsonSetMember(elementConstructor, finalOptions)(target, propertyKey);\n    updateSerializableMember(target, propertyKey, finalOptions);\n  };\n}","export * from './SerializableObject';\nexport * from './SerializableMember';\nexport * from './SerializableArrayMember';\nexport * from './SerializableMapMember';\nexport * from './SerializableSetMember';\nexport * from './SerializableMemberFunction';\nexport * from './options';","export var NumberType;\n(function (NumberType) {\n  NumberType[NumberType[\"INTEGER\"] = 0] = \"INTEGER\";\n  NumberType[NumberType[\"FLOAT\"] = 1] = \"FLOAT\";\n  NumberType[NumberType[\"DOUBLE\"] = 2] = \"DOUBLE\";\n  NumberType[NumberType[\"DECIMAL\"] = 3] = \"DECIMAL\";\n  NumberType[NumberType[\"LONG\"] = 4] = \"LONG\";\n  NumberType[NumberType[\"SHORT\"] = 5] = \"SHORT\";\n})(NumberType || (NumberType = {}));","import { AnyT, JsonObjectMetadata } from 'typedjson';\nimport { DataSerializer } from '../DataSerializer';\nimport { DataSerializerUtils } from '../DataSerializerUtils';\n// eslint-disable-next-line\nconst cloneDeep = require('lodash.clonedeep');\n/**\n * Inject member options into object\n *\n * @param {any} target Prototype\n * @param {PropertyKey} propertyKey Property key\n * @param {any} options Options to inject\n */\nexport function updateSerializableMember(target, propertyKey, options) {\n  var _a, _b;\n  // Inject additional options if available\n  if (options) {\n    const ownMeta = JsonObjectMetadata.ensurePresentInPrototype(target);\n    const rootMeta = DataSerializerUtils.getRootMetadata(target.constructor);\n    const ownMemberMetadata = ownMeta.dataMembers.get(propertyKey) || ownMeta.dataMembers.get(options.name);\n    const rootMemberMetadata = rootMeta.dataMembers.get(propertyKey) || rootMeta.dataMembers.get(options.name);\n    if (!ownMemberMetadata) {\n      throw new Error(`Unable to get member metadata for ${target}!`);\n    }\n    ownMemberMetadata.options = mergeDeep((_a = ownMemberMetadata.options) !== null && _a !== void 0 ? _a : {}, options);\n    if (rootMemberMetadata) {\n      ownMemberMetadata.options = mergeDeep((_b = rootMemberMetadata.options) !== null && _b !== void 0 ? _b : {}, ownMemberMetadata.options);\n    }\n    // Merge known sub types as well\n    rootMeta.knownTypes.forEach(otherType => {\n      var _a, _b;\n      if (otherType === target || target instanceof otherType) {\n        return;\n      }\n      const otherMeta = (_a = DataSerializerUtils.getMetadata(otherType)) !== null && _a !== void 0 ? _a : JsonObjectMetadata.ensurePresentInPrototype(otherType);\n      const otherMemberMetadata = otherMeta.dataMembers.get(propertyKey) || otherMeta.dataMembers.get(options.name);\n      if (otherMemberMetadata) {\n        otherMemberMetadata.options = mergeDeep((_b = ownMemberMetadata.options) !== null && _b !== void 0 ? _b : {}, otherMemberMetadata.options);\n      }\n    });\n    // TODO: Possibly need to sync super types as well\n  }\n  // Detect generic types that have no deserialization or constructor specified\n  const reflectPropCtor = Reflect.getMetadata('design:type', target, propertyKey);\n  if (reflectPropCtor === Object && (!options || !options.deserializer && !Object.keys(options).includes('constructor'))) {\n    const meta = JsonObjectMetadata.ensurePresentInPrototype(target);\n    const existingOptions = meta.dataMembers.get(options ? options.name || propertyKey : propertyKey);\n    existingOptions.serializer = object => DataSerializer.serialize(object);\n    existingOptions.deserializer = objectJson => DataSerializer.deserialize(objectJson);\n    existingOptions.type = () => AnyT;\n  }\n}\n/**\n * Inject object members\n *\n * @param {Serializable} target Target to update\n * @param {SerializableObjectOptions} options Options to inject\n */\nexport function updateSerializableObject(target, options) {\n  var _a, _b, _c;\n  const ownMeta = DataSerializerUtils.getMetadata(target);\n  const rootMeta = DataSerializerUtils.getRootMetadata(target.prototype);\n  rootMeta.knownTypes.add(target);\n  if (rootMeta.initializerCallback && !ownMeta.initializerCallback) {\n    ownMeta.initializerCallback = rootMeta.initializerCallback;\n  }\n  // Merge options\n  if (options) {\n    ownMeta.options = mergeDeep(ownMeta === rootMeta ? (_a = ownMeta.options) !== null && _a !== void 0 ? _a : {} : (_c = (_b = ownMeta.options) !== null && _b !== void 0 ? _b : rootMeta.options) !== null && _c !== void 0 ? _c : {}, options);\n    // Merge known sub types as well\n    rootMeta.knownTypes.forEach(otherType => {\n      var _a;\n      if (otherType === target || !(otherType.prototype instanceof target)) {\n        return;\n      }\n      const otherMeta = DataSerializerUtils.getMetadata(otherType);\n      otherMeta.options = mergeDeep((_a = ownMeta.options) !== null && _a !== void 0 ? _a : {}, otherMeta.options);\n      if (!otherMeta.initializerCallback && ownMeta.initializerCallback) {\n        otherMeta.initializerCallback = ownMeta.initializerCallback;\n      }\n    });\n  }\n  // Sync settings from super types\n  rootMeta.knownTypes.forEach(otherType => {\n    if (otherType === target || !(target.prototype instanceof otherType)) {\n      return;\n    }\n    const otherMeta = DataSerializerUtils.getMetadata(otherType);\n    if (otherMeta.initializerCallback && !ownMeta.initializerCallback) {\n      ownMeta.initializerCallback = otherMeta.initializerCallback;\n    }\n  });\n  // (Re)register type\n  DataSerializer.registerType(target);\n}\n/**\n * Check if something is an object\n *\n * @param {any} item Item to check for object\n * @returns {boolean} Is an object\n */\nfunction isObject(item) {\n  return item && typeof item === 'object' && !Array.isArray(item);\n}\n/**\n * Deep merge member options\n *\n * @param {unknown} target Target object\n * @param {string} propertyKey Property key in target\n * @param {any} options Member options\n * @returns {any} Merged objects\n */\nexport function mergeMemberOptions(target, propertyKey, options) {\n  var _a;\n  if (typeof options === 'function') {\n    return options;\n  }\n  const memberOptions = (_a = DataSerializerUtils.getMemberOptions(target.constructor, propertyKey)) !== null && _a !== void 0 ? _a : {};\n  return mergeDeep(options, memberOptions);\n}\n/**\n * Deep merge objects\n *\n * @param {any} target Target object\n * @param {any} source Source object\n * @returns {any} Merged object\n */\nfunction mergeDeep(target, source) {\n  const output = cloneDeep(target);\n  if (isObject(target) && isObject(source)) {\n    Object.keys(source).forEach(key => {\n      if (Array.isArray(source[key])) {\n        output[key] = source[key];\n        output[key].push(...(target[key] || []).filter(val => !source[key].includes(val)));\n      } else if (isObject(source[key])) {\n        if (!(key in target)) Object.assign(output, {\n          [key]: source[key]\n        });else output[key] = mergeDeep(target[key], source[key]);\n      } else {\n        Object.assign(output, {\n          [key]: source[key]\n        });\n      }\n    });\n  }\n  return output;\n}","export * from './DataFrame';\nexport * from './object';\nexport * from './position';\nexport * from './decorators';\nexport * from './values';\nexport * from './DataSerializer';\nexport * from './Serializer';\nexport * from './Deserializer';\nexport * from './DataSerializerUtils';","var DataObject_1;\nimport { __decorate, __metadata } from \"tslib\";\nimport { AbsolutePosition } from '../position/AbsolutePosition';\nimport { RelativePosition } from '../position/RelativePosition';\nimport { SerializableObject, SerializableMember, SerializableArrayMember, NumberType } from '../decorators';\nimport { v4 as uuidv4 } from 'uuid';\nimport { DataSerializer } from '../DataSerializer';\nimport { TimeService } from '../../service/TimeService';\nimport { EventEmitter } from 'events';\n/**\n * A data object is an instance that can be anything ranging from a person or asset to\n * a more abstract object such as a Wi-Fi access point or {@link ReferenceSpace}.\n *\n * ## Usage\n *\n * ### Creation\n * Objects can be created with an optional uid and display name.\n * ```typescript\n * const myObject = new DataObject(\"mvdewync\", \"Maxim\");\n * ```\n *\n * ### Service binding\n * Data objects can be bounded to a service. Persistence is handled in {@link DataObjectService}s\n * that store and load data objects.\n * ```typescript\n * myObject.bind(myModel).save();\n * ```\n *\n * @category data\n */\nlet DataObject = DataObject_1 = class DataObject {\n  /**\n   * Create a new data object\n   *\n   * @param {string} uid Optional unique identifier\n   * @param {string} displayName Optional display name\n   */\n  constructor(uid = uuidv4(), displayName) {\n    this._relativePositions = new Map();\n    this.uid = uid;\n    this.createdTimestamp = TimeService.now();\n    this.displayName = displayName;\n  }\n  /**\n   * Get the current absolute position of the object\n   * relative to the global reference space\n   *\n   * @returns {AbsolutePosition} Absolute position of data object\n   */\n  get position() {\n    return this.getPosition();\n  }\n  /**\n   * Set the current absolute position of the object\n   * relative to the global reference space\n   */\n  set position(position) {\n    this.setPosition(position);\n  }\n  /**\n   * Get the current absolute position of the object\n   *\n   * @param {TransformationSpace} [referenceSpace] Reference space to transform it to\n   * @returns {AbsolutePosition} Position of the data object\n   */\n  getPosition(referenceSpace) {\n    if (referenceSpace !== undefined && this._position !== undefined) {\n      return referenceSpace.transform(this._position, {\n        inverse: true\n      });\n    } else {\n      return this._position;\n    }\n  }\n  /**\n   * Set the current absolute position of the object\n   *\n   * @param {AbsolutePosition} position Position to set\n   * @param {TransformationSpace} [referenceSpace] Reference space\n   * @returns {DataObject} Data object instance\n   */\n  setPosition(position, referenceSpace) {\n    this._position = referenceSpace ? referenceSpace.transform(position, {\n      inverse: false\n    }) : position;\n    return this;\n  }\n  /**\n   * Set the unique identifier of this object\n   *\n   * @param {string} uid Unique Identifier\n   * @returns {DataObject} Data object instance\n   */\n  setUID(uid) {\n    this.uid = uid;\n    return this;\n  }\n  /**\n   * Get relative positions\n   *\n   * @returns {RelativePosition[]} Array of relative positions\n   */\n  get relativePositions() {\n    const relativePostions = [];\n    if (this._relativePositions !== undefined) {\n      this._relativePositions.forEach(values => {\n        values.forEach(value => {\n          relativePostions.push(value);\n        });\n      });\n    }\n    return relativePostions;\n  }\n  set relativePositions(relativePostions) {\n    this._relativePositions = new Map();\n    relativePostions.forEach(relativePostion => {\n      this.addRelativePosition(relativePostion);\n    });\n  }\n  /**\n   * Set a parent object to the data object\n   *\n   * @param {DataObject | string | undefined} object Data object or UID to add as parent\n   * @returns {DataObject} instance\n   */\n  setParent(object) {\n    this.parentUID = object instanceof DataObject_1 ? object.uid : object;\n    return this;\n  }\n  removeRelativePositions(referenceObjectUID) {\n    this._relativePositions.delete(referenceObjectUID);\n  }\n  /**\n   * Add a relative position to this data object\n   *\n   * @param {RelativePosition} relativePosition Relative position to add\n   * @returns {DataObject} Data object instance\n   */\n  addRelativePosition(relativePosition) {\n    if (!relativePosition || relativePosition.referenceObjectUID === undefined) {\n      return this;\n    }\n    if (!this._relativePositions.has(relativePosition.referenceObjectUID)) {\n      this._relativePositions.set(relativePosition.referenceObjectUID, new Map());\n    }\n    this._relativePositions.get(relativePosition.referenceObjectUID).set(relativePosition.constructor.name, relativePosition);\n    return this;\n  }\n  /**\n   * Get relative positions for a different target\n   *\n   * @param {string} [referenceObjectUID] Reference object identifier\n   * @returns {RelativePosition[]} Array of relative positions for the reference object\n   */\n  getRelativePositions(referenceObjectUID) {\n    if (referenceObjectUID === undefined) {\n      return this.relativePositions;\n    } else if (this._relativePositions.has(referenceObjectUID)) {\n      return Array.from(this._relativePositions.get(referenceObjectUID).values());\n    } else {\n      return [];\n    }\n  }\n  /**\n   * Get relative position of a specified object\n   *\n   * @param {string} referenceObjectUID Reference object identifier\n   * @param {string} type Constructor type of the relative position\n   * @returns {RelativePosition} Relative position to reference object\n   */\n  getRelativePosition(referenceObjectUID, type) {\n    if (this._relativePositions.has(referenceObjectUID)) {\n      const positions = this._relativePositions.get(referenceObjectUID);\n      if (type) {\n        return positions.get(type);\n      } else {\n        return Array.from(positions.values())[0];\n      }\n    } else {\n      return undefined;\n    }\n  }\n  hasRelativePosition(referenceObjectUID) {\n    return this._relativePositions.has(referenceObjectUID);\n  }\n  /**\n   * Bind the data object to a service\n   *\n   * @param {DataService<string, DataObject>} service Service to bind it to\n   * @returns {DataObjectBinding<DataObject>} Data object binding with a service\n   */\n  bind(service) {\n    return new DataObjectBinding(this, service);\n  }\n  /**\n   * Clone the data object\n   *\n   * @returns {DataObject} Cloned data object\n   */\n  clone() {\n    return DataSerializer.clone(this);\n  }\n};\n__decorate([SerializableMember(), __metadata(\"design:type\", String)], DataObject.prototype, \"displayName\", void 0);\n__decorate([SerializableMember({\n  index: true,\n  numberType: NumberType.LONG\n}), __metadata(\"design:type\", Number)], DataObject.prototype, \"createdTimestamp\", void 0);\n__decorate([SerializableMember({\n  primaryKey: true\n}), __metadata(\"design:type\", String)], DataObject.prototype, \"uid\", void 0);\n__decorate([SerializableMember(), __metadata(\"design:type\", String)], DataObject.prototype, \"parentUID\", void 0);\n__decorate([SerializableMember(), __metadata(\"design:type\", AbsolutePosition), __metadata(\"design:paramtypes\", [AbsolutePosition])], DataObject.prototype, \"position\", null);\n__decorate([SerializableArrayMember(RelativePosition), __metadata(\"design:type\", Array), __metadata(\"design:paramtypes\", [Array])], DataObject.prototype, \"relativePositions\", null);\nDataObject = DataObject_1 = __decorate([SerializableObject(), __metadata(\"design:paramtypes\", [String, String])], DataObject);\nexport { DataObject };\nclass DataObjectBinding extends EventEmitter {\n  constructor(target, service) {\n    super();\n    this.target = target;\n    this.service = service;\n    this.service.on('insert', this._onInsert.bind(this));\n  }\n  _onInsert(uid, object) {\n    if (this.target.uid === uid) {\n      this.emit('update', this.target, object);\n      this.target = object;\n    }\n  }\n  on(name, listener) {\n    return super.on(name, listener);\n  }\n  /**\n   * Save the data object\n   *\n   * @returns {Promise<DataObject>} Promise of stored data object\n   */\n  save() {\n    return this.service.insert(this.target.uid, this.target);\n  }\n  /**\n   * Destroy the data object\n   *\n   * @returns {Promise<void>} Destroy promise\n   */\n  delete() {\n    return this.service.delete(this.target.uid);\n  }\n  /**\n   * Dispose of the binding\n   */\n  dispose() {\n    this.service.removeListener('update', this._onInsert.bind(this));\n  }\n}","import { __decorate, __metadata } from \"tslib\";\nimport { SerializableMember, SerializableObject } from '../decorators';\nimport { Orientation } from '../position';\nimport { SensorValue } from '../values';\nimport { DataObject } from './DataObject';\n/**\n * A sensor object is a {@link DataObject} that is a sensor with a value.\n */\nlet SensorObject =\n// eslint-disable-next-line\nclass SensorObject extends DataObject {\n  constructor(uid, value, frequency, displayName) {\n    super(uid, displayName);\n    this.value = value !== null && value !== void 0 ? value : {};\n    this.frequency = frequency;\n  }\n  /**\n   * Get the sensor timestamp\n   *\n   * @returns {number} timestamp\n   */\n  get timestamp() {\n    return this.value instanceof SensorValue || this.value instanceof Orientation ? this.value.timestamp : this.createdTimestamp;\n  }\n};\n__decorate([SerializableMember(), __metadata(\"design:type\", Object)], SensorObject.prototype, \"value\", void 0);\n__decorate([SerializableMember(), __metadata(\"design:type\", Number)], SensorObject.prototype, \"frequency\", void 0);\nSensorObject = __decorate([SerializableObject()\n// eslint-disable-next-line\n, __metadata(\"design:paramtypes\", [String, Object, Number, String])], SensorObject);\nexport { SensorObject };","export * from './DataObject';\nexport * from './space';\nexport * from './SensorObject';\nexport * from './sensors';","import { __decorate, __metadata } from \"tslib\";\nimport { SerializableObject } from '../../decorators';\nimport { Orientation } from '../../position';\nimport { SensorObject } from '../SensorObject';\n/**\n * Absolute orientation sensor describes the device's physical orientation in relation to the Earth's reference coordinate system.\n *\n * @category data\n */\nlet AbsoluteOrientationSensor = class AbsoluteOrientationSensor extends SensorObject {\n  constructor(uid, value, frequency, displayName) {\n    super(uid, value !== null && value !== void 0 ? value : new Orientation(), frequency, displayName);\n  }\n};\nAbsoluteOrientationSensor = __decorate([SerializableObject(), __metadata(\"design:paramtypes\", [String, Orientation, Number, String])], AbsoluteOrientationSensor);\nexport { AbsoluteOrientationSensor };","import { __decorate, __metadata } from \"tslib\";\nimport { SerializableObject } from '../../decorators';\nimport { Acceleration } from '../../values';\nimport { SensorObject } from '../SensorObject';\n/**\n * Accelerometer sensor provides on each reading the acceleration applied to the device along all three axes including gravity.\n *\n * @category data\n */\nlet Accelerometer = class Accelerometer extends SensorObject {\n  constructor(uid, value, frequency, displayName) {\n    super(uid, value !== null && value !== void 0 ? value : new Acceleration(), frequency, displayName);\n  }\n};\nAccelerometer = __decorate([SerializableObject(), __metadata(\"design:paramtypes\", [String, Acceleration, Number, String])], Accelerometer);\nexport { Accelerometer };","import { __decorate, __metadata } from \"tslib\";\nimport { SerializableObject } from '../../decorators';\nimport { Acceleration } from '../../values';\nimport { SensorObject } from '../SensorObject';\n/**\n * The gravity sensor provides on each reading the gravity applied to the device along all three axes.\n *\n * @category data\n */\nlet GravitySensor = class GravitySensor extends SensorObject {\n  constructor(uid, value, frequency, displayName) {\n    super(uid, value !== null && value !== void 0 ? value : new Acceleration(), frequency, displayName);\n  }\n};\nGravitySensor = __decorate([SerializableObject(), __metadata(\"design:paramtypes\", [String, Acceleration, Number, String])], GravitySensor);\nexport { GravitySensor };","import { __decorate, __metadata } from \"tslib\";\nimport { SerializableObject } from '../../decorators';\nimport { AngularVelocity } from '../../values';\nimport { SensorObject } from '../SensorObject';\n/**\n * The gyroscope provides on each reading the angular velocity of the device along all three axes.\n *\n * @category data\n */\nlet Gyroscope = class Gyroscope extends SensorObject {\n  constructor(uid, value, frequency, displayName) {\n    super(uid, value !== null && value !== void 0 ? value : new AngularVelocity(), frequency, displayName);\n  }\n};\nGyroscope = __decorate([SerializableObject(), __metadata(\"design:paramtypes\", [String, AngularVelocity, Number, String])], Gyroscope);\nexport { Gyroscope };","import { __decorate, __metadata } from \"tslib\";\nimport { SerializableObject } from '../../decorators';\nimport { Acceleration } from '../../values';\nimport { SensorObject } from '../SensorObject';\n/**\n * The linear acceleration sensor provides on each reading the acceleration applied to the device along all three axes, but without the contribution of gravity.\n *\n * @category data\n */\nlet LinearAccelerationSensor = class LinearAccelerationSensor extends SensorObject {\n  constructor(uid, value, frequency, displayName) {\n    super(uid, value !== null && value !== void 0 ? value : new Acceleration(), frequency, displayName);\n  }\n};\nLinearAccelerationSensor = __decorate([SerializableObject(), __metadata(\"design:paramtypes\", [String, Acceleration, Number, String])], LinearAccelerationSensor);\nexport { LinearAccelerationSensor };","import { __decorate, __metadata } from \"tslib\";\nimport { SerializableObject } from '../../decorators';\nimport { LinearVelocity } from '../../values';\nimport { SensorObject } from '../SensorObject';\n/**\n * The linear velocity sensors provides on each reading the linear velocity of the device along all three axes.\n *\n * @category data\n */\nlet LinearVelocitySensor = class LinearVelocitySensor extends SensorObject {\n  constructor(uid, value, frequency, displayName) {\n    super(uid, value !== null && value !== void 0 ? value : new LinearVelocity(), frequency, displayName);\n  }\n};\nLinearVelocitySensor = __decorate([SerializableObject(), __metadata(\"design:paramtypes\", [String, LinearVelocity, Number, String])], LinearVelocitySensor);\nexport { LinearVelocitySensor };","import { __decorate, __metadata } from \"tslib\";\nimport { SerializableObject } from '../../decorators';\nimport { Magnetism } from '../../values';\nimport { SensorObject } from '../SensorObject';\n/**\n * The magnetometer sensor provides information about the magnetic field as detected by the device's primary magnetometer sensor.\n *\n * @category data\n */\nlet Magnetometer = class Magnetometer extends SensorObject {\n  constructor(uid, value, frequency, displayName) {\n    super(uid, value !== null && value !== void 0 ? value : new Magnetism(), frequency, displayName);\n  }\n};\nMagnetometer = __decorate([SerializableObject(), __metadata(\"design:paramtypes\", [String, Magnetism, Number, String])], Magnetometer);\nexport { Magnetometer };","import { __decorate, __metadata } from \"tslib\";\nimport { SerializableObject } from '../../decorators';\nimport { Orientation } from '../../position';\nimport { SensorObject } from '../SensorObject';\n/**\n * The relative orientation sensor describes the device's physical orientation without regard to the Earth's reference coordinate system.\n *\n * @category data\n */\nlet RelativeOrientationSensor = class RelativeOrientationSensor extends SensorObject {\n  constructor(uid, value, frequency, displayName) {\n    super(uid, value !== null && value !== void 0 ? value : new Orientation(), frequency, displayName);\n  }\n};\nRelativeOrientationSensor = __decorate([SerializableObject(), __metadata(\"design:paramtypes\", [String, Orientation, Number, String])], RelativeOrientationSensor);\nexport { RelativeOrientationSensor };","export * from './Accelerometer';\nexport * from './GravitySensor';\nexport * from './Gyroscope';\nexport * from './LinearAccelerationSensor';\nexport * from './AbsoluteOrientationSensor';\nexport * from './RelativeOrientationSensor';\nexport * from './Magnetometer';\nexport * from './LinearVelocitySensor';","import { __decorate, __metadata } from \"tslib\";\nimport { DataObject } from '../DataObject';\nimport { SerializableObject, SerializableMember } from '../../decorators';\nimport { Matrix4, Euler, Quaternion, AxisAngle, Vector3 } from '../../../utils/math';\nimport { LengthUnit } from '../../../utils';\n/**\n * A reference space transforms absolute positions to another (global) reference space.\n * The following data can be transformed:\n * - Position coordinates\n * - Linear velocity\n * - Angular velocity\n * - Orientation\n * - Position accuracy\n */\nlet ReferenceSpace = class ReferenceSpace extends DataObject {\n  constructor(parent) {\n    super();\n    this.parent = parent;\n    this._scaleMatrix = new Matrix4();\n    this._transformationMatrix = new Matrix4().identity();\n    this._translationMatrix = new Matrix4().identity();\n    this._rotation = new Quaternion();\n  }\n  /**\n   * Set the parent space\n   *\n   * @param {TransformationSpace} space Parent space\n   */\n  set parent(space) {\n    if (!space) {\n      return;\n    } else {\n      this.parentUID = space.uid;\n      this._parent = space;\n    }\n  }\n  /**\n   * Get the parent space if loaded\n   *\n   * @returns {TransformationSpace | undefined} Transformation space or undefined\n   */\n  get parent() {\n    return this._parent;\n  }\n  /**\n   * Update parent reference spaces\n   *\n   * @param {DataService} service Service to use for updating\n   * @returns {Promise<void>} Update promise\n   */\n  update(service) {\n    return new Promise((resolve, reject) => {\n      if (this.parentUID) {\n        // Update parent\n        service.findByUID(this.parentUID).then(parent => {\n          this._parent = parent;\n          if (!parent) {\n            throw new Error(`Unable to find reference space with uid: ${this.parentUID}!`);\n          }\n          return this._parent.update(service);\n        }).then(resolve).catch(reject);\n      } else {\n        resolve();\n      }\n    });\n  }\n  orthographic(left, right, bottom, top, near, far) {\n    this._transformationMatrix.multiply(new Matrix4().makeOrthographic(left, right, bottom, top, near, far));\n    return this;\n  }\n  /**\n   * Transform perspective\n   *\n   * @param {number} left Farthest left on the x-axis\n   * @param {number} right Farthest right on the x-axis\n   * @param {number} bottom Farthest down on the y-axis\n   * @param {number} top Farthest up on the y-axis\n   * @param {number} near Distance to the near clipping plane along the -Z axis\n   * @param {number} far Distance to the far clipping plane along the -Z axis\n   * @returns {ReferenceSpace} Reference space instance\n   */\n  perspective(left, right, bottom, top, near, far) {\n    this._transformationMatrix.multiply(new Matrix4().makePerspective(left, right, bottom, top, near, far));\n    return this;\n  }\n  reset() {\n    this._transformationMatrix.identity();\n    this._scaleMatrix = new Matrix4();\n    this._rotation = new Quaternion();\n    return this;\n  }\n  referenceUnit(unit) {\n    this._unit = unit;\n    return this;\n  }\n  translation(dX, dY, dZ = 0) {\n    this._translationMatrix.multiply(new Matrix4().makeTranslation(dX, dY, dZ));\n    this._transformationMatrix.multiply(this._translationMatrix);\n    return this;\n  }\n  scale(kX, kY, kZ = 1.0) {\n    this._scaleMatrix = new Matrix4().makeScale(kX, kY, kZ);\n    this._transformationMatrix.multiply(this._scaleMatrix);\n    return this;\n  }\n  rotation(r) {\n    if (r instanceof Quaternion) {\n      this._rotation = r.clone();\n      this._transformationMatrix.multiply(this._rotation.toRotationMatrix());\n    } else if (r instanceof Euler) {\n      this._rotation = Quaternion.fromEuler(r);\n      this._transformationMatrix.multiply(this._rotation.toRotationMatrix());\n    } else if (r instanceof AxisAngle) {\n      this._rotation = Quaternion.fromAxisAngle(r);\n      this._transformationMatrix.multiply(this._rotation.toRotationMatrix());\n    } else {\n      this._rotation = Quaternion.fromEuler(r);\n      this._transformationMatrix.multiply(this._rotation.toRotationMatrix());\n    }\n    return this;\n  }\n  /**\n   * Transform a position\n   *\n   * @param {AbsolutePosition} position Position to transform\n   * @param {SpaceTransformationOptions} [options] Transformation options\n   * @returns {AbsolutePosition} Transformed position\n   */\n  transform(position, options) {\n    const config = options || {};\n    // Clone the position\n    const newPosition = this._parent ? this._parent.transform(position, options) : position.clone();\n    // Transform the position to the length unit\n    if (this._unit) {\n      newPosition.fromVector(newPosition.toVector3(this._unit));\n      newPosition.setAccuracy(newPosition.accuracy.to(this._unit));\n    }\n    const transformationMatrix = config.inverse ? this.transformationMatrix.clone().invert() : this.transformationMatrix;\n    const rotation = config.inverse ? this.rotationQuaternion.clone().invert() : this.rotationQuaternion;\n    const scale = config.inverse ? this._scaleMatrix.clone().invert() : this.scaleMatrix;\n    // Transform the point using the transformation matrix\n    newPosition.fromVector(newPosition.toVector3().applyMatrix4(transformationMatrix));\n    // Transform the orientation (rotation)\n    if (newPosition.orientation) {\n      // Rotate the quaterion\n      newPosition.orientation.multiply(rotation);\n    }\n    if (newPosition.linearVelocity) {\n      // Transform the linear velocity (rotation and scale)\n      newPosition.linearVelocity.applyMatrix4(scale).applyMatrix4(Matrix4.rotationFromQuaternion(rotation));\n    }\n    newPosition.setAccuracy(new Vector3(newPosition.accuracy.valueOf(), 0, 0).applyMatrix4(scale).x, newPosition.accuracy.unit);\n    newPosition.referenceSpaceUID = this.uid;\n    return newPosition;\n  }\n  get transformationMatrix() {\n    return this._transformationMatrix;\n  }\n  set transformationMatrix(matrix) {\n    this._transformationMatrix = matrix;\n  }\n  /**\n   * Get the transformation matrix for scaling\n   *\n   * @returns {Matrix4} Transformation matrix\n   */\n  get scaleMatrix() {\n    return this._scaleMatrix;\n  }\n  set scaleMatrix(matrix) {\n    this._scaleMatrix = matrix;\n  }\n  get rotationQuaternion() {\n    return this._rotation;\n  }\n  set rotationQuaternion(quaternion) {\n    this._rotation = quaternion;\n  }\n  get translationMatrix() {\n    return this._translationMatrix;\n  }\n  set translationMatrix(matrix) {\n    this._translationMatrix = matrix;\n  }\n};\n__decorate([SerializableMember({\n  name: 'translationMatrix'\n}), __metadata(\"design:type\", Matrix4)], ReferenceSpace.prototype, \"_translationMatrix\", void 0);\n__decorate([SerializableMember({\n  name: 'transformationMatrix'\n}), __metadata(\"design:type\", Matrix4)], ReferenceSpace.prototype, \"_transformationMatrix\", void 0);\n__decorate([SerializableMember({\n  name: 'scaleMatrix'\n}), __metadata(\"design:type\", Matrix4)], ReferenceSpace.prototype, \"_scaleMatrix\", void 0);\n__decorate([SerializableMember({\n  name: 'rotation'\n}), __metadata(\"design:type\", Quaternion)], ReferenceSpace.prototype, \"_rotation\", void 0);\n__decorate([SerializableMember({\n  name: 'unit'\n}), __metadata(\"design:type\", LengthUnit)], ReferenceSpace.prototype, \"_unit\", void 0);\nReferenceSpace = __decorate([SerializableObject(), __metadata(\"design:paramtypes\", [Object])], ReferenceSpace);\nexport { ReferenceSpace };","export * from './ReferenceSpace';\nexport * from './TransformationSpace';","import { __decorate, __metadata } from \"tslib\";\nimport { AbsolutePosition } from './AbsolutePosition';\nimport { NumberType, SerializableMember, SerializableObject } from '../decorators';\nimport { LengthUnit } from '../../utils';\nimport { Vector3 } from '../../utils/math';\n/**\n * Absolute cartesian 2D position. This class uses a {@link Vector2}. This location can be used both as\n * an absolute location or relative location.\n *\n * @category Position\n */\nlet Absolute2DPosition = class Absolute2DPosition extends AbsolutePosition {\n  constructor(x, y, unit = LengthUnit.METER) {\n    super();\n    this.vector = new Vector3();\n    this.vector.x = unit.convert(x ? x : 0, LengthUnit.METER);\n    this.vector.y = unit.convert(y ? y : 0, LengthUnit.METER);\n  }\n  get x() {\n    if (!this.vector) {\n      return undefined;\n    }\n    return this.vector.x;\n  }\n  set x(value) {\n    if (!this.vector) {\n      return;\n    }\n    this.vector.x = value;\n  }\n  get y() {\n    if (!this.vector) {\n      return undefined;\n    }\n    return this.vector.y;\n  }\n  set y(value) {\n    if (!this.vector) {\n      return;\n    }\n    this.vector.y = value;\n  }\n  /**\n   * Get the angle in radians from this position to a destination\n   *\n   * @param {Absolute2DPosition} destination Destination position\n   * @returns {number} Bearing in radians from this position to destination\n   */\n  angleTo(destination) {\n    return this.vector.angleTo(destination.vector);\n  }\n  fromVector(vector, unit) {\n    if (unit) {\n      this.x = unit.convert(vector.x, this.unit);\n      this.y = unit.convert(vector.y, this.unit);\n    } else {\n      this.x = vector.x;\n      this.y = vector.y;\n    }\n    return this;\n  }\n  toVector3(unit) {\n    if (unit) {\n      return new Vector3(this.unit.convert(this.x, unit), this.unit.convert(this.y, unit));\n    } else {\n      return new Vector3(this.x, this.y);\n    }\n  }\n  /**\n   * Clone the position\n   *\n   * @returns {Absolute2DPosition} Cloned position\n   */\n  clone() {\n    const position = super.clone();\n    position.x = this.x;\n    position.y = this.y;\n    return position;\n  }\n};\n__decorate([SerializableMember({\n  numberType: NumberType.DECIMAL\n}), __metadata(\"design:type\", Number), __metadata(\"design:paramtypes\", [Number])], Absolute2DPosition.prototype, \"x\", null);\n__decorate([SerializableMember({\n  numberType: NumberType.DECIMAL\n}), __metadata(\"design:type\", Number), __metadata(\"design:paramtypes\", [Number])], Absolute2DPosition.prototype, \"y\", null);\nAbsolute2DPosition = __decorate([SerializableObject(), __metadata(\"design:paramtypes\", [Number, Number, LengthUnit])], Absolute2DPosition);\nexport { Absolute2DPosition };","import { __decorate, __metadata } from \"tslib\";\nimport { NumberType, SerializableMember, SerializableObject } from '../decorators';\nimport { LengthUnit, Vector3 } from '../../utils';\nimport { Absolute2DPosition } from './Absolute2DPosition';\n/**\n * Absolute cartesian 3D position. This class uses a {@link Vector3}. This location can be used both as\n * an absolute location or relative location.\n *\n * @category Position\n */\nlet Absolute3DPosition = class Absolute3DPosition extends Absolute2DPosition {\n  constructor(x, y, z, unit = LengthUnit.METER) {\n    super(x, y, unit);\n    this.vector.z = unit.convert(z ? z : 0, LengthUnit.METER);\n  }\n  get z() {\n    if (!this.vector) {\n      return undefined;\n    }\n    return this.vector.z;\n  }\n  set z(value) {\n    if (!this.vector) {\n      return;\n    }\n    this.vector.z = value;\n  }\n  fromVector(vector, unit) {\n    if (unit) {\n      this.x = unit.convert(vector.x, this.unit);\n      this.y = unit.convert(vector.y, this.unit);\n      this.z = unit.convert(vector.z, this.unit);\n    } else {\n      this.x = vector.x;\n      this.y = vector.y;\n      this.z = vector.z;\n    }\n    return this;\n  }\n  toVector3(unit) {\n    if (unit) {\n      return new Vector3(this.unit.convert(this.x, unit), this.unit.convert(this.y, unit), this.unit.convert(this.z, unit));\n    } else {\n      return new Vector3(this.x, this.y, this.z);\n    }\n  }\n  /**\n   * Clone the position\n   *\n   * @returns {Absolute3DPosition} Cloned position\n   */\n  clone() {\n    const position = super.clone();\n    position.x = this.x;\n    position.y = this.y;\n    position.z = this.z;\n    return position;\n  }\n};\n__decorate([SerializableMember({\n  numberType: NumberType.DECIMAL\n}), __metadata(\"design:type\", Number), __metadata(\"design:paramtypes\", [Number])], Absolute3DPosition.prototype, \"z\", null);\nAbsolute3DPosition = __decorate([SerializableObject(), __metadata(\"design:paramtypes\", [Number, Number, Number, LengthUnit])], Absolute3DPosition);\nexport { Absolute3DPosition };","import { __decorate, __metadata } from \"tslib\";\nimport { LengthUnit } from '../../utils/unit';\nimport { Velocity } from '../values/Velocity';\nimport { Orientation } from './Orientation';\nimport { SerializableMember, SerializableObject } from '../decorators';\nimport { TimeService } from '../../service/TimeService';\nimport { Accuracy } from '../values/Accuracy';\nimport { Accuracy1D } from '../values/Accuracy1D';\nimport { EUCLIDEAN } from '../../utils';\n/**\n * An absolute position of a {@link DataObject}.\n *\n * @category Position\n */\nlet AbsolutePosition = class AbsolutePosition {\n  constructor() {\n    /**\n     * Position recording timestamp\n     */\n    this.timestamp = TimeService.now();\n    /**\n     * Velocity at recorded position\n     */\n    this.velocity = new Velocity();\n    /**\n     * Position unit\n     */\n    this.unit = LengthUnit.METER;\n  }\n  /**\n   * Get the position probability\n   *\n   * @returns {number} Probability between 0 and 1\n   */\n  get probability() {\n    if (!this._probability) {\n      return 1 / this.accuracy.valueOf();\n    }\n    return this._probability;\n  }\n  set probability(value) {\n    if (value > 1 || value < 0) {\n      throw new Error(`${this.constructor.name} should be between 0 and 1.`);\n    }\n    this._probability = value;\n  }\n  /**\n   * Position accuracy\n   *\n   * @returns {Accuracy} Position accuracy\n   */\n  get accuracy() {\n    if (!this._accuracy) {\n      this._accuracy = new Accuracy1D(1, this.unit);\n    }\n    return this._accuracy;\n  }\n  set accuracy(value) {\n    if (!value) {\n      throw new Error(`Accuracy can not be undefined!`);\n    }\n    this._accuracy = value;\n  }\n  /**\n   * Get the linear velocity\n   *\n   * @returns {LinearVelocity} Linear velocity\n   */\n  get linearVelocity() {\n    if (!this.velocity) {\n      return undefined;\n    }\n    return this.velocity.linear;\n  }\n  /**\n   * Set the linear velocity\n   */\n  set linearVelocity(value) {\n    if (!this.velocity) {\n      this.velocity = new Velocity();\n    }\n    this.velocity.linear = value;\n  }\n  /**\n   * Get the angular velocity\n   *\n   * @returns {AngularVelocity} Angular velocity\n   */\n  get angularVelocity() {\n    if (!this.velocity) {\n      return undefined;\n    }\n    return this.velocity.angular;\n  }\n  /**\n   * Set the angular velocity\n   */\n  set angularVelocity(value) {\n    if (!this.velocity) {\n      this.velocity = new Velocity();\n    }\n    this.velocity.angular = value;\n  }\n  /**\n   * Set the accuracy of the absolute position\n   *\n   * @param {number | Accuracy} accuracy Accuracy object or number\n   * @param {Unit} [unit] Optional unit\n   * @returns {AbsolutePosition} instance\n   */\n  setAccuracy(accuracy, unit) {\n    if (typeof accuracy === 'number') {\n      this.accuracy = new Accuracy1D(accuracy, unit || this.unit);\n    } else {\n      this.accuracy = accuracy;\n    }\n    return this;\n  }\n  /**\n   * Get the distance from this location to a destination\n   *\n   * @param {AbsolutePosition} destination Destination location\n   * @param {DistanceFn} [distanceFunction] Distance function to use (default EUCLIDEAN distance)\n   * @returns {number} Distance between this point and destination\n   */\n  distanceTo(destination, distanceFunction = EUCLIDEAN) {\n    return distanceFunction(this.toVector3().toArray(), destination.toVector3().toArray());\n  }\n  equals(position) {\n    return this.toVector3(this.unit).equals(position.toVector3(this.unit));\n  }\n  /**\n   * Clone the position\n   *\n   * @returns {AbsolutePosition} Cloned position\n   */\n  clone() {\n    const position = new this.constructor();\n    position.unit = this.unit;\n    position._accuracy = this._accuracy ? this._accuracy.clone() : undefined;\n    position.orientation = this.orientation ? this.orientation.clone() : undefined;\n    position.velocity = this.velocity ? this.velocity.clone() : undefined;\n    position.timestamp = this.timestamp;\n    position.referenceSpaceUID = this.referenceSpaceUID;\n    return position;\n  }\n};\n__decorate([SerializableMember({\n  index: true\n}), __metadata(\"design:type\", Number)], AbsolutePosition.prototype, \"timestamp\", void 0);\n__decorate([SerializableMember(), __metadata(\"design:type\", Velocity)], AbsolutePosition.prototype, \"velocity\", void 0);\n__decorate([SerializableMember(), __metadata(\"design:type\", Orientation)], AbsolutePosition.prototype, \"orientation\", void 0);\n__decorate([SerializableMember(), __metadata(\"design:type\", LengthUnit)], AbsolutePosition.prototype, \"unit\", void 0);\n__decorate([SerializableMember({\n  index: true\n}), __metadata(\"design:type\", String)], AbsolutePosition.prototype, \"referenceSpaceUID\", void 0);\n__decorate([SerializableMember({\n  name: 'accuracy'\n}), __metadata(\"design:type\", Accuracy)], AbsolutePosition.prototype, \"_accuracy\", void 0);\n__decorate([SerializableMember({\n  name: 'probability'\n}), __metadata(\"design:type\", Number)], AbsolutePosition.prototype, \"_probability\", void 0);\nAbsolutePosition = __decorate([SerializableObject()], AbsolutePosition);\nexport { AbsolutePosition };","var GeographicalPosition_1;\nimport { __decorate, __metadata } from \"tslib\";\nimport { AngleUnit } from '../../utils/unit/AngleUnit';\nimport { LengthUnit } from '../../utils/unit/LengthUnit';\nimport { SerializableObject, SerializableMember, NumberType } from '../decorators';\nimport { Absolute3DPosition } from './Absolute3DPosition';\nimport { GCS, HAVERSINE, Vector3 } from '../../utils';\n/**\n * Geographical WGS 84 position stored as an 3D vector in ISO 6709.\n *\n * @category Position\n */\nlet GeographicalPosition = GeographicalPosition_1 = class GeographicalPosition extends Absolute3DPosition {\n  constructor(lat, lng, amsl) {\n    super();\n    this.latitude = lat;\n    this.longitude = lng;\n    this.z = amsl;\n  }\n  /**\n   * Geographical Latitude\n   *\n   * @returns {number} Latitude\n   */\n  get latitude() {\n    return this.y;\n  }\n  set latitude(lat) {\n    this.y = lat;\n  }\n  /**\n   * Geographical Longitude\n   *\n   * @returns {number} Longitude\n   */\n  get longitude() {\n    return this.x;\n  }\n  set longitude(lng) {\n    this.x = lng;\n  }\n  /**\n   * Altitude above mean sea level\n   *\n   * @returns {number} Altitude\n   */\n  get altitude() {\n    return this.z;\n  }\n  set altitude(amsl) {\n    this.z = amsl;\n  }\n  /**\n   * Get the distance from this location to a destination\n   *\n   * @param {GeographicalPosition} destination Destination location\n   * @returns {number} Distance between this point and destination\n   */\n  distanceTo(destination) {\n    return super.distanceTo(destination, HAVERSINE);\n  }\n  /**\n   * Get the bearing in degrees from this location to a destination\n   *\n   * @param {GeographicalPosition} destination Destination location\n   * @returns {number} Bearing in degrees from this position to destination\n   */\n  bearing(destination) {\n    return AngleUnit.RADIAN.convert(this.angleTo(destination), AngleUnit.DEGREE);\n  }\n  /**\n   * Get the bearing in radians from this location to a destination\n   *\n   * @param {GeographicalPosition} destination Destination location\n   * @returns {number} Bearing in radians from this position to destination\n   */\n  angleTo(destination) {\n    const lonRadA = AngleUnit.DEGREE.convert(this.longitude, AngleUnit.RADIAN);\n    const latRadA = AngleUnit.DEGREE.convert(this.latitude, AngleUnit.RADIAN);\n    const lonRadB = AngleUnit.DEGREE.convert(destination.longitude, AngleUnit.RADIAN);\n    const latRadB = AngleUnit.DEGREE.convert(destination.latitude, AngleUnit.RADIAN);\n    const y = Math.sin(lonRadB - lonRadA) * Math.cos(latRadB);\n    const x = Math.cos(latRadA) * Math.sin(latRadB) - Math.sin(latRadA) * Math.cos(latRadB) * Math.cos(lonRadB - lonRadA);\n    return Math.atan2(y, x);\n  }\n  destination(bearing, distance, bearingUnit = AngleUnit.DEGREE, distanceUnit = LengthUnit.METER) {\n    distance = distanceUnit.convert(distance, LengthUnit.METER);\n    const brng = bearingUnit.convert(bearing, AngleUnit.RADIAN);\n    const lonRadA = bearingUnit.convert(this.longitude, AngleUnit.RADIAN);\n    const latRadA = bearingUnit.convert(this.latitude, AngleUnit.RADIAN);\n    const latX = Math.asin(Math.sin(latRadA) * Math.cos(distance / GCS.EARTH_RADIUS_MEAN) + Math.cos(latRadA) * Math.sin(distance / GCS.EARTH_RADIUS_MEAN) * Math.cos(brng));\n    const lonX = lonRadA + Math.atan2(Math.sin(brng) * Math.sin(distance / GCS.EARTH_RADIUS_MEAN) * Math.cos(latRadA), Math.cos(distance / GCS.EARTH_RADIUS_MEAN) - Math.sin(latRadA) * Math.sin(latX));\n    const location = new GeographicalPosition_1();\n    location.latitude = AngleUnit.RADIAN.convert(latX, AngleUnit.DEGREE);\n    location.longitude = AngleUnit.RADIAN.convert(lonX, AngleUnit.DEGREE);\n    location.altitude = this.altitude;\n    location.unit = this.unit;\n    return location;\n  }\n  fromVector(vector, unit = GCS.WGS84) {\n    let converted;\n    if (unit instanceof LengthUnit) {\n      converted = GCS.ECEF.convert(new Vector3(unit.convert(vector.x, LengthUnit.METER), unit.convert(vector.y, LengthUnit.METER), unit.convert(vector.z, LengthUnit.METER)), GCS.WGS84);\n    } else if (unit instanceof GCS) {\n      converted = unit.convert(vector, GCS.WGS84);\n    }\n    this.x = converted.x;\n    this.y = converted.y;\n    this.z = converted.z;\n    return this;\n  }\n  toVector3(unit = GCS.WGS84) {\n    if (unit instanceof GCS) {\n      return GCS.WGS84.convert(new Vector3(this.x, this.y, this.z), unit);\n    } else if (unit instanceof LengthUnit) {\n      return GCS.WGS84.convert(new Vector3(LengthUnit.METER.convert(this.x, unit), LengthUnit.METER.convert(this.y, unit), LengthUnit.METER.convert(this.z, unit)), GCS.ECEF);\n    }\n  }\n  /**\n   * Clone the position\n   *\n   * @returns {GeographicalPosition} Cloned geographical position\n   */\n  clone() {\n    const position = super.clone();\n    position.latitude = this.latitude;\n    position.longitude = this.longitude;\n    position.z = this.altitude;\n    return position;\n  }\n};\n__decorate([SerializableMember({\n  numberType: NumberType.DECIMAL\n}), __metadata(\"design:type\", Number), __metadata(\"design:paramtypes\", [Number])], GeographicalPosition.prototype, \"latitude\", null);\n__decorate([SerializableMember({\n  numberType: NumberType.DECIMAL\n}), __metadata(\"design:type\", Number), __metadata(\"design:paramtypes\", [Number])], GeographicalPosition.prototype, \"longitude\", null);\n__decorate([SerializableMember({\n  numberType: NumberType.DECIMAL\n}), __metadata(\"design:type\", Number), __metadata(\"design:paramtypes\", [Number])], GeographicalPosition.prototype, \"altitude\", null);\nGeographicalPosition = GeographicalPosition_1 = __decorate([SerializableObject(), __metadata(\"design:paramtypes\", [Number, Number, Number])], GeographicalPosition);\nexport { GeographicalPosition };","var Orientation_1;\nimport { __decorate, __metadata } from \"tslib\";\nimport { Quaternion } from '../../utils/math';\nimport { NumberType, SerializableMember, SerializableObject } from '../decorators';\nimport { TimeService } from '../../service/TimeService';\nimport { Accuracy } from '../values/Accuracy';\nimport { AngleUnit } from '../../utils';\nimport { Accuracy1D } from '../values/Accuracy1D';\n/**\n * Orientation quaternion with accuracy\n *\n * @category Position\n */\nlet Orientation = Orientation_1 = class Orientation extends Quaternion {\n  constructor(x, y, z, w, accuracy) {\n    super(x, y, z, w);\n    this.accuracy = accuracy || new Accuracy1D(0, AngleUnit.RADIAN);\n    this.timestamp = TimeService.now();\n  }\n  static fromQuaternion(quat) {\n    return new Orientation_1(quat.x, quat.y, quat.z, quat.w);\n  }\n  clone() {\n    const vector = super.clone();\n    vector.accuracy = this.accuracy ? this.accuracy.clone() : undefined;\n    vector.timestamp = this.timestamp;\n    return vector;\n  }\n};\n__decorate([SerializableMember({\n  isRequired: false,\n  numberType: NumberType.LONG\n}), __metadata(\"design:type\", Number)], Orientation.prototype, \"timestamp\", void 0);\n__decorate([SerializableMember({\n  isRequired: false\n}), __metadata(\"design:type\", Accuracy)], Orientation.prototype, \"accuracy\", void 0);\nOrientation = Orientation_1 = __decorate([SerializableObject(), __metadata(\"design:paramtypes\", [Number, Number, Number, Number, Accuracy])], Orientation);\nexport { Orientation };","import { __decorate, __metadata } from \"tslib\";\nimport { TimeService } from '../../service/TimeService';\nimport { LengthUnit } from '../../utils';\nimport { Matrix4 } from '../../utils/math/';\nimport { SerializableMember, SerializableObject } from '../decorators';\nimport { Accuracy } from '../values/Accuracy';\nimport { Accuracy1D } from '../values/Accuracy1D';\nimport { Absolute3DPosition } from './Absolute3DPosition';\nimport { Orientation } from './Orientation';\n/**\n * Position and orientation.\n *\n * In computer vision and robotics, a typical task is to identify specific objects in an image and to determine each object's position and orientation relative to some coordinate system. This information can then be used, for example, to allow a robot to manipulate an object or to avoid moving into the object. The combination of position and orientation is referred to as the pose of an object, even though this concept is sometimes used only to describe the orientation. Exterior orientation and translation are also used as synonyms of pose.\n *\n * @see {@link https://en.wikipedia.org/wiki/Pose_(computer_vision)}\n */\nlet Pose = class Pose extends Matrix4 {\n  constructor() {\n    super(...arguments);\n    /**\n     * Position recording timestamp\n     */\n    this.timestamp = TimeService.now();\n    /**\n     * Position unit\n     */\n    this.unit = LengthUnit.METER;\n    this._probability = 1.0;\n  }\n  /**\n   * Get the position probability\n   *\n   * @returns {number} Probability between 0 and 1\n   */\n  get probability() {\n    return this._probability;\n  }\n  set probability(value) {\n    if (value > 1 || value < 0) {\n      throw new Error(`${this.constructor.name} should be between 0 and 1.`);\n    }\n    this._probability = value;\n  }\n  /**\n   * Position accuracy\n   *\n   * @returns {Accuracy} Position accuracy\n   */\n  get accuracy() {\n    if (!this._accuracy) {\n      this._accuracy = new Accuracy1D(1, this.unit);\n    }\n    return this._accuracy;\n  }\n  set accuracy(value) {\n    this._accuracy = value;\n  }\n  /**\n   * Get a pose from a 4d matrix\n   *\n   * @param {Matrix4} matrix 4x4 Matrix\n   * @returns {Pose} Pose instance\n   */\n  static fromMatrix4(matrix) {\n    const pose = new this();\n    pose.fromArray(matrix.toArray());\n    return pose;\n  }\n  /**\n   * Create a pose from a position\n   *\n   * @param {Absolute3DPosition} position 3D position\n   * @returns {Pose} Output pose\n   */\n  static fromPosition(position) {\n    const pose = new this();\n    pose.timestamp = position.timestamp;\n    pose.unit = position.unit;\n    pose.probability = position.probability;\n    pose.accuracy = pose.accuracy.clone();\n    const vector = position.toVector3();\n    if (position.orientation) {\n      pose.makeRotationFromQuaternion(position.orientation);\n    }\n    pose.setPosition(vector.x, vector.y, vector.z);\n    return pose;\n  }\n  /**\n   * Extract the orientation from the pose\n   *\n   * @returns {Orientation} Orientation\n   */\n  get orientation() {\n    const rotationMatrix = this.extractRotation(this);\n    const orientation = Orientation.fromRotationMatrix(rotationMatrix);\n    orientation.timestamp = this.timestamp;\n    return orientation;\n  }\n  /**\n   * Extract the 3d position from the pose\n   *\n   * @returns {Absolute3DPosition} 3D position\n   */\n  get position() {\n    const positionMatrix = this.copyPosition(this);\n    const position = new Absolute3DPosition(positionMatrix.elements[12], positionMatrix.elements[13], positionMatrix.elements[14]);\n    position.timestamp = this.timestamp;\n    position.unit = this.unit;\n    position.probability = this.probability;\n    position.accuracy = this.accuracy.clone();\n    position.orientation = this.orientation;\n    return position;\n  }\n};\n__decorate([SerializableMember({\n  index: true\n}), __metadata(\"design:type\", Number)], Pose.prototype, \"timestamp\", void 0);\n__decorate([SerializableMember(), __metadata(\"design:type\", LengthUnit)], Pose.prototype, \"unit\", void 0);\n__decorate([SerializableMember({\n  name: 'accuracy'\n}), __metadata(\"design:type\", Accuracy)], Pose.prototype, \"_accuracy\", void 0);\n__decorate([SerializableMember(), __metadata(\"design:type\", Number), __metadata(\"design:paramtypes\", [Number])], Pose.prototype, \"probability\", null);\nPose = __decorate([SerializableObject()], Pose);\nexport { Pose };","import { __decorate, __metadata } from \"tslib\";\nimport { AngleUnit } from '../../utils';\nimport { SerializableObject, SerializableMember } from '../decorators';\nimport { Orientation } from './Orientation';\nimport { RelativePosition } from './RelativePosition';\n/**\n * Relative location to another reference object measured in the angle.\n *\n * @category Position\n */\nlet RelativeAngle = class RelativeAngle extends RelativePosition {\n  constructor(referenceObject, angle, angleUnit, orientation) {\n    super(referenceObject, angle, angleUnit || AngleUnit.RADIAN);\n    /**\n     * Orientation at recorded position\n     */\n    this.orientation = new Orientation();\n    this.angleUnit = angleUnit;\n    if (orientation) {\n      this.orientation = orientation;\n    }\n  }\n  /**\n   * Angle to reference object\n   *\n   * @returns {number} Angle\n   */\n  get angle() {\n    return this.referenceValue;\n  }\n  set angle(value) {\n    this.referenceValue = value;\n  }\n};\n__decorate([SerializableMember(), __metadata(\"design:type\", Orientation)], RelativeAngle.prototype, \"orientation\", void 0);\n__decorate([SerializableMember(), __metadata(\"design:type\", AngleUnit)], RelativeAngle.prototype, \"angleUnit\", void 0);\nRelativeAngle = __decorate([SerializableObject(), __metadata(\"design:paramtypes\", [Object, Number, AngleUnit, Orientation])], RelativeAngle);\nexport { RelativeAngle };","import { __decorate, __metadata } from \"tslib\";\nimport { RelativePosition } from './RelativePosition';\nimport { SerializableObject } from '../decorators';\nimport { AngularVelocity } from '../values';\nimport { AngularVelocityUnit } from '../../utils';\n/**\n * Relative angular velocity to another reference object\n *\n * @category Position\n */\nlet RelativeAngularVelocity = class RelativeAngularVelocity extends RelativePosition {\n  constructor(referenceObject, velocity) {\n    super(referenceObject, velocity, AngularVelocityUnit.RADIAN_PER_MINUTE);\n  }\n  get velocity() {\n    return this.referenceValue;\n  }\n  set velocity(value) {\n    this.referenceValue = value;\n  }\n};\nRelativeAngularVelocity = __decorate([SerializableObject(), __metadata(\"design:paramtypes\", [Object, AngularVelocity])], RelativeAngularVelocity);\nexport { RelativeAngularVelocity };","import { __decorate, __metadata } from \"tslib\";\nimport { LengthUnit } from '../../utils';\nimport { SerializableObject, SerializableMember } from '../decorators';\nimport { RelativePosition } from './RelativePosition';\n/**\n * Relative location to another reference object in distance.\n *\n * @category Position\n */\nlet RelativeDistance = class RelativeDistance extends RelativePosition {\n  constructor(referenceObject, distance, distanceUnit) {\n    super(referenceObject, distance, LengthUnit.METER);\n    this.distanceUnit = distanceUnit;\n  }\n  /**\n   * Distance to reference object\n   *\n   * @returns {number} Distance\n   */\n  get distance() {\n    return this.referenceValue;\n  }\n  set distance(value) {\n    this.referenceValue = value;\n  }\n};\n__decorate([SerializableMember(), __metadata(\"design:type\", LengthUnit)], RelativeDistance.prototype, \"distanceUnit\", void 0);\nRelativeDistance = __decorate([SerializableObject(), __metadata(\"design:paramtypes\", [Object, Number, LengthUnit])], RelativeDistance);\nexport { RelativeDistance };","import { __decorate, __metadata } from \"tslib\";\nimport { RelativePosition } from './RelativePosition';\nimport { SerializableObject } from '../decorators';\nimport { LinearVelocity } from '../values';\nimport { LinearVelocityUnit } from '../../utils';\n/**\n * Relative linear velocity to another reference object\n *\n * @category Position\n */\nlet RelativeLinearVelocity = class RelativeLinearVelocity extends RelativePosition {\n  constructor(referenceObject, velocity) {\n    super(referenceObject, velocity, LinearVelocityUnit.METER_PER_SECOND);\n  }\n  get velocity() {\n    return this.referenceValue;\n  }\n  set velocity(value) {\n    this.referenceValue = value;\n  }\n};\nRelativeLinearVelocity = __decorate([SerializableObject(), __metadata(\"design:paramtypes\", [Object, LinearVelocity])], RelativeLinearVelocity);\nexport { RelativeLinearVelocity };","import { __decorate, __metadata } from \"tslib\";\nimport { TimeService } from '../../service/TimeService';\nimport { Unit } from '../../utils';\nimport { DataSerializer } from '../DataSerializer';\nimport { SerializableMember, SerializableObject } from '../decorators';\nimport { Accuracy } from '../values/Accuracy';\nimport { Accuracy1D } from '../values/Accuracy1D';\n/**\n * Relative position to another reference object or space.\n *\n * @category Position\n */\nlet RelativePosition = class RelativePosition {\n  constructor(referenceObject, value, unit) {\n    /**\n     * Position recording timestamp\n     */\n    this.timestamp = TimeService.now();\n    if (referenceObject !== undefined) {\n      if (referenceObject instanceof String || typeof referenceObject === 'string') {\n        this.referenceObjectUID = referenceObject;\n      } else {\n        this.referenceObjectType = referenceObject.constructor.name;\n        this.referenceObjectUID = referenceObject.uid;\n      }\n    }\n    this._defaultUnit = unit || Unit.UNKNOWN;\n    this.referenceValue = value;\n  }\n  /**\n   * Get the position probability\n   *\n   * @returns {number} Probability between 0 and 1\n   */\n  get probability() {\n    if (!this._probability) {\n      return 1 / this.accuracy.valueOf();\n    }\n    return this._probability;\n  }\n  set probability(value) {\n    if (value > 1 || value < 0) {\n      throw new Error(`${this.constructor.name} should be between 0 and 1.`);\n    }\n    this._probability = value;\n  }\n  /**\n   * Position accuracy\n   *\n   * @returns {Accuracy} Position accuracy\n   */\n  get accuracy() {\n    if (!this._accuracy) {\n      this._accuracy = new Accuracy1D(1, this._defaultUnit);\n    }\n    return this._accuracy;\n  }\n  set accuracy(value) {\n    if (!value) {\n      throw new Error(`Accuracy can not be undefined!`);\n    }\n    this.accuracy = value;\n  }\n  /**\n   * Set the accuracy of the absolute position\n   *\n   * @param {number | Accuracy} accuracy Accuracy object or number\n   * @param {Unit} [unit] Optional unit\n   * @returns {RelativePosition} instance\n   */\n  setAccuracy(accuracy, unit) {\n    if (typeof accuracy === 'number') {\n      this.accuracy = new Accuracy1D(accuracy, unit || this._defaultUnit);\n    } else {\n      this.accuracy = accuracy;\n    }\n    return this;\n  }\n  equals(position) {\n    return this.timestamp === position.timestamp;\n  }\n  /**\n   * Clone the position\n   *\n   * @returns {RelativePosition} Cloned relative position\n   */\n  clone() {\n    return DataSerializer.clone(this);\n  }\n};\n__decorate([SerializableMember({\n  index: true\n}), __metadata(\"design:type\", Number)], RelativePosition.prototype, \"timestamp\", void 0);\n__decorate([SerializableMember(), __metadata(\"design:type\", String)], RelativePosition.prototype, \"referenceObjectUID\", void 0);\n__decorate([SerializableMember(), __metadata(\"design:type\", String)], RelativePosition.prototype, \"referenceObjectType\", void 0);\n__decorate([SerializableMember(), __metadata(\"design:type\", Object)], RelativePosition.prototype, \"referenceValue\", void 0);\n__decorate([SerializableMember({\n  name: 'accuracy'\n}), __metadata(\"design:type\", Accuracy)], RelativePosition.prototype, \"_accuracy\", void 0);\n__decorate([SerializableMember({\n  name: 'probability'\n}), __metadata(\"design:type\", Number)], RelativePosition.prototype, \"_probability\", void 0);\nRelativePosition = __decorate([SerializableObject(), __metadata(\"design:paramtypes\", [Object, Object, Object])], RelativePosition);\nexport { RelativePosition };","import { __decorate, __metadata } from \"tslib\";\nimport { SerializableArrayMember, SerializableMember, SerializableObject } from '../decorators';\nimport { v4 as uuidv4 } from 'uuid';\nimport { AbsolutePosition } from './AbsolutePosition';\nimport { TimeService } from '../../service/TimeService';\nlet Trajectory = class Trajectory {\n  constructor(objectUID) {\n    this.uid = uuidv4();\n    this.positions = [];\n    this.objectUID = objectUID;\n    this.createdTimestamp = TimeService.now();\n  }\n  get trajectoryStart() {\n    if (!this.positions || this.positions.length === 0) return -1;\n    return this.positions[0].timestamp;\n  }\n  get trajectoryEnd() {\n    if (!this.positions || this.positions.length === 0) return -1;\n    return this.positions[this.positions.length - 1].timestamp;\n  }\n};\n__decorate([SerializableMember({\n  primaryKey: true\n}), __metadata(\"design:type\", String)], Trajectory.prototype, \"uid\", void 0);\n__decorate([SerializableMember({\n  index: true\n}), __metadata(\"design:type\", String)], Trajectory.prototype, \"objectUID\", void 0);\n__decorate([SerializableArrayMember(AbsolutePosition), __metadata(\"design:type\", Array)], Trajectory.prototype, \"positions\", void 0);\n__decorate([SerializableMember({\n  index: true\n}), __metadata(\"design:type\", Number)], Trajectory.prototype, \"createdTimestamp\", void 0);\nTrajectory = __decorate([SerializableObject(), __metadata(\"design:paramtypes\", [String])], Trajectory);\nexport { Trajectory };","export * from './Position';\nexport * from './RelativePosition';\nexport * from './AbsolutePosition';\nexport * from './GeographicalPosition';\nexport * from './Absolute2DPosition';\nexport * from './Absolute3DPosition';\nexport * from './RelativeAngle';\nexport * from './RelativeDistance';\nexport * from './RelativeAngularVelocity';\nexport * from './RelativeLinearVelocity';\nexport * from './Orientation';\nexport * from './Trajectory';\nexport * from './Pose';","import { __decorate, __metadata } from \"tslib\";\nimport { AccelerationUnit } from '../../utils';\nimport { SerializableObject } from '../decorators';\nimport { SensorValue } from './SensorValue';\n/**\n * Acceleration sensor value\n *\n * @category Sensor Value\n */\nlet Acceleration = class Acceleration extends SensorValue {\n  constructor(x = 0, y = 0, z = 0, unit = AccelerationUnit.METER_PER_SECOND_SQUARE) {\n    super(x, y, z, unit, AccelerationUnit.METER_PER_SECOND_SQUARE);\n  }\n};\nAcceleration = __decorate([SerializableObject(), __metadata(\"design:paramtypes\", [Object, Object, Object, Object])], Acceleration);\nexport { Acceleration };","import { __decorate, __metadata } from \"tslib\";\nimport { Vector3 } from '../../utils/math/Vector3';\nimport { SerializableObject, SerializableMember } from '../decorators';\nlet Accuracy = class Accuracy {\n  constructor(value, unit) {\n    this.value = value;\n    this._unit = unit;\n  }\n  /**\n   * Convert the value to another unit\n   *\n   * @param {Unit} unit Target unit\n   * @returns {Accuracy} Converted value\n   */\n  to(unit) {\n    if (!unit) {\n      throw new Error(`${this.constructor.name} does not have a unit to convert from!`);\n    }\n    const value = this.value;\n    if (!(value instanceof Vector3) && typeof value !== 'number') {\n      throw new Error(`${this.constructor.name} can not be converted!`);\n    }\n    const result = this.unit.convert(value, unit);\n    return new this.constructor(result, unit);\n  }\n  /**\n   * Unit this value is in\n   *\n   * @returns {Unit} Unit this value is in\n   */\n  get unit() {\n    return this._unit;\n  }\n  clone() {\n    const result = new this.constructor();\n    result.value = this.value;\n    result._unit = this._unit;\n    return result;\n  }\n};\n__decorate([SerializableMember(), __metadata(\"design:type\", Object)], Accuracy.prototype, \"value\", void 0);\n__decorate([SerializableMember({\n  name: 'unit'\n}), __metadata(\"design:type\", Object)], Accuracy.prototype, \"_unit\", void 0);\nAccuracy = __decorate([SerializableObject(), __metadata(\"design:paramtypes\", [Object, Object])], Accuracy);\nexport { Accuracy };","import { __decorate, __metadata } from \"tslib\";\nimport { SerializableObject } from '../decorators';\nimport { Accuracy } from './Accuracy';\nlet Accuracy1D = class Accuracy1D extends Accuracy {\n  constructor(value, unit) {\n    super(value, unit);\n  }\n  valueOf() {\n    return this.value.valueOf();\n  }\n  toString() {\n    return this.valueOf().toString();\n  }\n};\nAccuracy1D = __decorate([SerializableObject(), __metadata(\"design:paramtypes\", [Number, Object])], Accuracy1D);\nexport { Accuracy1D };","import { __decorate, __metadata } from \"tslib\";\nimport { Vector3 } from '../../utils/math/';\nimport { SerializableObject } from '../decorators';\nimport { Accuracy } from './Accuracy';\nlet Accuracy2D = class Accuracy2D extends Accuracy {\n  constructor(x, y, unit) {\n    super(new Vector3(), unit);\n    this.value.x = x;\n    this.value.y = y;\n  }\n  /**\n   * Convert the value to another unit\n   *\n   * @param {Unit} unit Target unit\n   * @returns {Accuracy2D} Converted value\n   */\n  to(unit) {\n    const accuracy = super.to(unit);\n    accuracy.x = this.unit.convert(this.x, unit);\n    accuracy.y = this.unit.convert(this.y, unit);\n    return accuracy;\n  }\n  valueOf() {\n    return (this.x + this.y) / 2;\n  }\n  toString() {\n    return this.valueOf().toString();\n  }\n  get x() {\n    return this.value.x;\n  }\n  set x(val) {\n    this.value.x = val;\n  }\n  get y() {\n    return this.value.y;\n  }\n  set y(val) {\n    this.value.y = val;\n  }\n};\nAccuracy2D = __decorate([SerializableObject(), __metadata(\"design:paramtypes\", [Number, Number, Object])], Accuracy2D);\nexport { Accuracy2D };","import { __decorate, __metadata } from \"tslib\";\nimport { SerializableObject } from '../decorators';\nimport { Accuracy2D } from './Accuracy2D';\nlet Accuracy3D = class Accuracy3D extends Accuracy2D {\n  constructor(x, y, z, unit) {\n    super(x, y, unit);\n    this.value.z = z;\n  }\n  /**\n   * Convert the value to another unit\n   *\n   * @param {Unit} unit Target unit\n   * @returns {Accuracy3D} Converted value\n   */\n  to(unit) {\n    const accuracy = super.to(unit);\n    accuracy.z = this.unit.convert(this.z, unit);\n    return accuracy;\n  }\n  valueOf() {\n    return (this.x + this.y + this.z) / 3;\n  }\n  get z() {\n    return this.value.z;\n  }\n  set z(val) {\n    this.value.z = val;\n  }\n};\nAccuracy3D = __decorate([SerializableObject(), __metadata(\"design:paramtypes\", [Number, Number, Number, Object])], Accuracy3D);\nexport { Accuracy3D };","import { __decorate, __metadata } from \"tslib\";\nimport { AngularVelocityUnit } from '../../utils/unit/AngularVelocityUnit';\nimport { SerializableObject } from '../decorators';\nimport { SensorValue } from './SensorValue';\n/**\n * @category Sensor Value\n */\nlet AngularVelocity = class AngularVelocity extends SensorValue {\n  constructor(x, y, z, unit = AngularVelocityUnit.RADIAN_PER_SECOND) {\n    super(x, y, z, unit, AngularVelocityUnit.RADIAN_PER_SECOND);\n  }\n  static fromArray(array, unit = AngularVelocityUnit.RADIAN_PER_SECOND) {\n    return new this(array[0], array[1], array[2], unit);\n  }\n};\nAngularVelocity = __decorate([SerializableObject(), __metadata(\"design:paramtypes\", [Number, Number, Number, Object])], AngularVelocity);\nexport { AngularVelocity };","import { __decorate, __metadata } from \"tslib\";\nimport { SensorValue } from './SensorValue';\nimport { SerializableObject } from '../decorators';\nlet Humidity = class Humidity extends SensorValue {\n  constructor(value = 0) {\n    super(value, undefined, undefined);\n  }\n  get value() {\n    return this.x;\n  }\n  set value(x) {\n    this.x = x;\n  }\n};\nHumidity = __decorate([SerializableObject(), __metadata(\"design:paramtypes\", [Object])], Humidity);\nexport { Humidity };","import { __decorate, __metadata } from \"tslib\";\nimport { SerializableObject } from '../decorators';\nimport { LinearVelocityUnit } from '../../utils';\nimport { SensorValue } from './SensorValue';\n/**\n * @category Sensor Value\n */\nlet LinearVelocity = class LinearVelocity extends SensorValue {\n  constructor(x, y, z, unit = LinearVelocityUnit.METER_PER_SECOND) {\n    super(x, y, z, unit, LinearVelocityUnit.METER_PER_SECOND);\n  }\n  static fromArray(array, unit = LinearVelocityUnit.METER_PER_SECOND) {\n    return new this(array[0], array[1], array[2], unit);\n  }\n};\nLinearVelocity = __decorate([SerializableObject(), __metadata(\"design:paramtypes\", [Number, Number, Number, Object])], LinearVelocity);\nexport { LinearVelocity };","import { __decorate, __metadata } from \"tslib\";\nimport { SerializableObject } from '../decorators';\nimport { MagnetismUnit } from '../../utils';\nimport { SensorValue } from './SensorValue';\n/**\n * @category Sensor Value\n */\nlet Magnetism = class Magnetism extends SensorValue {\n  constructor(x, y, z, unit = MagnetismUnit.MICROTESLA) {\n    super(x, y, z, unit, MagnetismUnit.MICROTESLA);\n  }\n};\nMagnetism = __decorate([SerializableObject(), __metadata(\"design:paramtypes\", [Number, Number, Number, Object])], Magnetism);\nexport { Magnetism };","import { __decorate, __metadata } from \"tslib\";\nimport { SensorValue } from './SensorValue';\nimport { SerializableObject } from '../decorators';\nimport { PressureUnit } from '../../utils/unit';\nlet Pressure = class Pressure extends SensorValue {\n  constructor(value = 0, unit = PressureUnit.PASCAL) {\n    super(value, undefined, undefined, unit, PressureUnit.PASCAL);\n  }\n  get value() {\n    return this.x;\n  }\n  set value(x) {\n    this.x = x;\n  }\n};\nPressure = __decorate([SerializableObject(), __metadata(\"design:paramtypes\", [Object, Object])], Pressure);\nexport { Pressure };","import { __decorate, __metadata } from \"tslib\";\nimport { TimeService } from '../../service/TimeService';\nimport { Unit } from '../../utils';\nimport { Vector3 } from '../../utils/math';\nimport { SerializableMember, SerializableObject, NumberType } from '../decorators';\nimport { Accuracy } from './Accuracy';\nimport { Accuracy1D } from './Accuracy1D';\n/**\n * 3D vector sensor value with accuracy and timestamp.\n */\nlet SensorValue = class SensorValue extends Vector3 {\n  constructor(x, y, z, unit, defaultUnit, accuracy) {\n    var _a;\n    if (unit && defaultUnit) {\n      super(unit.convert(x ? x : 0, defaultUnit), unit.convert(y ? y : 0, defaultUnit), unit.convert(z ? z : 0, defaultUnit));\n      this._defaultUnit = defaultUnit;\n    } else {\n      super(x, y, z);\n    }\n    this.unit = (_a = defaultUnit !== null && defaultUnit !== void 0 ? defaultUnit : unit) !== null && _a !== void 0 ? _a : Unit.UNKNOWN;\n    this.timestamp = TimeService.now();\n    this.accuracy = accuracy || new Accuracy1D(1, this._defaultUnit || Unit.UNKNOWN);\n  }\n  /**\n   * Set the accuracy of the absolute position\n   *\n   * @param {number | Accuracy} accuracy Accuracy object or number\n   * @returns {SensorValue} instance\n   */\n  setAccuracy(accuracy) {\n    if (typeof accuracy === 'number') {\n      this.accuracy = new Accuracy1D(accuracy, this._defaultUnit);\n    } else {\n      this.accuracy = accuracy;\n    }\n    return this;\n  }\n  clone() {\n    const vector = super.clone();\n    vector.accuracy = this.accuracy;\n    vector.timestamp = this.timestamp;\n    return vector;\n  }\n};\n__decorate([SerializableMember({\n  isRequired: false,\n  numberType: NumberType.LONG\n}), __metadata(\"design:type\", Number)], SensorValue.prototype, \"timestamp\", void 0);\n__decorate([SerializableMember({\n  isRequired: false\n}), __metadata(\"design:type\", Accuracy)], SensorValue.prototype, \"accuracy\", void 0);\n__decorate([SerializableMember(), __metadata(\"design:type\", Object)], SensorValue.prototype, \"unit\", void 0);\nSensorValue = __decorate([SerializableObject(), __metadata(\"design:paramtypes\", [Number, Number, Number, Unit, Object, Accuracy])], SensorValue);\nexport { SensorValue };","import { __decorate, __metadata } from \"tslib\";\nimport { TemperatureUnit } from '../../utils/unit';\nimport { SerializableObject } from '../decorators';\nimport { SensorValue } from './SensorValue';\n/**\n * @category Sensor Value\n */\nlet Temperature = class Temperature extends SensorValue {\n  constructor(value = 0, unit = TemperatureUnit.CELCIUS) {\n    super(value, undefined, undefined, unit, TemperatureUnit.CELCIUS);\n  }\n  get value() {\n    return this.x;\n  }\n  set value(x) {\n    this.x = x;\n  }\n};\nTemperature = __decorate([SerializableObject(), __metadata(\"design:paramtypes\", [Object, Object])], Temperature);\nexport { Temperature };","import { __decorate, __metadata } from \"tslib\";\nimport { SerializableObject, SerializableMember } from '../decorators';\nimport { AngularVelocity } from './AngularVelocity';\nimport { LinearVelocity } from './LinearVelocity';\n/**\n * Velocity of the object at the recorded position\n *\n * @category Sensor Value\n */\nlet Velocity = class Velocity {\n  constructor(linear, angular) {\n    this.linear = linear;\n    this.angular = angular;\n  }\n  /**\n   * Clone the velocity\n   *\n   * @returns {Velocity} Cloned velocity object\n   */\n  clone() {\n    return new this.constructor(this.linear ? this.linear.clone() : undefined, this.angular ? this.angular.clone() : undefined);\n  }\n};\n__decorate([SerializableMember(), __metadata(\"design:type\", LinearVelocity)], Velocity.prototype, \"linear\", void 0);\n__decorate([SerializableMember(), __metadata(\"design:type\", AngularVelocity)], Velocity.prototype, \"angular\", void 0);\nVelocity = __decorate([SerializableObject(), __metadata(\"design:paramtypes\", [LinearVelocity, AngularVelocity])], Velocity);\nexport { Velocity };","export * from './Velocity';\nexport * from './AngularVelocity';\nexport * from './LinearVelocity';\nexport * from './Acceleration';\nexport * from './Magnetism';\nexport * from './SensorValue';\nexport * from './Temperature';\nexport * from './Humidity';\nexport * from './Pressure';\nexport * from './Accuracy';\nexport * from './Accuracy1D';\nexport * from './Accuracy2D';\nexport * from './Accuracy3D';","import { PushError } from './events';\nimport { EventEmitter } from 'events';\n/**\n * Edge provides the connection between two nodes\n * Nodes have access to inlet and outlet interfaces that only\n * allow functionality needed for the type of port.\n *\n * As a part of the graph that can not be modified, this object\n * has the ability to perform error handling.\n *\n * @category Graph\n */\nexport class Edge extends EventEmitter {\n  constructor(inputNode, outputNode) {\n    super();\n    this.inputNode = inputNode;\n    this.outputNode = outputNode;\n    // Register default push and pull handling\n    this.on('push', this._onPush.bind(this));\n    this.on('pull', this._onPull.bind(this));\n  }\n  _onPush(data, options) {\n    return this.outputNode.push(data, options);\n  }\n  _onPull(options) {\n    return this.inputNode.pull(options);\n  }\n  /**\n   * Push data to the output node\n   *\n   * @param {DataFrame | DataFrame[]} data Data frame to push\n   * @param {PushOptions} [options] Push options\n   * @returns {Promise<void>} Push promise\n   */\n  push(data, options = {}) {\n    return new Promise(resolve => {\n      const newOptions = Object.assign(Object.assign({}, options), {\n        lastNode: this.inputNode.uid\n      });\n      const pushListeners = this.listeners('push');\n      Promise.all(pushListeners.map(listener => listener(data, newOptions))).then(() => {\n        resolve();\n      }).catch(ex => {\n        // Error handling is done in the edge\n        if (Array.isArray(data)) {\n          data.forEach(frame => {\n            this.inputNode.emit('error', new PushError(frame.uid, this.outputNode.uid, ex));\n          });\n        } else {\n          this.inputNode.emit('error', new PushError(data.uid, this.outputNode.uid, ex));\n        }\n      });\n    });\n  }\n  /**\n   * Pull data from the input node\n   *\n   * @param {PullOptions} [options] Pull options\n   * @returns {Promise<void>} Pull promise\n   */\n  pull(options) {\n    return new Promise((resolve, reject) => {\n      const pullListeners = this.listeners('pull');\n      Promise.all(pullListeners.map(listener => listener(options))).then(() => {\n        resolve();\n      }).catch(reject);\n    });\n  }\n  emit(name, event) {\n    return this.inputNode.emit(name, event);\n  }\n  on(name, listener) {\n    this.removeAllListeners(name);\n    return super.on(name, listener);\n  }\n}","import { __decorate, __metadata } from \"tslib\";\nimport { v4 as uuidv4 } from 'uuid';\nimport { SerializableMember, SerializableObject } from '../../data/decorators';\nimport { AsyncEventEmitter } from '../../_internal/AsyncEventEmitter';\nlet GraphNode = class GraphNode extends AsyncEventEmitter {\n  constructor() {\n    super();\n    /**\n     * Unique identifier of node.\n     */\n    this.uid = uuidv4();\n    this._ready = false;\n    this._available = true;\n    this.prependOnceListener('ready', () => {\n      this._ready = true;\n    });\n    this.on('error', this._onError.bind(this));\n    this.on('completed', this._onCompleted.bind(this));\n  }\n  /**\n   * Graph logger\n   *\n   * @param {string} level Logging level\n   * @param {string} message Message\n   * @param {any} data Data to include in log\n   */\n  logger(level, message, data) {\n    if (typeof message === 'object') {\n      this.graph.logger(level, JSON.stringify(message));\n    } else {\n      this.graph.logger(level, message, data);\n    }\n  }\n  isReady() {\n    return this._ready;\n  }\n  /**\n   * Check if the node is available for accepting push requests\n   *\n   * @returns {boolean} Is the node available to push\n   */\n  isAvailable() {\n    return this._available;\n  }\n  /**\n   * Get the outgoing edges\n   *\n   * @returns {Array<Outlet<DataFrame>>} Outgoing edges\n   */\n  get outlets() {\n    return this.graph.edges.filter(edge => edge.inputNode === this);\n  }\n  /**\n   * Get the incoming edges\n   *\n   * @returns {Array<Inlet<DataFrame>>} Incoming edges\n   */\n  get inlets() {\n    return this.graph.edges.filter(edge => edge.outputNode === this);\n  }\n  emit(name, ...args) {\n    return super.emit(name, ...args);\n  }\n  on(name, listener) {\n    return super.on(name, listener);\n  }\n  once(name, listener) {\n    return super.once(name, listener);\n  }\n  /**\n   * Send a pull request to the node\n   *\n   * @param {PullOptions} [options] Pull options\n   * @returns {Promise<void>} Pull promise\n   */\n  pull(options) {\n    return new Promise((resolve, reject) => {\n      const callbackPromises = [];\n      this.listeners('pull').forEach(callback => {\n        callbackPromises.push(callback(options));\n      });\n      if (callbackPromises.length === 0) {\n        this.inlets.forEach(inlet => {\n          callbackPromises.push(inlet.pull(options));\n        });\n      }\n      Promise.all(callbackPromises).then(() => {\n        resolve();\n      }).catch(reject);\n    });\n  }\n  /**\n   * Push data to the node\n   *\n   * @param {DataFrame | DataFrame[]} data Data frame to push\n   * @param {PushOptions} [options] Push options\n   * @returns {Promise<void>} Push promise\n   */\n  push(data, options = {}) {\n    return new Promise((resolve, reject) => {\n      if (data === null || data === undefined) {\n        return reject(new Error('Node received null data frame!'));\n      }\n      const listeners = this.listeners('push');\n      if (listeners.length === 0) {\n        // Forward push, resolve before outlets resolve\n        this.outlets.forEach(outlet => outlet.push(data, options));\n        resolve();\n      } else {\n        this._available = false;\n        Promise.all(listeners.map(callback => callback(data, options))).then(() => {\n          this._available = true;\n          this.emit('available');\n          resolve();\n        }).catch(reject);\n      }\n    });\n  }\n  /**\n   * Promise once the node is available\n   *\n   * @returns {Promise} Promise when the node is available\n   */\n  onceAvailable() {\n    return new Promise(resolve => {\n      if (this.isAvailable()) {\n        resolve();\n      } else {\n        this.once('available', () => {\n          resolve();\n        });\n      }\n    });\n  }\n  /**\n   * Promise once the frame is completed\n   *\n   * @param {string} frameUID Frame UID\n   * @returns {Promise} Promise when the frame is completed\n   */\n  onceCompleted(frameUID) {\n    return new Promise((resolve, reject) => {\n      const completedListener = function (event) {\n        if (event.frameUID === frameUID) {\n          this.removeListener('completed', completedListener);\n          this.removeListener('error', completedListener);\n          if (event.error) {\n            reject(event);\n          } else {\n            resolve(event);\n          }\n        }\n      };\n      this.on('completed', completedListener.bind(this));\n      this.on('error', completedListener.bind(this));\n    });\n  }\n  _onError(error) {\n    this.inlets.forEach(inlet => inlet.emit('error', error));\n  }\n  _onCompleted(event) {\n    this.inlets.forEach(inlet => inlet.emit('completed', event));\n  }\n};\n__decorate([SerializableMember(), __metadata(\"design:type\", String)], GraphNode.prototype, \"name\", void 0);\n__decorate([SerializableMember(), __metadata(\"design:type\", String)], GraphNode.prototype, \"uid\", void 0);\nGraphNode = __decorate([SerializableObject(), __metadata(\"design:paramtypes\", [])], GraphNode);\nexport { GraphNode };","import { __decorate, __metadata } from \"tslib\";\nimport { GraphNode } from '../GraphNode';\nimport { BroadcastNode } from '../../../nodes/shapes/BroadcastNode';\nimport { Edge } from '../../Edge';\nimport { Node } from '../../../Node';\nimport { SerializableMapMember, SerializableMember, SerializableObject } from '../../../data/decorators';\n/**\n * @category Graph\n */\nlet GraphShape = class GraphShape extends Node {\n  constructor() {\n    super();\n    this._nodes = new Map();\n    this._edges = new Map();\n    this.internalSource = new BroadcastNode();\n    this.internalSink = new BroadcastNode();\n    /**\n     * Graph logger\n     *\n     * @returns {(level: string, message: string, data?: any) => void} logger function\n     */\n    this.logger = () => undefined;\n    // Internal input and output nodes\n    this.addNode(this.internalSource);\n    this.addNode(this.internalSink);\n    // Graph building and destroying\n    this.once('build', this._onBuild.bind(this));\n    this.once('destroy', this._onDestroy.bind(this));\n    // Error handling\n    this.removeAllListeners('error');\n    this.internalSource.on('error', this.onError.bind(this));\n    this.internalSink.on('error', this.onError.bind(this));\n    // Completed event\n    this.removeAllListeners('completed');\n    this.internalSource.on('completed', this.onCompleted.bind(this));\n    this.internalSink.on('completed', this.onCompleted.bind(this));\n  }\n  _onDestroy() {\n    this.nodes.forEach(node => {\n      node.emit('destroy');\n    });\n  }\n  _onBuild(_) {\n    return new Promise((resolve, reject) => {\n      Promise.all(this.nodes.map(node => node.emitAsync('build', _))).then(() => {\n        this.emit('ready');\n        resolve();\n      }).catch(ex => {\n        reject(ex);\n      });\n    });\n  }\n  get edges() {\n    return this._edges ? Array.from(this._edges.values()) : [];\n  }\n  set edges(edges) {\n    edges.forEach(this.addEdge);\n  }\n  get nodes() {\n    return this._nodes ? Array.from(this._nodes.values()) : [];\n  }\n  set nodes(nodes) {\n    nodes.forEach(this.addNode);\n  }\n  findNodeByUID(uid) {\n    return this._nodes.get(uid);\n  }\n  findNodeByName(name) {\n    let result;\n    this._nodes.forEach(node => {\n      if (node.name === name) {\n        result = node;\n        return;\n      }\n    });\n    return result;\n  }\n  addNode(node) {\n    node.graph = this.graph === undefined ? this : this.model;\n    this._nodes.set(node.uid, node);\n  }\n  addEdge(edge) {\n    this._edges.set(edge.inputNode.uid + edge.outputNode.uid, edge);\n  }\n  deleteEdge(edge) {\n    this._edges.delete(edge.inputNode.uid + edge.outputNode.uid);\n  }\n  deleteNode(node) {\n    this._nodes.delete(node.uid);\n  }\n  /**\n   * Find an edge by the identifiers of its inlet and outlet\n   *\n   * @param {string} inlet Node uid of inlet\n   * @param {string} outlet Node uid of outlet\n   * @returns {Edge<any>} Edge\n   */\n  findEdge(inlet, outlet) {\n    return this._edges.get(inlet + outlet);\n  }\n  /**\n   * Send a pull request to the graph\n   *\n   * @param {PullOptions} [options] Pull options\n   * @returns {Promise<void>} Pull promise\n   */\n  pull(options) {\n    return this.internalSink.pull(options);\n  }\n  /**\n   * Push data to the graph\n   *\n   * @param {DataFrame | DataFrame[]} frame Data frame to push\n   * @param {PushOptions} [options] Push options\n   * @returns {Promise<void>} Push promise\n   */\n  push(frame, options) {\n    return this.internalSource.push(frame, options);\n  }\n  onError(event) {\n    // Do not emit if no listeners attached\n    // Event emitter will throw an uncaught exception\n    if (this.listenerCount('error') > 0) this.emit('error', event);\n  }\n  onCompleted(event) {\n    this.emit('completed', event);\n  }\n};\n__decorate([SerializableMapMember(String, GraphNode, {\n  name: 'nodes'\n}), __metadata(\"design:type\", Map)], GraphShape.prototype, \"_nodes\", void 0);\n__decorate([SerializableMapMember(String, Edge, {\n  serializer: edges => {\n    return Array.from(edges.values()).map(edge => ({\n      input: edge.inputNode.uid,\n      output: edge.outputNode.uid\n    }));\n  },\n  name: 'edges'\n}), __metadata(\"design:type\", Map)], GraphShape.prototype, \"_edges\", void 0);\n__decorate([SerializableMember({\n  serializer: node => node.uid,\n  deserializer: () => {\n    return undefined;\n  }\n}), __metadata(\"design:type\", GraphNode)], GraphShape.prototype, \"internalSource\", void 0);\n__decorate([SerializableMember({\n  serializer: node => node.uid,\n  deserializer: () => {\n    return undefined;\n  }\n}), __metadata(\"design:type\", GraphNode)], GraphShape.prototype, \"internalSink\", void 0);\nGraphShape = __decorate([SerializableObject({\n  initializer: (sourceObject, raw) => {\n    raw.edges.forEach(edge => {\n      sourceObject._edges.set(edge.input + edge.output, new Edge(sourceObject._nodes.get(edge.input), sourceObject._nodes.get(edge.output)));\n    });\n    return sourceObject;\n  }\n}), __metadata(\"design:paramtypes\", [])], GraphShape);\nexport { GraphShape };","export class GraphValidator {\n  static validate(graph) {\n    this.validateNodes(graph);\n    this.validateEdges(graph);\n  }\n  static _validateInternalNode(graph, node) {\n    if (node.outlets.length === 0 && node.inlets.length === 0) {\n      graph.deleteNode(node);\n    } else if (!graph.findNodeByUID(node.uid)) {\n      throw new Error(`Internal node ${node.uid} (${node.name}) is not connected to the graph!`);\n    }\n  }\n  static validateNodes(graph) {\n    GraphValidator._validateInternalNode(graph, graph.internalSource);\n    GraphValidator._validateInternalNode(graph, graph.internalSink);\n    graph.nodes.forEach(node => {\n      if (node.graph === undefined) {\n        throw new Error(`Node ${node.uid} (${node.name}) does not have a graph set!`);\n      }\n      if (node.inlets.length === 0 && node.outlets.length === 0) {\n        throw new Error(`Node ${node.uid} (${node.name}) is not connected to the graph!`);\n      }\n    });\n  }\n  static validateEdges(graph) {\n    graph.edges.forEach(edge => {\n      if (!graph.findNodeByUID(edge.inputNode.uid)) {\n        throw new Error(`Node ${edge.inputNode.uid} (${edge.inputNode.name}) is used in an edge but not added to the graph!`);\n      } else if (!graph.findNodeByUID(edge.outputNode.uid)) {\n        throw new Error(`Node ${edge.outputNode.uid} (${edge.outputNode.name}) is used in an edge but not added to the graph!`);\n      }\n    });\n  }\n}","import { __decorate, __metadata } from \"tslib\";\nimport { ReferenceSpace } from '../../../data/object';\nimport { Service } from '../../../service/Service';\nimport { DataService } from '../../../service/DataService';\nimport { GraphShape } from './GraphShape';\nimport { ServiceProxy } from '../../../service/_internal/ServiceProxy';\nimport { SerializableMapMember, SerializableMember, SerializableObject } from '../../../data/decorators';\nimport { DataServiceProxy } from '../../../service/_internal';\n/**\n * [[Model]] implementation\n */\nlet ModelGraph = class ModelGraph extends GraphShape {\n  /**\n   * Create a new OpenHPS model\n   *\n   * @param {string} name Model name\n   */\n  constructor(name = 'model') {\n    super();\n    this._services = new Map();\n    this._dataServices = new Map();\n    this.name = name;\n    this.referenceSpace = new ReferenceSpace(undefined);\n    this.removeAllListeners('build');\n    this.removeAllListeners('destroy');\n    this.once('build', this._onModelBuild.bind(this));\n    this.once('destroy', this._onModelDestroy.bind(this));\n  }\n  _onModelBuild(_) {\n    return new Promise((resolve, reject) => {\n      this.emit('prebuild', _);\n      // First resolve the building of services\n      this._buildServices().then(() => {\n        for (const service of this.findAllServices()) {\n          if (!service.isReady()) {\n            service.emit('ready');\n          }\n        }\n        // Build nodes\n        return this._buildNodes(_);\n      }).then(() => {\n        for (const node of this.nodes) {\n          if (!node.isReady()) {\n            node.emit('ready');\n          }\n        }\n        this.emit('ready');\n        this.emit('postbuild', this);\n        resolve();\n      }).catch(reject);\n    });\n  }\n  _buildServices() {\n    return new Promise((resolve, reject) => {\n      const buildPromises = [];\n      this._services.forEach(service => {\n        if (!service.isReady()) {\n          buildPromises.push(service.emitAsync('build'));\n        }\n      });\n      this._dataServices.forEach(service => {\n        if (!service.isReady()) {\n          buildPromises.push(service.emitAsync('build'));\n        }\n      });\n      Promise.all(buildPromises).then(() => resolve()).catch(reject);\n    });\n  }\n  _buildNodes(_) {\n    return new Promise((resolve, reject) => {\n      const buildPromises = [];\n      this.nodes.forEach(node => {\n        if (!node.isReady()) {\n          buildPromises.push(node.emitAsync('build', _));\n        }\n      });\n      Promise.all(buildPromises).then(() => resolve()).catch(reject);\n    });\n  }\n  _onModelDestroy(_) {\n    return new Promise((resolve, reject) => {\n      const destroyPromises = [];\n      this._services.forEach(service => {\n        destroyPromises.push(service.emitAsync('destroy', _));\n      });\n      this._dataServices.forEach(service => {\n        destroyPromises.push(service.emitAsync('destroy', _));\n      });\n      this.nodes.forEach(node => {\n        destroyPromises.push(node.emitAsync('destroy', _));\n      });\n      Promise.all(destroyPromises).then(() => {\n        resolve();\n      }).catch(reject);\n    });\n  }\n  findService(q) {\n    if (!q) {\n      return undefined;\n    } else if (typeof q === 'string') {\n      return this._services.get(q);\n    } else {\n      return Array.from(this._services.values()).filter(s => s instanceof q)[0];\n    }\n  }\n  findDataService(q) {\n    let result;\n    if (q === undefined) {\n      result = undefined;\n    } else if (typeof q === 'string') {\n      // Find by name\n      result = this._findDataServiceByUID(q);\n    } else if (q.prototype instanceof DataService) {\n      // Find by data service class\n      result = this.findAllServices(q)[0];\n    } else if (q instanceof Function) {\n      // Find by constructor\n      result = this.findAllDataServices(q)[0];\n    } else {\n      // Find by instance\n      result = this.findDataService(q.constructor);\n    }\n    return result;\n  }\n  _findDataServiceByUID(uid) {\n    return Array.from(this._dataServices.values()).filter(s => s.uid === uid)[0];\n  }\n  /**\n   * Find all services and data services\n   *\n   * @param {typeof Service} [q] Service class\n   * @returns {Service[]} Array of all services\n   */\n  findAllServices(q) {\n    if (q !== undefined) {\n      return this.findAllServices().filter(s => s instanceof q) || [];\n    } else {\n      return Array.from(this._services.values()).concat(Array.from(this._dataServices.values())) || [];\n    }\n  }\n  /**\n   * Find all data services by data type\n   *\n   * @param {typeof Service} [q] data type class\n   * @returns {Service[]} Array of all services\n   */\n  findAllDataServices(q) {\n    if (q !== undefined) {\n      return this.findAllDataServices().map(s => [s, ...this._instanceofPriority(q, s['target'].dataType)]).filter(s => s[1]).sort((a, b) => a[2] === b[2] ? b[0].priority - a[0].priority : a[2] - b[2]).map(s => s[0]) || [];\n    } else {\n      return Array.from(this._dataServices.values()) || [];\n    }\n  }\n  _instanceofPriority(obj, constr) {\n    if (obj === constr) {\n      return [true, 0];\n    }\n    let level = 1;\n    while (obj = Object.getPrototypeOf(obj)) {\n      if (obj === constr) {\n        return [true, level];\n      }\n      level++;\n    }\n    return [false, undefined];\n  }\n  /**\n   * Add service to model\n   *\n   * @param {Service} service Service to add\n   * @param {ProxyHandler} [proxy] Proxy handler\n   */\n  addService(service, proxy) {\n    service.model = this.graph === undefined ? this : this.model;\n    if (service instanceof DataService) {\n      // Data service\n      this._dataServices.set(service.uid, new Proxy(service, proxy || new DataServiceProxy()));\n    } else {\n      // Normal service\n      this._services.set(service.uid, new Proxy(service, proxy || new ServiceProxy()));\n    }\n  }\n  push(frame, options) {\n    return new Promise((resolve, reject) => {\n      const servicePromises = [];\n      // Merge the changes in the frame service\n      const frameService = this.findDataService(frame.constructor.name);\n      if (frameService) {\n        if (Array.isArray(frame)) {\n          frame.forEach(f => {\n            // Update the frame\n            servicePromises.push(frameService.insert(f.uid, frame));\n          });\n        } else {\n          // Update the frame\n          servicePromises.push(frameService.insert(frame.uid, frame));\n        }\n      }\n      Promise.all(servicePromises).then(() => this.internalSource.push(frame, options)).then(() => {\n        resolve();\n      }).catch(reject);\n    });\n  }\n  destroy() {\n    return this.emitAsync('destroy');\n  }\n};\n__decorate([SerializableMapMember(String, Service, {\n  name: 'services'\n}), __metadata(\"design:type\", Map)], ModelGraph.prototype, \"_services\", void 0);\n__decorate([SerializableMapMember(String, DataService, {\n  name: 'dataServices'\n}), __metadata(\"design:type\", Map)], ModelGraph.prototype, \"_dataServices\", void 0);\n__decorate([SerializableMember(), __metadata(\"design:type\", ReferenceSpace)], ModelGraph.prototype, \"referenceSpace\", void 0);\nModelGraph = __decorate([SerializableObject(), __metadata(\"design:paramtypes\", [Object])], ModelGraph);\nexport { ModelGraph };","import { TimeUnit } from '../../utils';\nimport { GraphShape } from '../_internal/implementations/GraphShape';\nimport { PlaceholderNode } from '../../nodes/_internal/PlaceholderNode';\nimport { SourceNode } from '../../nodes/SourceNode';\nimport { Edge } from '../Edge';\nimport { GraphValidator } from '../_internal/implementations';\n/**\n * Graph builder\n *\n * @category Graph\n */\nexport class GraphBuilder {\n  constructor(graph = new GraphShape()) {\n    this.graph = graph;\n    this.graph.name = 'graph';\n  }\n  static create() {\n    return new GraphBuilder();\n  }\n  on(name, listener) {\n    this.graph.once(name, listener);\n    return this;\n  }\n  from(...nodes) {\n    const selectedNodes = [];\n    nodes.forEach(node => {\n      if (node === undefined) {\n        throw new Error('Undefined node was provided as a source!');\n      } else if (typeof node === 'string') {\n        let nodeObject = this.graph.findNodeByUID(node) || this.graph.findNodeByName(node);\n        if (nodeObject === undefined) {\n          // Add a placeholder\n          nodeObject = new PlaceholderNode(node);\n        }\n        this.graph.addNode(nodeObject);\n        selectedNodes.push(nodeObject);\n      } else {\n        this.graph.addNode(node);\n        if (node instanceof SourceNode) {\n          this.graph.addEdge(new Edge(this.graph.internalSource, node));\n        }\n        selectedNodes.push(node);\n      }\n    });\n    return new GraphShapeBuilder(this, this.graph, selectedNodes.length === 0 ? [this.graph.internalSource] : selectedNodes);\n  }\n  addNode(node) {\n    this.graph.addNode(node);\n    return this;\n  }\n  addEdge(edge) {\n    this.graph.addEdge(edge);\n    return this;\n  }\n  deleteEdge(edge) {\n    this.graph.deleteEdge(edge);\n    return this;\n  }\n  deleteNode(node) {\n    this.graph.deleteNode(node);\n    return this;\n  }\n  /**\n   * Add graph shape to graph\n   *\n   * @param {GraphBuilder | GraphShape} shape Graph builder or abstract graph\n   * @returns {GraphBuilder} Current graph builder instance\n   */\n  addShape(shape) {\n    let graph;\n    if (shape instanceof GraphBuilder) {\n      graph = shape.graph;\n    } else {\n      graph = shape;\n    }\n    // Add the graph node and edges\n    graph.nodes.forEach(node => {\n      // Check if the node is a placeholder\n      if (node instanceof PlaceholderNode) {\n        // Try to find a node with the same uid/name as the placeholder node\n        const existingNode = this.graph.findNodeByUID(node.name) || this.graph.findNodeByName(node.name);\n        if (existingNode) {\n          // Edit the edges connected to this placeholder\n          const outputEdges = graph.edges.filter(edge => edge.inputNode === node);\n          const inputEdges = graph.edges.filter(edge => edge.outputNode === node);\n          outputEdges.map(edge => edge.inputNode = existingNode);\n          inputEdges.map(edge => edge.outputNode = existingNode);\n          this.addNode(existingNode);\n        } else {\n          // Add the node as a placeholder\n          this.addNode(node);\n        }\n      } else {\n        this.addNode(node);\n      }\n    });\n    graph.edges.forEach(edge => {\n      this.addEdge(edge);\n    });\n    // Connect internal and external output to shape\n    this.graph.addEdge(new Edge(this.graph.internalSource, graph.internalSource));\n    this.graph.addEdge(new Edge(graph.internalSink, this.graph.internalSink));\n    return this;\n  }\n  build() {\n    return new Promise((resolve, reject) => {\n      GraphValidator.validate(this.graph);\n      this.graph.once('ready', () => {\n        resolve(this.graph);\n      });\n      this.graph.emitAsync('build', this).catch(ex => {\n        // Destroy model\n        this.graph.emit('destroy');\n        reject(ex);\n      });\n    });\n  }\n}\nexport class GraphShapeBuilder {\n  constructor(graphBuilder, graph, nodes) {\n    this.graphBuilder = graphBuilder;\n    this.previousNodes = nodes;\n    this.graph = graph;\n  }\n  viaGraph(graph) {\n    // Add graph as node\n    graph.nodes.forEach(node => {\n      node.graph = this.graph;\n      this.graph.addNode(node);\n    });\n    graph.edges.forEach(edge => {\n      this.graph.addEdge(edge);\n    });\n    this._insertNode(graph.internalSource);\n    return graph.internalSink;\n  }\n  via(...nodes) {\n    const selectedNodes = [];\n    nodes.forEach(node => {\n      if (node === undefined) {\n        throw new Error('Undefined node was provided!');\n      } else if (node instanceof GraphBuilder) {\n        selectedNodes.push(this.viaGraph(node.graph));\n      } else if (node instanceof GraphShape) {\n        selectedNodes.push(this.viaGraph(node));\n      } else {\n        let nodeObject;\n        if (typeof node === 'string') {\n          nodeObject = this.graph.findNodeByUID(node) || this.graph.findNodeByName(node);\n          if (nodeObject === undefined) {\n            // Add a placeholder\n            nodeObject = new PlaceholderNode(node);\n          }\n        } else {\n          nodeObject = node;\n        }\n        this.graph.addNode(nodeObject);\n        this._insertNode(nodeObject);\n        selectedNodes.push(nodeObject);\n      }\n    });\n    this.previousNodes = selectedNodes;\n    return this;\n  }\n  /**\n   * Insert a new node in the existing graph\n   *\n   * @param {Node} node Node to insert\n   */\n  _insertNode(node) {\n    this.previousNodes.forEach(prevNode => {\n      this.graph.addEdge(new Edge(prevNode, node));\n    });\n  }\n  static registerShape(key, fn) {\n    GraphShapeBuilder.shapes.set(key, fn);\n  }\n  chunk(size, timeout, timeoutUnit) {\n    return this.via(GraphShapeBuilder.shapes.get('chunk')(size, timeout, timeoutUnit));\n  }\n  flatten() {\n    return this.via(GraphShapeBuilder.shapes.get('flatten')());\n  }\n  filter(filterFn) {\n    return this.via(GraphShapeBuilder.shapes.get('filter')(filterFn));\n  }\n  /**\n   * Filter objects inside frames\n   *\n   * @param {Function} filterFn Filter function (true to keep, false to remove)\n   * @returns {GraphShapeBuilder} Current graph builder instance\n   */\n  filterObjects(filterFn) {\n    return this.via(GraphShapeBuilder.shapes.get('filterObjects')(filterFn));\n  }\n  /**\n   * Merge objects\n   *\n   * @param {Function} by Merge key\n   * @param {number} timeout Timeout\n   * @param {TimeUnit} timeoutUnit Timeout unit\n   * @returns {GraphShapeBuilder} Current graph shape builder\n   */\n  merge(by = () => true, timeout = 100, timeoutUnit = TimeUnit.MILLISECOND) {\n    return this.via(GraphShapeBuilder.shapes.get('merge')(by, timeout, timeoutUnit));\n  }\n  debounce(timeout = 100, timeoutUnit = TimeUnit.MILLISECOND) {\n    return this.via(GraphShapeBuilder.shapes.get('debounce')(timeout, timeoutUnit));\n  }\n  delay(timeout = 100, timeoutUnit = TimeUnit.MILLISECOND) {\n    return this.via(GraphShapeBuilder.shapes.get('delay')(timeout, timeoutUnit));\n  }\n  /**\n   * Clone frames\n   *\n   * @returns {GraphShapeBuilder} Current graph shape builder\n   */\n  clone() {\n    return this.via(GraphShapeBuilder.shapes.get('clone')());\n  }\n  /**\n   * Convert positions of all objects to a certain reference space\n   *\n   * @param {ReferenceSpace | string} referenceSpace Reference space to convert to\n   * @returns {GraphShapeBuilder} Current graph shape builder\n   */\n  convertToSpace(referenceSpace) {\n    return this.via(GraphShapeBuilder.shapes.get('convertToSpace')(referenceSpace));\n  }\n  /**\n   * Convert positions of all objects from a certain reference space\n   *\n   * @param {ReferenceSpace | string} referenceSpace Reference space to convert from\n   * @returns {GraphShapeBuilder} Current graph shape builder\n   */\n  convertFromSpace(referenceSpace) {\n    return this.via(GraphShapeBuilder.shapes.get('convertFromSpace')(referenceSpace));\n  }\n  /**\n   * Buffer pushed objects\n   *\n   * @returns {GraphShapeBuilder} Current graph shape builder\n   */\n  buffer() {\n    return this.via(GraphShapeBuilder.shapes.get('buffer')());\n  }\n  /**\n   * Storage as sink node\n   *\n   * @returns {GraphBuilder} Graph builder\n   */\n  store() {\n    return this.to(GraphShapeBuilder.shapes.get('store')());\n  }\n  to(...nodes) {\n    if (nodes.length !== 0) {\n      const selectedNodes = [];\n      nodes.forEach(node => {\n        let nodeObject;\n        if (node === undefined) {\n          throw new Error('Undefined node was provided as a sink!');\n        } else if (typeof node === 'string') {\n          nodeObject = this.graph.findNodeByUID(node) || this.graph.findNodeByName(node);\n          if (nodeObject === undefined) {\n            // Add a placeholder\n            nodeObject = new PlaceholderNode(node);\n          }\n        } else {\n          nodeObject = node;\n        }\n        this.graph.addNode(nodeObject);\n        this._insertNode(nodeObject);\n        this.graph.addEdge(new Edge(nodeObject, this.graph.internalSink));\n        selectedNodes.push(nodeObject);\n      });\n      this.previousNodes = selectedNodes;\n    } else {\n      this._insertNode(this.graph.internalSink);\n    }\n    return this.graphBuilder;\n  }\n}\nGraphShapeBuilder.shapes = new Map();","import '../_internal/GraphShapeRegistration';\nexport * from './GraphBuilder';","/**\n * Push error\n *\n * @category Graph\n */\nexport class PushError extends Error {\n  constructor(frameUID, nodeUID, error) {\n    super();\n    this.frameUID = frameUID;\n    this.nodeUID = nodeUID;\n    this.name = error.name;\n    this.message = error.message;\n    this.stack = error.stack;\n  }\n}","export * from './PushCompletedEvent';\nexport * from './PushError';\nexport * from './PushEvent';","export * from './options';\nexport * from './builders';\nexport * from './events';\nexport * from './Edge';\nexport * from './Inlet';\nexport * from './Outlet';\nexport * from './Graph';","import 'reflect-metadata';\nexport * from './graph';\nexport * from './Model';\nexport * from './utils';\nexport * from './Node';\nexport * from './data';\nexport * from './service';\nexport * from './ModelBuilder';\nexport * from './nodes';\nexport * from './worker';\nexport * from './ModelSerializer';","import { Node } from '../Node';\n/**\n * @category Node\n */\nexport class CallbackNode extends Node {\n  constructor(pushCallback = () => true, pullCallback = () => null, options) {\n    super(options);\n    this.pushCallback = pushCallback;\n    this.pullCallback = pullCallback;\n    this.on('push', this._onPush.bind(this));\n    this.on('pull', this._onPull.bind(this));\n    this.options.autoPush = this.options.autoPush || true;\n  }\n  _onPush(frame, options) {\n    return new Promise((resolve, reject) => {\n      Promise.resolve(this.pushCallback(frame, options)).then(() => {\n        if (this.options.autoPush) {\n          return Promise.all(this.outlets.map(outlet => outlet.push(frame, options)));\n        } else {\n          resolve();\n        }\n      }).then(() => {\n        resolve();\n      }).catch(reject);\n    });\n  }\n  _onPull(options) {\n    return new Promise((resolve, reject) => {\n      Promise.resolve(this.pullCallback(options)).then(result => {\n        if (result !== undefined && result !== null) {\n          // Push result\n          Promise.all(this.outlets.map(outlet => outlet.push(result, options))).then(() => {\n            resolve();\n          }).catch(reject);\n        } else {\n          // Forward pull\n          Promise.all(this.inlets.map(inlet => inlet.pull(options))).then(() => {\n            resolve();\n          }).catch(reject);\n        }\n      }).catch(reject);\n    });\n  }\n}","import { Node } from '../Node';\n/**\n * Graph shape node is a node that contains multiple nodes on itself. Other than a constructed\n * graph shape, this type of node should offer a collection of nodes. An example could be a \"PDRProcessingNode\"\n * that performs pedestrian dead reckoning by combining multiple internal nodes, such as an AccelerationProcessing,\n * VelocityProcessingNode and StepDetection.\n */\nexport class GraphShapeNode extends Node {\n  constructor(options) {\n    super(options);\n    this.once('build', this._onBuild.bind(this));\n    this.once('destroy', this._onDestroy.bind(this));\n  }\n  _onBuild() {\n    return new Promise((resolve, reject) => {\n      this.construct(this._builder);\n      this._builder.build().then(graph => {\n        this._graph = graph;\n        this._builder = null;\n        resolve();\n      }).catch(reject);\n    });\n  }\n  _onDestroy() {\n    return this._graph.emitAsync('destroy');\n  }\n  /**\n   * Send a pull request to the node\n   *\n   * @param {PullOptions} [options] Pull options\n   * @returns {Promise<void>} Pull promise\n   */\n  pull(options) {\n    return this._graph.pull(options);\n  }\n  /**\n   * Push data to the node\n   *\n   * @param {DataFrame | DataFrame[]} data Data frame to push\n   * @param {PushOptions} [options] Push options\n   * @returns {Promise<void>} Push promise\n   */\n  push(data, options = {}) {\n    return this._graph.push(data, options);\n  }\n  get processingGraph() {\n    return this._graph;\n  }\n}","import { DataObject } from '../data';\nimport { ProcessingNode } from './ProcessingNode';\n/**\n * Processing node that processes each {@link DataObject} in a {@link DataFrame} individually\n *\n * ## Usage\n *\n * ### Creating an ObjectProcessingNode\n * Extended on a {@link ProcessingNode} is an object processing node that processes individual objects in each frame.\n * ```typescript\n * import { DataFrame, DataObject, ObjectProcessingNode } from '@openhps/core';\n *\n * export class CustomObjectProcessingNode<InOut extends DataFrame> extends ObjectProcessingNode<InOut> {\n *    // ...\n *    public processObject(object: DataObject, frame?: DataFrame): Promise<DataObject> {\n *        return new Promise<DataObject>((resolve, reject) => {\n *            // Manipulate the object\n *            object.displayName = \"test\";\n *            resolve(object);\n *        });\n *    }\n * }\n * ```\n *\n * @category Processing node\n */\nexport class ObjectProcessingNode extends ProcessingNode {\n  constructor(options) {\n    super(options);\n    this.options.objectFilter = this.options.objectFilter || (() => true);\n  }\n  process(frame, options) {\n    return new Promise((resolve, reject) => {\n      const processObjectPromises = [];\n      frame.getObjects().filter(value => this.options.objectFilter(value, frame)).forEach(object => {\n        processObjectPromises.push(this.processObject(object, frame, options));\n      });\n      Promise.all(processObjectPromises).then(objects => {\n        objects.forEach(object => {\n          frame.addObject(object);\n        });\n        resolve(frame);\n      }).catch(reject);\n    });\n  }\n  /**\n   * Find an object by its uid\n   *\n   * @param {string} uid Unique identifier of object to find\n   * @param {DataFrame} dataFrame Optional data frame to look in\n   * @param {string} type Optional type of the object to find\n   * @returns {Promise<DataObject>} Data object promise if found\n   */\n  findObjectByUID(uid, dataFrame, type) {\n    if (dataFrame !== undefined) {\n      if (dataFrame.hasObject(new DataObject(uid))) {\n        return new Promise(resolve => {\n          resolve(dataFrame.getObjectByUID(uid));\n        });\n      }\n    }\n    let service;\n    if (type !== undefined) {\n      service = this.model.findDataService(type);\n    }\n    service = service || this.model.findDataService(DataObject);\n    return new Promise(resolve => {\n      service.findByUID(uid).then(resolve).catch(() => resolve(undefined));\n    });\n  }\n}","import { __decorate, __metadata } from \"tslib\";\nimport { Node } from '../Node';\nimport { NodeData } from '../service';\nimport { SerializableObject } from '../data/decorators';\n/**\n * Node that processes a dataframe or the contained objects.\n *\n * ## Usage\n *\n * ### Creating a ProcessingNode\n * Processing nodes hide the push and pull functionalities from a regular node. When a push is received, this\n * data frame is provided to the ```process()``` method that has to be implemented. When a pull is received, this pull is\n * forwarded to all incoming nodes.\n * ```typescript\n * import { DataFrame, DataObject, ProcessingNode } from '@openhps/core';\n *\n * export class CustomProcessingNode<In extends DataFrame, Out extends DataFrame> extends ProcessingNode<In, Out> {\n *     // ...\n *     public process(data: In, options?: GraphOptions): Promise<Out> {\n *         return new Promise<Out>((resolve, reject) => {\n *             // ... process/manipulate the data frame\n *             data.addObject(new DataObject(\"custom_process_object\"));\n *             resolve(data);\n *         });\n *     }\n * }\n * ```\n *\n * @category Processing node\n */\nlet ProcessingNode = class ProcessingNode extends Node {\n  constructor(options) {\n    super(options);\n    this.options.frameFilter = this.options.frameFilter || (() => true);\n    this.on('push', this._onPush.bind(this));\n  }\n  _onPush(frame, options) {\n    return new Promise((resolve, reject) => {\n      const processPromises = [];\n      if (Array.isArray(frame)) {\n        frame.filter(frame => this.options.frameFilter(frame)).forEach(f => {\n          processPromises.push(this.process(f, options));\n        });\n        frame.filter(frame => !this.options.frameFilter(frame)).forEach(f => {\n          processPromises.push(Promise.resolve(f));\n        });\n      } else if (this.options.frameFilter(frame)) {\n        processPromises.push(this.process(frame, options));\n      } else {\n        processPromises.push(Promise.resolve(frame));\n      }\n      Promise.all(processPromises).then(results => {\n        const output = results.filter(res => res !== undefined);\n        if (output.length > 0) {\n          this.outlets.forEach(outlet => outlet.push(output.length === 1 ? output[0] : output, options));\n        }\n        resolve();\n      }).catch(ex => {\n        if (ex === undefined) {\n          this.logger('warn', `Exception thrown in processing node ${this.uid} but no exception given!`);\n        }\n        reject(ex);\n      });\n    });\n  }\n  findNodeDataService() {\n    return this.model.findDataService(NodeData);\n  }\n  /**\n   * Get node data\n   *\n   * @param {DataObject} dataObject Data object to get node data from\n   * @param {any} [defaultData] Default data\n   * @returns {Promise<any>} Promise with node data\n   */\n  getNodeData(dataObject, defaultData = undefined) {\n    return new Promise((resolve, reject) => {\n      this.findNodeDataService().findData(this.uid, dataObject).then(data => {\n        if (!data) {\n          resolve(defaultData);\n        } else {\n          resolve(data);\n        }\n      }).catch(reject);\n    });\n  }\n  /**\n   * Set node data\n   *\n   * @param {DataObject} dataObject Data object to store data for\n   * @param {any} data Data to store\n   * @returns {Promise<any>} Promise with stored node data\n   */\n  setNodeData(dataObject, data) {\n    return new Promise((resolve, reject) => {\n      this.findNodeDataService().insertData(this.uid, dataObject, data).then(resolve).catch(reject);\n    });\n  }\n};\nProcessingNode = __decorate([SerializableObject(), __metadata(\"design:paramtypes\", [Object])], ProcessingNode);\nexport { ProcessingNode };","import { DataFrame } from '../data/DataFrame';\nimport { Node } from '../Node';\nimport { RemoteService } from '../service/RemoteService';\nimport { DataSerializer } from '../data/DataSerializer';\n/**\n * A remote node connects to a service in order to provide a remote connection.\n *\n * @category Node\n */\nexport class RemoteNode extends Node {\n  constructor(options, node) {\n    var _a, _b;\n    super(options);\n    this.proxyNode = node;\n    this.options.service = this.options.service || RemoteService;\n    this.options.serialize = (_a = this.options.serialize) !== null && _a !== void 0 ? _a : object => DataSerializer.serialize(object);\n    this.options.deserialize = (_b = this.options.deserialize) !== null && _b !== void 0 ? _b : object => DataSerializer.deserialize(object);\n    this.on('push', this._onPush.bind(this));\n    this.on('pull', this._onPull.bind(this));\n    this.on('error', this._onDownstreamError.bind(this));\n    this.on('completed', this._onDownstreamCompleted.bind(this));\n    this.on('localpush', this._onLocalPush.bind(this));\n    this.on('localpull', this._onLocalPull.bind(this));\n    this.on('localevent', this._onLocalEvent.bind(this));\n    this.once('build', this._onBuild.bind(this));\n  }\n  _onBuild() {\n    return new Promise((resolve, reject) => {\n      this.service = this.graph.findService(this.options.service);\n      if (this.service === undefined || this.service === null) {\n        return reject(new Error(`Remote service was not added to model!`));\n      }\n      this.service.registerNode(this).then(resolve).catch(reject);\n    });\n  }\n  _onPush(frame, options) {\n    return new Promise(resolve => {\n      // Send push to clients\n      this.service.remotePush(this.uid, frame, Object.assign(Object.assign({}, options), this.options));\n      resolve();\n    });\n  }\n  _onPull(options) {\n    return new Promise(resolve => {\n      // Send pull to clients\n      this.service.remotePull(this.uid, options);\n      resolve();\n    });\n  }\n  _onLocalPush(frame, options) {\n    return new Promise(resolve => {\n      const frameDeserialized = frame instanceof DataFrame ? frame : this.options.deserialize(frame, options);\n      this.outlets.forEach(outlet => outlet.push(frameDeserialized, options));\n      resolve();\n    });\n  }\n  _onLocalPull(options) {\n    return new Promise((resolve, reject) => {\n      Promise.all(this.inlets.map(inlet => inlet.pull(options))).then(() => {\n        resolve();\n      }).catch(reject);\n    });\n  }\n  _onLocalEvent(event, arg) {\n    this.inlets.forEach(inlet => inlet.emit(event, arg));\n  }\n  _onDownstreamCompleted(event) {\n    // Send completed event to client\n    this.service.remoteEvent(this.uid, 'completed', event);\n  }\n  _onDownstreamError(error) {\n    // Send error to clients\n    this.service.remoteEvent(this.uid, 'error', error);\n  }\n}","import { __decorate, __metadata } from \"tslib\";\nimport { SerializableObject } from '../data/decorators';\nimport { v4 as uuidv4 } from 'uuid';\nimport { Node } from '../Node';\n/**\n * Sink node\n *\n * ## Usage\n *\n * ### Creating a SinkNode\n * When creating a sink node, you have to implement an ```onPush``` method that provides you with the pushed data frame.\n * Sink nodes are the final nodes in the model and have no outlets. Once the onPush is resolved, data objects in that frame\n * are stored in a {@link DataObjectService}.\n * ```typescript\n * import { DataFrame, SinkNode } from '@openhps/core';\n *\n * export class CustomSink<In extends DataFrame> extends SinkNode<In> {\n *     // ...\n *     public onPush(data: In, options?: GraphOptions): Promise<void> {\n *         return new Promise<void>((resolve, reject) => {\n *\n *         });\n *     }\n * }\n * ```\n *\n * @category Sink node\n */\nlet SinkNode = class SinkNode extends Node {\n  constructor(options) {\n    super(options);\n    this.options.completedEvent = this.options['completedEvent'] === undefined ? true : this.options.completedEvent;\n    this.options.persistence = this.options['persistence'] === undefined ? true : this.options.persistence;\n  }\n  push(data, options) {\n    return new Promise((resolve, reject) => {\n      if (data === null || data === undefined) {\n        return reject();\n      }\n      // Push the frame to the sink node\n      this.onPush(data, options).then(() => {\n        const persistPromise = [];\n        if (data instanceof Array) {\n          data.forEach(f => {\n            if (this.options.persistence) {\n              persistPromise.push(this.persistDataObject(f));\n            }\n          });\n        } else {\n          if (this.options.persistence) {\n            persistPromise.push(this.persistDataObject(data));\n          }\n        }\n        return Promise.all(persistPromise);\n      }).then(() => {\n        resolve();\n        // Fire a completed event\n        if (this.options.completedEvent) {\n          if (data instanceof Array) {\n            data.forEach(f => {\n              this.emit('completed', {\n                frameUID: f.uid\n              });\n            });\n          } else {\n            this.emit('completed', {\n              frameUID: data.uid\n            });\n          }\n        }\n      }).catch(reject);\n    });\n  }\n  persistDataObject(frame) {\n    return new Promise((resolve, reject) => {\n      const servicePromises = [];\n      const objects = frame.getObjects();\n      for (const object of objects) {\n        if (object.uid === null) {\n          object.uid = uuidv4();\n        }\n        // Queue the storage of the object in a data service\n        const service = this.model.findDataService(object);\n        servicePromises.push(service.insert(object.uid, object));\n      }\n      Promise.all(servicePromises).then(() => resolve()).catch(reject);\n    });\n  }\n};\nSinkNode = __decorate([SerializableObject(), __metadata(\"design:paramtypes\", [Object])], SinkNode);\nexport { SinkNode };","import { __decorate, __metadata } from \"tslib\";\nimport { DataObject } from '../data/object/DataObject';\nimport { Node } from '../Node';\nimport { SerializableObject, SerializableMember } from '../data/decorators';\n/**\n * Source node\n *\n * ## Usage\n *\n * ### Creating a SourceNode\n * When creating a source node, you have to implement a promise based ```onPull``` method that expects a data\n * frame.\n *\n * As mentioned in the {@link Node} class, pulling normally does not require you to return\n * a data frame. The source node implementation provides an abstraction on top of this. If your source node can generate\n * data frames, you can resolve to a data frame. The data frame will then be pushed to outgoing nodes.\n * If not, you can simply resolve nothing or a null object.\n *\n * On top of this abstraction, a source node adds an intermediate output node that merges data objects from the [data service](#dataservice).\n * This way, the data frame pushed by the source will always be up-to-date and merged with existing processed information.\n *\n * ```typescript\n * import { DataFrame, SourceNode } from '@openhps/core';\n *\n * export class CustomSource<Out extends DataFrame> extends SourceNode<Out> {\n *     // ...\n *     constructor() {\n *         // Source nodes expect a source object to be provided\n *         super(new DataObject(\"mobile_input\")));\n *     }\n *\n *     public onPull(options?: GraphPullOptions): Promise<Out> {\n *         return new Promise<Out>((resolve, reject) => {\n *             // ... pull request\n *             // ... get data from somewhere\n *\n *             const dataFrame = new DataFrame(this.getSource());\n *             resolve(dataFrame);\n *         });\n *     }\n * }\n * ```\n *\n * @category Source node\n */\nlet SourceNode = class SourceNode extends Node {\n  /**\n   * Construct a new source node\n   *\n   * @param {SourceNodeOptions} [options=undefined] Source node options\n   */\n  constructor(options) {\n    super(options);\n    // Default source settings\n    this.options.persistence = this.options['persistence'] === undefined ? true : this.options.persistence;\n    this.on('push', this._onPush.bind(this));\n    this.on('pull', this._onPull.bind(this));\n    if (this.source) {\n      this.once('build', this.registerService.bind(this));\n    }\n  }\n  /**\n   * Get the source data object\n   *\n   * @returns {DataObject} Source data object\n   */\n  get source() {\n    return this.options.source;\n  }\n  registerService() {\n    return new Promise(resolve => {\n      const service = this.model.findDataService(this.source);\n      // Update source when modified\n      service.on('insert', (uid, object) => {\n        if (uid === this.source.uid) {\n          this.options.source = object;\n        }\n      });\n      // Update to the latest version\n      service.findByUID(this.source.uid).then(object => {\n        this.options.source = object;\n        resolve();\n      }).catch(() => {\n        // Ignore, most likely not calibrated or stored yet\n        resolve();\n      });\n    });\n  }\n  _onPush(data, options) {\n    return new Promise((resolve, reject) => {\n      const servicePromises = [];\n      if (this.options.persistence) {\n        if (data instanceof Array) {\n          for (const f of data) {\n            servicePromises.push(this.mergeFrame(f));\n          }\n        } else {\n          servicePromises.push(this.mergeFrame(data));\n        }\n      }\n      Promise.all(servicePromises).then(() => {\n        this.outlets.map(outlet => outlet.push(data, options));\n        resolve();\n      }).catch(reject);\n    });\n  }\n  mergeFrame(frame) {\n    return new Promise((resolve, reject) => {\n      const defaultService = this.model.findDataService(DataObject);\n      const promises = [];\n      const objects = [];\n      frame.getObjects().forEach(object => {\n        objects.push(object);\n      });\n      objects.forEach(object => {\n        promises.push(new Promise(objResolve => {\n          let service = this.model.findDataService(object);\n          if (service === null || service === undefined) {\n            service = defaultService;\n          }\n          service.findByUID(object.uid).then(existingObject => {\n            if (existingObject === null) {\n              objResolve();\n            }\n            this.mergeObject(object, existingObject);\n            objResolve();\n          }).catch(() => {\n            // Ignore\n            objResolve();\n          });\n        }));\n      });\n      Promise.all(promises).then(() => {\n        resolve(frame);\n      }).catch(reject);\n    });\n  }\n  /**\n   * Merge an object\n   *\n   * @param {DataObject} newObject New object\n   * @param {DataObject} oldObject Existing object\n   * @returns {DataObject} Existing object\n   */\n  mergeObject(newObject, oldObject) {\n    newObject.displayName = newObject.displayName || oldObject.displayName;\n    newObject.position = newObject.position || oldObject.position;\n    newObject.parentUID = newObject.parentUID || oldObject.parentUID;\n    oldObject.relativePositions.forEach(relativePosition => {\n      // Get the new relative position by its uid and type\n      const newPosition = newObject.getRelativePosition(relativePosition.referenceObjectUID, relativePosition.constructor.name);\n      if (newPosition && newPosition.timestamp < relativePosition.timestamp) {\n        // New object contains older relative position\n        newObject.addRelativePosition(relativePosition);\n      } else if (!newPosition) {\n        // New object does not contain stored relative position\n        newObject.addRelativePosition(relativePosition);\n      }\n    });\n    return newObject;\n  }\n  _onPull(options = {}) {\n    if (options.sourceNode && options.sourceNode !== this.uid) {\n      // Pull options indicate the pull on a specific source node\n      return Promise.resolve();\n    }\n    const sequential = options['sequentialPull'] === undefined ? true : options.sequentialPull;\n    if (sequential) {\n      return this._onSequentialPull(options);\n    } else {\n      return this._onParallelPull(options);\n    }\n  }\n  _onSequentialPull(options) {\n    const newOptions = Object.assign({\n      sourceNode: this.uid\n    }, options);\n    const count = options.count || 1;\n    let promise = Promise.resolve();\n    for (let i = 0; i < count; i++) {\n      promise = promise.then(() => new Promise((resolve, reject) => {\n        this.onPull(options).then(frame => {\n          if (frame !== undefined && frame !== null) {\n            // Resolve after push is done\n            return this.push(frame, newOptions);\n          } else {\n            resolve();\n          }\n        }).then(resolve).catch(reject);\n      }));\n    }\n    return promise;\n  }\n  _onParallelPull(options) {\n    return new Promise((resolve, reject) => {\n      const newOptions = Object.assign({\n        sourceNode: this.uid\n      }, options);\n      const count = options.count || 1;\n      Promise.all([...Array(count).keys()].map(() => this.onPull(options))).then(results => {\n        const pushPromises = [];\n        results.forEach(frame => {\n          if (frame !== undefined && frame !== null) {\n            // Push without waiting\n            pushPromises.push(this.push(frame, newOptions));\n          }\n        });\n        return Promise.all(pushPromises);\n      }).then(() => {\n        resolve();\n      }).catch(reject);\n    });\n  }\n};\n__decorate([SerializableMember(), __metadata(\"design:type\", Object)], SourceNode.prototype, \"options\", void 0);\nSourceNode = __decorate([SerializableObject(), __metadata(\"design:paramtypes\", [Object])], SourceNode);\nexport { SourceNode };","import { DataSerializer } from '../data';\nimport { Node } from '../Node';\nimport { WorkerHandler } from '../worker';\n/**\n * Worker nodes are normal nodes that initialize multiple web workers.\n * Push and pull requests are forwarded to these web workers.\n *\n * ## Usage\n *\n * ### Absolute Imports\n * ```typescript\n * const workerNode = new WorkerNode((builder) => {\n *      const TimeConsumingNode = require('@openhps/abc');\n *      builder.to(new TimeConsumingNode());\n * });\n * ```\n *\n * ### Relative Imports\n * ```typescript\n * const workerNode = new WorkerNode((builder) => {\n *      const TimeConsumingNode = require(path.join(__dirname, '../TimeConsumingNode'));\n *      builder.to(new TimeConsumingNode());\n * }, { directory: __dirname });\n * ```\n *\n * ### Web Worker\n * Web workers can be used by specifying the worker file.\n * ```typescript\n * const workerNode = new WorkerNode((builder) => {\n *      const TimeConsumingNode = require(path.join(__dirname, '../TimeConsumingNode'));\n *      builder.to(new TimeConsumingNode());\n * }, {\n *      worker: 'worker.openhps-core.min.js'    // Worker JS file\n * });\n * ```\n *\n * @category Node\n */\nexport class WorkerNode extends Node {\n  constructor(worker, options) {\n    super(options);\n    this.config = {};\n    this.options.worker = this.options.worker || '../worker/WorkerRunner';\n    if (worker instanceof Node) {\n      // Serializable node\n      this.config.serialized = DataSerializer.serialize(worker);\n    } else if (worker instanceof Function) {\n      // Code\n      this.config.builder = worker.toString();\n      if (this.options.typescript) {\n        // eslint-disable-next-line\n        this.config.builder = require('typescript').transpile(this.config.builder);\n      }\n    } else {\n      this.config.shape = worker;\n    }\n    this.once('build', this._onBuild.bind(this));\n    this.once('destroy', this._onDestroy.bind(this));\n    this.on('pull', this._onPull.bind(this));\n    this.on('push', this._onPush.bind(this));\n  }\n  _onBuild() {\n    return new Promise((resolve, reject) => {\n      this.handler = new WorkerHandler(this.model, this.options, this.config);\n      this.handler.on('push', this._onWorkerPush.bind(this));\n      this.handler.on('pull', this._onWorkerPull.bind(this));\n      this.handler.on('event', this._onWorkerEvent.bind(this));\n      this.handler.build().then(resolve).catch(reject);\n    });\n  }\n  _onDestroy() {\n    return new Promise((resolve, reject) => {\n      this.handler.destroy().then(resolve).catch(reject);\n    });\n  }\n  _onPull(options) {\n    return new Promise((resolve, reject) => {\n      if (this.options.optimizedPull) {\n        // Do not pass the pull request to the worker\n        Promise.all(this.inlets.map(inlet => inlet.pull(options))).then(() => {\n          resolve();\n        }).catch(reject);\n      } else {\n        this.handler.pull(options).then(resolve).catch(reject);\n      }\n    });\n  }\n  _onPush(frame, options) {\n    return this.handler.push(frame, options);\n  }\n  _onWorkerEvent(value) {\n    this.inlets.map(inlet => inlet.emit(value.name, value.event));\n  }\n  /**\n   * Triggered for each worker that requests a pull\n   *\n   * @param {PullOptions} options Pull options\n   */\n  _onWorkerPull(options) {\n    this.inlets.forEach(inlet => inlet.pull(options));\n  }\n  /**\n   * Triggered for each worker that pushes data\n   *\n   * @param {DataFrame} frame Deserialized frame\n   * @param {PushOptions} options Push options\n   */\n  _onWorkerPush(frame, options) {\n    this.outlets.forEach(outlet => outlet.push(frame, options));\n  }\n}","import { Node } from '../../Node';\nexport class PlaceholderNode extends Node {\n  constructor(name, options) {\n    super(Object.assign({\n      name\n    }, options));\n  }\n}","export * from './SinkNode';\nexport * from './SourceNode';\nexport * from './shapes';\nexport * from './sink';\nexport * from './source';\nexport * from './ProcessingNode';\nexport * from './processing';\nexport * from './ObjectProcessingNode';\nexport * from './WorkerNode';\nexport * from './CallbackNode';\nexport * from './RemoteNode';\nexport * from './GraphShapeNode';","import { LengthUnit } from '../../utils';\nimport { ObjectProcessingNode } from '../ObjectProcessingNode';\n/**\n * Accuracy modifier node. Apply an offset of magnitude to the position accuracy.\n *\n * @category Processing node\n */\nexport class AccuracyModifierNode extends ObjectProcessingNode {\n  constructor(options) {\n    super(options);\n    this.options.offsetUnit = this.options.offsetUnit || LengthUnit.METER;\n    this.options.offset = this.options.offset || 0;\n    this.options.magnitude = this.options.magnitude || 1;\n  }\n  processObject(object) {\n    return new Promise(resolve => {\n      if (object.position) {\n        if (this.options.value) {\n          object.position.accuracy.value = LengthUnit.METER.convert(this.options.value, object.position.unit);\n        } else {\n          const accuracy = object.position.accuracy.value || this.options.defaultValue;\n          if (accuracy) {\n            const offset = this.options.offsetUnit.convert(this.options.offset, object.position.unit);\n            object.position.accuracy.value = accuracy * this.options.magnitude + offset;\n          }\n        }\n      }\n      resolve(object);\n    });\n  }\n}","import { RelativeDistance } from '../../data';\nimport { RelativePositionProcessing } from './RelativePositionProcessing';\n/**\n * Cell identification processing node\n *\n * @category Processing node\n */\nexport class CellIdentificationNode extends RelativePositionProcessing {\n  constructor(options) {\n    super(RelativeDistance, options);\n    this.options.maxDistance = this.options.maxDistance || 2;\n  }\n  processRelativePositions(dataObject, relativePositions, dataFrame) {\n    return new Promise(resolve => {\n      let spheres = [];\n      relativePositions.forEach((object, relativePosition) => {\n        if (object.getPosition()) {\n          spheres.push([object.getPosition(), relativePosition.distance]);\n        }\n      });\n      // Order points and distances by distances\n      spheres = spheres.sort((a, b) => a[1] - b[1]);\n      if (spheres.length > 0 && spheres[0][1] <= this.options.maxDistance) {\n        const position = spheres[0][0].clone();\n        position.timestamp = dataFrame.createdTimestamp;\n        position.accuracy.value = spheres[0][1];\n        dataObject.setPosition(position);\n        return resolve(dataObject);\n      }\n      resolve(dataObject);\n    });\n  }\n}","import { Accuracy1D, GeographicalPosition, RelativeDistance } from '../../data';\nimport { AngleUnit } from '../../utils';\nimport { Vector3 } from '../../utils/math';\nimport { RelativePositionProcessing } from './RelativePositionProcessing';\n/**\n * Multilateration processing node\n *\n * @category Processing node\n */\nexport class MultilaterationNode extends RelativePositionProcessing {\n  constructor(options) {\n    super(RelativeDistance, options);\n    this.options.incrementStep = this.options.incrementStep || 1;\n    this.options.minReferences = this.options.minReferences || 1;\n    this.options.nlsFunction = this.options.nlsFunction || this.nls.bind(this);\n  }\n  processRelativePositions(dataObject, relativePositions, dataFrame) {\n    return new Promise((resolve, reject) => {\n      let spheres = [];\n      relativePositions.forEach((object, relativePosition) => {\n        if (object.getPosition()) {\n          spheres.push(new Sphere(object.getPosition(), relativePosition.distance, relativePosition.accuracy.valueOf()));\n        }\n      });\n      // Order points and distances by distances\n      spheres = spheres.sort((a, b) => a.radius - b.radius);\n      // Check if amount of references surpasses the threshold\n      if (spheres.length < this.options.minReferences) {\n        return resolve(dataObject);\n      } else if (spheres.length > this.options.maxReferences) {\n        spheres = spheres.splice(0, this.options.maxReferences);\n      }\n      let position;\n      switch (spheres.length) {\n        case 0:\n          return resolve(dataObject);\n        case 1:\n          position = spheres[0].position.clone();\n          position.timestamp = dataFrame.createdTimestamp;\n          // Accuracy is radius + accuracy of the position that we are using\n          position.accuracy = new Accuracy1D(spheres[0].radius + position.accuracy.valueOf() + spheres[0].accuracy, position.unit);\n          dataObject.setPosition(position);\n          return resolve(dataObject);\n        case 2:\n          if (spheres[0].position instanceof GeographicalPosition) {\n            position = this.midpointGeographical(spheres[0], spheres[1]);\n          } else {\n            position = this.midpoint(spheres[0], spheres[1]);\n          }\n          position.timestamp = dataFrame.createdTimestamp;\n          position.accuracy = new Accuracy1D(spheres.map(s => s.accuracy).reduce((a, b) => a.valueOf() + b.valueOf()) / spheres.length, position.unit);\n          dataObject.setPosition(position);\n          return resolve(dataObject);\n        case 3:\n          if (!this.options.preferNls) {\n            this.trilaterate(spheres).then(position => {\n              if (position) {\n                position.timestamp = dataFrame.createdTimestamp;\n                position.accuracy = new Accuracy1D(spheres.map(s => s.accuracy).reduce((a, b) => a.valueOf() + b.valueOf()) / spheres.length, position.unit);\n                dataObject.setPosition(position);\n              }\n              resolve(dataObject);\n            }).catch(reject);\n            break;\n          }\n        // eslint-disable-next-line\n        default:\n          position = this.options.nlsFunction(spheres);\n          position.timestamp = dataFrame.createdTimestamp;\n          position.accuracy = new Accuracy1D(spheres.map(s => s.accuracy).reduce((a, b) => a.valueOf() + b.valueOf()) / spheres.length, position.unit);\n          dataObject.setPosition(position);\n          resolve(dataObject);\n      }\n    });\n  }\n  /**\n   * Nonlinear least squares using nelder mead\n   *\n   * @see {@link https://github.com/benfred/fmin}\n   * @author Ben Frederickson, Qingrong Ke\n   * @param {Array<Sphere<any>>} spheres Spheres with position and radius\n   * @returns {AbsolutePosition} Output position\n   */\n  nls(spheres) {\n    // Initiailize parameters\n    const f = point => this._calculateError(point, spheres);\n    const x0 = this._calculateInit(spheres);\n    const maxIterations = this.options.maxIterations;\n    const nonZeroDelta = 1.05;\n    const zeroDelta = 0.001;\n    const minErrorDelta = 1e-6;\n    const minTolerance = 1e-5;\n    const rho = 1;\n    const chi = 2;\n    const psi = -0.5;\n    const sigma = 0.5;\n    let maxDiff = 0;\n    // Initialize simplex\n    const N = x0.length;\n    const simplex = new Array(N + 1);\n    simplex[0] = x0;\n    simplex[0].fx = f(x0);\n    simplex[0].id = 0;\n    for (let i = 0; i < N; ++i) {\n      const point = x0.slice();\n      point[i] = point[i] ? point[i] * nonZeroDelta : zeroDelta;\n      simplex[i + 1] = point;\n      simplex[i + 1].fx = f(point);\n      simplex[i + 1].id = i + 1;\n    }\n    /**\n     * @param {number} value Value\n     */\n    function updateSimplex(value) {\n      for (let i = 0; i < value.length; i++) {\n        simplex[N][i] = value[i];\n      }\n      simplex[N].fx = value.fx;\n    }\n    /**\n     * @param {number[]} ret Return value\n     * @param {number} w1 Weight 1\n     * @param {number} v1 Value 1\n     * @param {number} w2 Weight 2\n     * @param {number} v2 Value 2\n     */\n    function weightedSum(ret, w1, v1, w2, v2) {\n      for (let j = 0; j < ret.length; ++j) {\n        ret[j] = w1 * v1[j] + w2 * v2[j];\n      }\n    }\n    const sortOrder = (a, b) => a.fx - b.fx;\n    const centroid = x0.slice();\n    const reflected = x0.slice();\n    const contracted = x0.slice();\n    const expanded = x0.slice();\n    for (let iteration = 0; iteration < maxIterations; ++iteration) {\n      simplex.sort(sortOrder);\n      maxDiff = 0;\n      for (let i = 0; i < N; ++i) {\n        maxDiff = Math.max(maxDiff, Math.abs(simplex[0][i] - simplex[1][i]));\n      }\n      if (Math.abs(simplex[0].fx - simplex[N].fx) < minErrorDelta && maxDiff < minTolerance) {\n        break;\n      }\n      // compute the centroid of all but the worst point in the simplex\n      for (let i = 0; i < N; ++i) {\n        centroid[i] = 0;\n        for (let j = 0; j < N; ++j) {\n          centroid[i] += simplex[j][i];\n        }\n        centroid[i] /= N;\n      }\n      // reflect the worst point past the centroid and compute loss at reflected\n      // point\n      const worst = simplex[N];\n      weightedSum(reflected, 1 + rho, centroid, -rho, worst);\n      reflected.fx = f(reflected);\n      // if the reflected point is the best seen, then possibly expand\n      if (reflected.fx < simplex[0].fx) {\n        weightedSum(expanded, 1 + chi, centroid, -chi, worst);\n        expanded.fx = f(expanded);\n        if (expanded.fx < reflected.fx) {\n          updateSimplex(expanded);\n        } else {\n          updateSimplex(reflected);\n        }\n      }\n      // if the reflected point is worse than the second worst, we need to\n      // contract\n      else if (reflected.fx >= simplex[N - 1].fx) {\n        let shouldReduce = false;\n        if (reflected.fx > worst.fx) {\n          // do an inside contraction\n          weightedSum(contracted, 1 + psi, centroid, -psi, worst);\n          contracted.fx = f(contracted);\n          if (contracted.fx < worst.fx) {\n            updateSimplex(contracted);\n          } else {\n            shouldReduce = true;\n          }\n        } else {\n          // do an outside contraction\n          weightedSum(contracted, 1 - psi * rho, centroid, psi * rho, worst);\n          contracted.fx = f(contracted);\n          if (contracted.fx < reflected.fx) {\n            updateSimplex(contracted);\n          } else {\n            shouldReduce = true;\n          }\n        }\n        if (shouldReduce) {\n          // if we don't contract here, we're done\n          if (sigma >= 1) break;\n          // do a reduction\n          for (let i = 1; i < simplex.length; ++i) {\n            weightedSum(simplex[i], 1 - sigma, simplex[0], sigma, simplex[i]);\n            simplex[i].fx = f(simplex[i]);\n          }\n        }\n      } else {\n        updateSimplex(reflected);\n      }\n    }\n    simplex.sort(sortOrder);\n    const position = spheres[0].position.clone();\n    position.fromVector(new Vector3(...simplex[0]));\n    return position;\n  }\n  /**\n   * Midpoint to another location\n   *\n   * @param {Sphere<any>} sphereA sphere A\n   * @param {Sphere<any>} sphereB sphere B\n   * @returns {AbsolutePosition} Calculated midpoint\n   */\n  midpoint(sphereA, sphereB) {\n    const pointA = sphereA.position;\n    const pointB = sphereB.position;\n    const newPoint = pointA.clone();\n    newPoint.fromVector(pointA.toVector3().multiplyScalar(sphereB.radius).add(pointB.toVector3().multiplyScalar(sphereA.radius)).divideScalar(sphereA.radius + sphereB.radius));\n    return newPoint;\n  }\n  /**\n   * Get the midpoint of two geographical locations\n   *\n   * @param {Sphere<GeographicalPosition>} sphereA First position to get midpoint from\n   * @param {Sphere<GeographicalPosition>} sphereB Other position to get midpoint from\n   * @returns {GeographicalPosition} Calculated midpoint\n   */\n  midpointGeographical(sphereA, sphereB) {\n    const pointA = sphereA.position;\n    const pointB = sphereB.position;\n    if (sphereA.radius === sphereB.radius) {\n      const lonRadA = AngleUnit.DEGREE.convert(pointA.longitude, AngleUnit.RADIAN);\n      const latRadA = AngleUnit.DEGREE.convert(pointA.latitude, AngleUnit.RADIAN);\n      const lonRadB = AngleUnit.DEGREE.convert(pointB.longitude, AngleUnit.RADIAN);\n      const latRadB = AngleUnit.DEGREE.convert(pointB.latitude, AngleUnit.RADIAN);\n      const Bx = Math.cos(latRadB) * Math.cos(lonRadB - lonRadA);\n      const By = Math.cos(latRadB) * Math.sin(lonRadB - lonRadA);\n      const latX = Math.atan2(Math.sin(latRadA) + Math.sin(latRadB), Math.sqrt((Math.cos(latRadA) + Bx) * (Math.cos(latRadA) + Bx) + By * By));\n      const lonX = lonRadA + Math.atan2(By, Math.cos(latRadA) + Bx);\n      const position = new GeographicalPosition();\n      position.latitude = AngleUnit.RADIAN.convert(latX, AngleUnit.DEGREE);\n      position.longitude = AngleUnit.RADIAN.convert(lonX, AngleUnit.DEGREE);\n      return position;\n    } else {\n      // Calculate bearings\n      const bearingAB = pointA.bearing(pointB);\n      const bearingBA = pointB.bearing(pointA);\n      // Calculate two reference points\n      const C = pointA.destination(bearingAB, sphereA.radius);\n      const D = pointB.destination(bearingBA, sphereB.radius);\n      // Calculate the middle of C and D\n      const midpoint = this.midpoint(new Sphere(C, 1, C.accuracy.valueOf()), new Sphere(D, 1, D.accuracy.valueOf()));\n      midpoint.accuracy = new Accuracy1D(Math.round(C.distanceTo(D) / 2 * 100) / 100, midpoint.unit);\n      return midpoint;\n    }\n  }\n  trilaterate(spheres) {\n    return new Promise(resolve => {\n      const maxIterations = this.options.maxIterations || 900;\n      const v = spheres.map(p => p.center);\n      const ex = v[1].clone().sub(v[0]).normalize();\n      const i = ex.clone().dot(v[2].clone().sub(v[0]));\n      const ey = v[2].clone().sub(v[0]).sub(ex.clone().multiplyScalar(i)).normalize();\n      const ez = ex.clone().cross(ey);\n      const d = v[1].clone().sub(v[0]).length();\n      const j = ey.clone().dot(v[2].clone().sub(v[0]));\n      // Calculate coordinates\n      let AX = spheres[0].radius;\n      let BX = spheres[1].radius;\n      let CX = spheres[2].radius;\n      let x = 0;\n      let y = 0;\n      let b = -1;\n      let iteration = 0;\n      do {\n        x = (Math.pow(AX, 2) - Math.pow(BX, 2) + Math.pow(d, 2)) / (2 * d);\n        y = (Math.pow(AX, 2) - Math.pow(CX, 2) + Math.pow(i, 2) + Math.pow(j, 2)) / (2 * j) - i / j * x;\n        b = Math.pow(AX, 2) - Math.pow(x, 2) - Math.pow(y, 2);\n        // Increase distances\n        AX += this.options.incrementStep;\n        BX += this.options.incrementStep;\n        CX += this.options.incrementStep;\n        iteration++;\n      } while (b < -1e-10 && iteration < maxIterations);\n      const z = Math.sqrt(b) || 0;\n      const point = spheres[0].position.clone();\n      point.fromVector(v[0].clone().add(ex.multiplyScalar(x)).add(ey.multiplyScalar(y)).add(ez.multiplyScalar(z)));\n      return resolve(point);\n    });\n  }\n  _calculateInit(spheres) {\n    // center coordinates of smallest circle\n    const smallestSphere = spheres[0];\n    // weighted centroid of all pnts\n    const sumR = spheres.map(p => p.radius).reduce((a, b) => a + b);\n    const wCentroid = new Vector3(0, 0, 0);\n    spheres.forEach(sphere => {\n      const weight = (sumR - sphere.radius) / ((spheres.length - 1) * sumR);\n      wCentroid.add(sphere.center.clone().multiplyScalar(weight));\n    });\n    // pick weighted centroid if it's included within the smallest circle radius,\n    // otherwise go as far in that direction as ~90% of the smallest radius allows\n    const radRatio = Math.min(1, smallestSphere.radius / smallestSphere.center.distanceTo(wCentroid) * 0.9);\n    const p0 = wCentroid.multiplyScalar(radRatio).add(smallestSphere.center.clone().multiplyScalar(1 - radRatio));\n    return p0.toArray();\n  }\n  _calculateError(point, spheres) {\n    return spheres.map(sphere => Math.pow(new Vector3(...point).distanceTo(sphere.center) - sphere.radius, 2)).reduce((a, b) => a + b);\n  }\n}\nclass Sphere {\n  constructor(position, radius, accuracy) {\n    this.position = position;\n    this.radius = radius;\n    this.accuracy = accuracy;\n  }\n  get center() {\n    return this.position.toVector3();\n  }\n}","import { ObjectProcessingNode } from '../ObjectProcessingNode';\nimport { ReferenceSpace } from '../../data';\n/**\n * This node converts the positions of data objects inside the frame\n * to another reference space.\n *\n * @category Processing node\n */\nexport class ReferenceSpaceConversionNode extends ObjectProcessingNode {\n  constructor(referenceSpace, options) {\n    super(options);\n    if (referenceSpace instanceof ReferenceSpace) {\n      this._referenceSpace = referenceSpace;\n      this._referenceSpaceUID = referenceSpace.uid;\n    } else {\n      this._referenceSpaceUID = referenceSpace;\n    }\n    this.once('build', this._onRegisterService.bind(this));\n  }\n  _onRegisterService() {\n    return new Promise(resolve => {\n      const service = this.graph.findDataService(ReferenceSpace);\n      // Update reference space when modified\n      service.on('insert', (uid, space) => {\n        if (uid === this._referenceSpaceUID) {\n          this._referenceSpace = space;\n        }\n      });\n      // Update to the latest version\n      service.findByUID(this._referenceSpaceUID).then(space => {\n        this._referenceSpace = space;\n        resolve();\n      }).catch(() => {\n        // Ignore, most likely not calibrated or stored yet\n        resolve();\n      });\n    });\n  }\n  processObject(object, frame) {\n    return new Promise(resolve => {\n      // First check if a reference space is provided inside\n      // the data frame. If not, use the stored reference space\n      let referenceSpace = frame.getObjectByUID(this._referenceSpaceUID);\n      if (referenceSpace === null || referenceSpace === undefined) {\n        referenceSpace = this._referenceSpace;\n      }\n      if (object.getPosition() && object.uid !== referenceSpace.uid) {\n        if (this.options.inverse) {\n          // Convert from reference space to global\n          object.setPosition(object.getPosition(), referenceSpace);\n        } else {\n          // Convert global space to reference space\n          object.setPosition(object.getPosition(referenceSpace));\n        }\n      }\n      resolve(object);\n    });\n  }\n}","import { ObjectProcessingNode } from '../ObjectProcessingNode';\n/**\n * Relative position processing node.\n *\n * @category Processing node\n */\nexport class RelativePositionProcessing extends ObjectProcessingNode {\n  constructor(relativePositionType, options) {\n    super(options);\n    this._relativePositionType = relativePositionType;\n  }\n  processObject(dataObject, dataFrame) {\n    return new Promise((resolve, reject) => {\n      const referencePromises = [];\n      const index = new Map();\n      for (const relativePosition of dataObject.relativePositions) {\n        // Only use relative positions that are instance of relativePositionType\n        if (relativePosition instanceof this._relativePositionType) {\n          index.set(relativePosition.referenceObjectUID, relativePosition);\n          referencePromises.push(this.findObjectByUID(relativePosition.referenceObjectUID, dataFrame, relativePosition.referenceObjectType));\n        }\n      }\n      Promise.all(referencePromises).then(referenceObjects => {\n        const relativePositions = new Map();\n        referenceObjects.filter(obj => obj !== undefined).forEach(referenceObject => {\n          relativePositions.set(index.get(referenceObject.uid), referenceObject);\n        });\n        return this.processRelativePositions(dataObject, relativePositions, dataFrame);\n      }).then(modifiedObject => {\n        resolve(modifiedObject);\n      }).catch(reject);\n    });\n  }\n}","import { RelativeAngle } from '../../data';\nimport { AngleUnit, Vector3 } from '../../utils';\nimport { RelativePositionProcessing } from './RelativePositionProcessing';\n/**\n * Triangulation processing node\n * Supported position types:\n * - {@link Absolute2DPosition}\n * - {@link Absolute3DPosition}\n * - {@link GeographicalPosition}\n *\n * @category Processing node\n */\nexport class TriangulationNode extends RelativePositionProcessing {\n  constructor(options) {\n    super(RelativeAngle, options);\n  }\n  processRelativePositions(dataObject, relativePositions, dataFrame) {\n    return new Promise((resolve, reject) => {\n      const objects = [];\n      const points = [];\n      const angles = [];\n      relativePositions.forEach((object, relativePosition) => {\n        if (object.getPosition()) {\n          objects.push(object);\n          points.push(object.getPosition());\n          angles.push(relativePosition.angleUnit.convert(relativePosition.angle, AngleUnit.RADIAN));\n        }\n      });\n      switch (objects.length) {\n        case 0:\n        case 1:\n          return resolve(dataObject);\n        case 2:\n          break;\n        case 3:\n          // TODO: Currently only for 2d\n          this.triangulate(points, angles).then(position => {\n            if (position !== null) {\n              position.timestamp = dataFrame.createdTimestamp;\n              dataObject.setPosition(position);\n            }\n            resolve(dataObject);\n          }).catch(reject);\n          break;\n        default:\n          return resolve(dataObject);\n      }\n    });\n  }\n  /**\n   * Triangulate a absolute 3d location\n   *\n   * @see {@link https://ieeexplore.ieee.org/document/6693716?tp=&arnumber=6693716}\n   * @param {AbsolutePosition[]} points Points to triangulate\n   * @param {number[]} angles Angles\n   * @returns {Promise<AbsolutePosition>} Promise for the triangulated absolute position\n   */\n  triangulate(points, angles) {\n    return new Promise((resolve, reject) => {\n      const vectors = [points[0].toVector3(), points[1].toVector3(), points[2].toVector3()];\n      const x1 = vectors[0].x - vectors[1].x;\n      const y1 = vectors[0].y - vectors[1].y;\n      const x3 = vectors[2].x - vectors[1].x;\n      const y3 = vectors[2].y - vectors[1].y;\n      const t12 = 1 / Math.tan(angles[1] - angles[0]);\n      const t23 = 1 / Math.tan(angles[2] - angles[1]);\n      const t31 = (1 - t12 * t23) / (t12 + t23);\n      const x12 = x1 + t12 * y1;\n      const y12 = y1 - t12 * x1;\n      const x23 = x3 - t23 * y3;\n      const y23 = y3 + t23 * x3;\n      const x31 = x3 + x1 + t31 * (y3 - y1);\n      const y31 = y3 + y1 - t31 * (x3 - x1);\n      const k31 = x1 * x3 + y1 * y3 + t31 * (x1 * y3 - x3 * y1);\n      const d = (x12 - x23) * (y23 - y31) - (y12 - y23) * (x23 - x31);\n      if (d === 0) {\n        return reject();\n      }\n      const xr = vectors[1].x + k31 * (y12 - y23) / d;\n      const yr = vectors[1].y + k31 * (x23 - x12) / d;\n      const point = points[0].clone();\n      point.unit = points[0].unit;\n      point.fromVector(new Vector3(xr, yr, 0));\n      return resolve(point);\n    });\n  }\n}","import { PropertyFilterProcessingNode } from './PropertyFilterProcessingNode';\n/**\n * @category Processing node\n */\nexport class EMAFilterNode extends PropertyFilterProcessingNode {\n  constructor(propertySelector, propertyModifier, options) {\n    super(propertySelector, propertyModifier, options);\n  }\n  initFilter(object, value, options) {\n    return new Promise(resolve => {\n      if (options.alpha > 1 || options.alpha < 0) {\n        throw new Error(`Filter coefficient needs to be between 0 and 1!`);\n      }\n      resolve({\n        x: value,\n        alpha: options.alpha\n      });\n    });\n  }\n  filter(object, value, filter) {\n    return new Promise(resolve => {\n      if (typeof value === 'number') {\n        filter.x = filter.x * (1 - filter.alpha) + filter.alpha * value;\n      } else {\n        const vector = value;\n        const filterVector = filter.x;\n        filter.x = filterVector.clone().multiplyScalar(1 - filter.alpha).add(vector.clone().multiplyScalar(filter.alpha));\n      }\n      resolve(filter.x);\n    });\n  }\n}","import { __awaiter } from \"tslib\";\nimport { TimeService } from '../../../service/TimeService';\nimport { ObjectProcessingNode } from '../../ObjectProcessingNode';\n/**\n * @category Processing node\n */\nexport class FilterProcessingNode extends ObjectProcessingNode {\n  constructor(options) {\n    super(options);\n  }\n  processObject(object, frame) {\n    return new Promise((resolve, reject) => {\n      // Get existing filter data\n      this.getNodeData(object).then(nodeData => __awaiter(this, void 0, void 0, function* () {\n        if (nodeData === undefined) {\n          nodeData = Object.assign({\n            timestamp: TimeService.now()\n          }, yield this.initFilter(object, frame, this.options));\n        } else if (nodeData['timestamp']) {\n          if (nodeData.timestamp + this.options.expire < TimeService.now()) {\n            nodeData = Object.assign({\n              timestamp: TimeService.now()\n            }, yield this.initFilter(object, frame, this.options));\n          }\n        } else {\n          nodeData = Object.assign({\n            timestamp: TimeService.now()\n          }, nodeData);\n        }\n        this.filter(object, frame, nodeData, this.options).then(result => {\n          resolve(result);\n        }).catch(reject).finally(() => {\n          this.setNodeData(object, nodeData).then(() => {\n            resolve(undefined);\n          }).catch(reject);\n        });\n      })).catch(reject);\n    });\n  }\n}","import { PropertyFilterProcessingNode } from './PropertyFilterProcessingNode';\n/**\n * @category Processing node\n */\nexport class HPFilterNode extends PropertyFilterProcessingNode {\n  constructor(propertySelector, propertyModifier, options) {\n    super(propertySelector, propertyModifier, options);\n  }\n  initFilter(object, value, options) {\n    return new Promise(resolve => {\n      const rc = 1.0 / (options.cutOff * 2 * Math.PI);\n      const dt = 1.0 / options.sampleRate;\n      const alpha = rc / (rc + dt);\n      resolve({\n        x: value,\n        y: value,\n        alpha\n      });\n    });\n  }\n  filter(object, value, filter) {\n    return new Promise(resolve => {\n      if (typeof value === 'number') {\n        filter.x = filter.alpha * (filter.x + value - filter.y);\n        filter.y = value;\n        resolve(filter.x);\n      } else {\n        filter.x = filter.x.clone().add(value).sub(filter.y).multiplyScalar(filter.alpha);\n        filter.y = value;\n        resolve(filter.x);\n      }\n    });\n  }\n}","import { PropertyFilterProcessingNode } from './PropertyFilterProcessingNode';\nimport { Vector3 } from '../../../utils';\n/**\n * Kalman Filter processing node\n *\n * @category Processing node\n */\nexport class KalmanFilterNode extends PropertyFilterProcessingNode {\n  constructor(propertySelector, propertyModifier, options) {\n    super(propertySelector, propertyModifier, options);\n  }\n  initFilter(object, value, options) {\n    return new Promise(resolve => {\n      Object.keys(options).forEach(key => {\n        if (typeof options[key] === 'number' && ['R', 'Q', 'A', 'B', 'C'].includes(key)) {\n          options[key] = new Vector3(options[key], 0, 0);\n        }\n      });\n      resolve(Object.assign({\n        x: undefined,\n        cov: NaN\n      }, options));\n    });\n  }\n  filter(object, value, filter) {\n    return new Promise(resolve => {\n      const kf = new KalmanFilter(filter.R, filter.Q, filter.A, filter.B, filter.C, filter.x, filter.cov);\n      const numeric = typeof value === 'number';\n      if (numeric) {\n        kf.filter(new Vector3(value, 0, 0));\n      } else {\n        kf.filter(value);\n      }\n      // Save the node data\n      filter.x = kf.measurement;\n      filter.cov = kf.covariance;\n      if (numeric) {\n        resolve(kf.measurement.x);\n      } else {\n        resolve(kf.measurement);\n      }\n    });\n  }\n}\n/**\n * Basic Kalman Filter\n *\n * @author Wouter Bulten\n * @see {@link http://github.com/wouterbulten/kalmanjs}\n * @copyright Copyright 2015-2018 Wouter Bulten\n * @license MIT\n */\nexport class KalmanFilter {\n  constructor(R, Q, A, B, C, x, cov) {\n    this._R = R;\n    this._Q = Q;\n    this._A = A;\n    this._B = B;\n    this._C = C;\n    this._x = x;\n    this._cov = cov;\n  }\n  /**\n   * Filter a new value\n   *\n   * @param  {Vector3} z Measurement\n   * @param  {Vector3} u Control\n   * @returns {Vector3} Filtered value\n   */\n  filter(z, u) {\n    if (this._x === undefined) {\n      const ct = new Vector3(1, 1, 1).divide(this._C);\n      this._x = ct.clone().multiply(z);\n      this._cov = ct.clone().multiply(this._Q).multiply(ct);\n    } else {\n      // Compute prediction\n      const predX = this.predict(u);\n      const predCov = this.uncertainty();\n      // Kalman gain\n      const K = predCov.clone().multiply(this._C).multiply(new Vector3(1, 1, 1).divide(this._C.clone().multiply(predCov).multiply(this._C).add(this._Q)));\n      // Correction\n      this._x = predX.clone().add(K.clone().multiply(z.clone().sub(this._C.clone().multiply(predX))));\n      this._cov = predCov.clone().sub(K.clone().multiply(this._C).multiply(predCov));\n    }\n    return this._x;\n  }\n  /**\n   * Predict next value\n   *\n   * @param  {Vector3} [u] Control\n   * @returns {Vector3} Predicted value\n   */\n  predict(u) {\n    return this._A.clone().multiply(this._x).add(u === undefined ? new Vector3() : this._B.clone().multiply(u));\n  }\n  /**\n   * Return uncertainty of filter\n   *\n   * @returns {number} Uncertainty\n   */\n  uncertainty() {\n    return this._A.clone().multiply(this._cov).multiply(this._A).add(this._R);\n  }\n  /**\n   * Return the last filtered measurement\n   *\n   * @returns {Vector3} Last measurement\n   */\n  get measurement() {\n    return this._x;\n  }\n  /**\n   * Get covariance\n   *\n   * @returns {Vector3} covariance vector\n   */\n  get covariance() {\n    return this._cov;\n  }\n}","import { PropertyFilterProcessingNode } from './PropertyFilterProcessingNode';\n/**\n * @category Processing node\n */\nexport class LPFilterNode extends PropertyFilterProcessingNode {\n  constructor(propertySelector, propertyModifier, options) {\n    super(propertySelector, propertyModifier, options);\n  }\n  initFilter(object, value, options) {\n    return new Promise(resolve => {\n      let alpha = options.alpha;\n      if (alpha === undefined) {\n        const rc = 1.0 / (options.cutOff * 2 * Math.PI);\n        const dt = 1.0 / options.sampleRate;\n        alpha = dt / (rc + dt);\n      }\n      resolve({\n        x: value,\n        alpha\n      });\n    });\n  }\n  filter(object, value, filter) {\n    return new Promise(resolve => {\n      if (typeof value === 'number') {\n        filter.x = filter.x + filter.alpha * (value - filter.x);\n      } else {\n        const vector = value.clone();\n        const filterVector = filter.x;\n        filter.x = filterVector.add(vector.sub(filter.x).multiplyScalar(filter.alpha));\n      }\n      resolve(filter.x);\n    });\n  }\n}","import { __awaiter } from \"tslib\";\nimport { ObjectProcessingNode } from '../../ObjectProcessingNode';\nimport { TimeService } from '../../../service/TimeService';\n/**\n * @category Processing node\n */\nexport class PropertyFilterProcessingNode extends ObjectProcessingNode {\n  constructor(propertySelector, propertyModifier, options) {\n    super(options);\n    this._propertySelector = propertySelector;\n    this._propertyModifier = propertyModifier;\n  }\n  processObject(object, frame) {\n    return new Promise((resolve, reject) => {\n      // Extract all sensor values from the frame\n      const types = this._propertySelector(object, frame);\n      Promise.all(types.map(type => {\n        return this.filterValue(object, type.value, type.key);\n      })).then(results => {\n        for (let i = 0; i < results.length; i++) {\n          const result = results[i];\n          const type = types[i];\n          this._propertyModifier(type.key, result, object, frame);\n        }\n        resolve(object);\n      }).catch(reject);\n    });\n  }\n  filterValue(object, value, key = 'default') {\n    return new Promise((resolve, reject) => {\n      // Get existing filter data\n      this.getNodeData(object).then(nodeData => __awaiter(this, void 0, void 0, function* () {\n        if (nodeData === undefined) {\n          nodeData = {};\n        }\n        const currentTimestamp = TimeService.now();\n        if (nodeData[key] === undefined) {\n          nodeData[key] = Object.assign({\n            timestamp: currentTimestamp\n          }, yield this.initFilter(object, value, this.options));\n        } else {\n          nodeData[key] = Object.assign({\n            timestamp: currentTimestamp\n          }, nodeData[key]);\n        }\n        if (this.options.expire) {\n          const deleteData = [];\n          Object.keys(nodeData).forEach(key => {\n            const data = nodeData[key];\n            if (data['timestamp']) {\n              if (data.timestamp + this.options.expire < currentTimestamp) {\n                deleteData.push(key);\n              }\n            }\n          });\n          deleteData.forEach(key => {\n            delete nodeData[key];\n          });\n        }\n        this.filter(object, value, nodeData[key], this.options).then(resolve).catch(reject).finally(() => {\n          this.setNodeData(object, nodeData);\n        });\n      })).catch(reject);\n    });\n  }\n}","import { TimeService } from '../../../service/TimeService';\nimport { KalmanFilterNode } from './KalmanFilterNode';\n/**\n * Relative position filter to filter the relative positions of an object depending on criteria\n */\nexport class RelativePositionFilter extends KalmanFilterNode {\n  constructor(relativePositionType, options) {\n    super(undefined, undefined, options);\n    this._relativePositionType = relativePositionType;\n    this.options.minValue = this.options.minValue || 0;\n    this.options.maxValue = this.options.maxValue || 100;\n    this.options.maxTimeDifference = this.options.maxTimeDifference || Infinity;\n  }\n  processObject(object) {\n    return new Promise((resolve, reject) => {\n      const relativePositions = object.relativePositions\n      // For each relative position matching the type\n      .filter(x => x instanceof this._relativePositionType);\n      Promise.all(relativePositions\n      // Filter the reference value with the built-in filter (key being object uid)\n      .map(relPos => {\n        return this.filterValue(object, relPos.referenceValue, relPos.referenceObjectUID);\n      })).then(results => {\n        results.forEach((result, idx) => {\n          const value = result;\n          const relativePosition = relativePositions[idx];\n          if (value <= this.options.maxValue && value >= this.options.minValue && TimeService.now() - this.options.maxTimeDifference <= relativePosition.timestamp) {\n            relativePosition.referenceValue = value;\n          } else {\n            object.removeRelativePositions(relativePosition.referenceObjectUID);\n          }\n        });\n        resolve(object);\n      }).catch(reject);\n    });\n  }\n}","import { PropertyFilterProcessingNode } from './PropertyFilterProcessingNode';\n/**\n * @category Processing node\n */\nexport class SMAFilterNode extends PropertyFilterProcessingNode {\n  constructor(propertySelector, propertyModifier, options) {\n    super(propertySelector, propertyModifier, options);\n  }\n  initFilter(object, value, options) {\n    return new Promise(resolve => {\n      if (options.taps < 1) {\n        throw new Error(`Filter taps needs to be higher than 1!`);\n      }\n      resolve({\n        x: [],\n        taps: options.taps\n      });\n    });\n  }\n  filter(object, value, filter, options) {\n    return new Promise(resolve => {\n      filter.x.push(value);\n      if (filter.x.length > filter.taps) {\n        filter.x.shift();\n      } else if (options.minTaps && filter.x.length < options.minTaps) {\n        resolve(value);\n      }\n      if (typeof value === 'number') {\n        const sum = filter.x.reduce((a, b) => a + b);\n        resolve(sum / filter.taps);\n      } else {\n        const sum = filter.x[0].clone();\n        for (let i = 1; i < filter.x.length; i++) {\n          sum.add(filter.x[i]);\n        }\n        resolve(sum.divideScalar(filter.taps));\n      }\n    });\n  }\n}","export * from './FilterProcessingNode';\nexport * from './PropertyFilterProcessingNode';\nexport * from './KalmanFilterNode';\nexport * from './LPFilterNode';\nexport * from './HPFilterNode';\nexport * from './SMAFilterNode';\nexport * from './EMAFilterNode';\nexport * from './RelativePositionFilter';","export * from './ReferenceSpaceConversionNode';\nexport * from './dsp';\nexport * from './RelativePositionProcessing';\nexport * from './MultilaterationNode';\nexport * from './TriangulationNode';\nexport * from './AccuracyModifierNode';\nexport * from './CellIdentificationNode';","import { Node } from '../../Node';\n/**\n * @category Flow shape\n */\nexport class BalanceNode extends Node {\n  constructor() {\n    super(...arguments);\n    this._busyNodes = [];\n    this._queue = [];\n  }\n  push(frame) {\n    return new Promise((resolve, reject) => {\n      this.logger('debug', `Received a data frame in the balance node ${this.uid}`, frame);\n      let assigned = false;\n      for (const outlet of this.outlets) {\n        if (this._busyNodes.indexOf(outlet) === -1) {\n          // Node is not busy - perform push\n          this._busyNodes.push(outlet);\n          assigned = true;\n          outlet.push(frame).then(() => {\n            this._busyNodes.splice(this._busyNodes.indexOf(outlet), 1);\n            this._updateQueue();\n            resolve();\n          }).catch(ex => {\n            this._updateQueue();\n            reject(ex);\n          });\n          break; // Stop Assigning\n        }\n      }\n\n      if (!assigned) {\n        // Add to queue\n        this._queue.push({\n          frame,\n          resolve,\n          reject\n        });\n      }\n    });\n  }\n  _updateQueue() {\n    if (this._queue.length !== 0) {\n      for (const outlet of this.outlets) {\n        if (this._busyNodes.indexOf(outlet) === -1) {\n          // Node is not busy - perform push\n          const queue = this._queue.pop();\n          outlet.push(queue.frame).then(() => {\n            this._busyNodes.splice(this._busyNodes.indexOf(outlet), 1);\n            this._updateQueue();\n            queue.resolve();\n          }).catch(ex => {\n            this._updateQueue();\n            queue.reject(ex);\n          });\n          break; // Stop Assigning\n        }\n      }\n    }\n  }\n}","import { Node } from '../../Node';\n/**\n * @category Flow shape\n */\nexport class BroadcastNode extends Node {}","import { DataFrame } from '../../data/DataFrame';\nimport { Node } from '../../Node';\n/**\n * @category Flow shape\n */\nexport class BufferNode extends Node {\n  constructor(options) {\n    super(options);\n    this.on('pull', this.onPull.bind(this));\n    this.on('push', this.onPush.bind(this));\n    this.on('build', this._initService.bind(this));\n  }\n  _initService() {\n    return new Promise(resolve => {\n      if (!this.service) {\n        this.service = this.model.findDataService(this.options.service || DataFrame);\n      }\n      resolve();\n    });\n  }\n  onPull(options) {\n    return new Promise((resolve, reject) => {\n      this.shift().then(frame => {\n        if (frame) {\n          this.outlets.forEach(outlet => outlet.push(frame, options));\n        }\n        resolve();\n      }).catch(reject);\n    });\n  }\n  onPush(frame) {\n    return new Promise((resolve, reject) => {\n      this.service.insertFrame(frame).then(() => {\n        resolve();\n      }).catch(reject);\n    });\n  }\n  next() {\n    return new Promise((resolve, reject) => {\n      this.service.findOne({}, {\n        sort: [['createdTimestamp', 1]]\n      }).then(resolve).catch(reject);\n    });\n  }\n  shift() {\n    return new Promise((resolve, reject) => {\n      let result;\n      this.next().then(frame => {\n        if (frame) {\n          result = frame;\n          return this.service.delete(frame.uid);\n        } else {\n          resolve(undefined);\n        }\n      }).then(() => resolve(result)).catch(reject);\n    });\n  }\n}","import { Node } from '../../Node';\nimport { TimeUnit } from '../../utils';\n/**\n * @category Flow shape\n */\nexport class FrameChunkNode extends Node {\n  constructor(count, timeout, timeoutUnit = TimeUnit.MILLISECOND, options) {\n    super(options);\n    this._queue = [];\n    this._count = count;\n    if (timeout) {\n      this._interval = timeoutUnit.convert(timeout, TimeUnit.MILLISECOND);\n      this.once('build', this._start.bind(this));\n      this.once('destroy', this._stop.bind(this));\n    }\n    this.on('push', this._onPush.bind(this));\n  }\n  _onPush(frame) {\n    return new Promise((resolve, reject) => {\n      this._queue.push(frame);\n      if (this._queue.length >= this._count) {\n        this._flushQueue().then(resolve).catch(reject);\n      } else {\n        resolve();\n      }\n    });\n  }\n  _flushQueue() {\n    return new Promise(resolve => {\n      // Restart the timeout\n      if (this._timer !== undefined) {\n        clearInterval(this._timer);\n        this._timer = setInterval(this._timeoutFn.bind(this), this._interval);\n      }\n      this.outlets.forEach(outlet => outlet.push(this._queue));\n      this._queue = [];\n      resolve();\n    });\n  }\n  _timeoutFn() {\n    if (this._queue.length > 0) {\n      Promise.resolve(this._flushQueue());\n    }\n  }\n  /**\n   * Start the timeout timer\n   *\n   * @returns {Promise<void>} Start promise\n   */\n  _start() {\n    return new Promise(resolve => {\n      this._timer = setInterval(this._timeoutFn.bind(this), this._interval);\n      resolve();\n    });\n  }\n  _stop() {\n    if (this._timer !== undefined) {\n      clearInterval(this._timer);\n      this._timer = undefined;\n    }\n  }\n}","import { DataFrame } from '../../data';\nimport { Node } from '../../Node';\n/**\n * @category Flow shape\n */\nexport class FrameCloneNode extends Node {\n  constructor(options) {\n    super(options);\n    this.on('push', this._onPush.bind(this));\n  }\n  _onPush(frame, options) {\n    return new Promise(resolve => {\n      const newFrame = this.options.repack ? this._repack(frame) : frame.clone();\n      this.outlets.forEach(outlet => outlet.push(newFrame, options));\n      resolve();\n    });\n  }\n  _repack(frame) {\n    const newFrame = new DataFrame();\n    newFrame.createdTimestamp = frame.createdTimestamp;\n    frame.getObjects().forEach(object => {\n      newFrame.addObject(object.clone());\n    });\n    return newFrame;\n  }\n}","import { TimeUnit } from '../../utils';\nimport { ProcessingNode } from '../ProcessingNode';\n/**\n * Frame delay node to delay pushing of frames.\n *\n * @category Flow shape\n */\nexport class FrameDelayNode extends ProcessingNode {\n  constructor(timeout, timeoutUnit) {\n    super();\n    this._timeout = timeout;\n    this._timeoutUnit = timeoutUnit;\n  }\n  process(frame) {\n    return new Promise(resolve => {\n      setTimeout(() => {\n        resolve(frame);\n      }, this._timeoutUnit.convert(this._timeout, TimeUnit.MILLISECOND));\n    });\n  }\n}","import { ProcessingNode } from '../ProcessingNode';\n/**\n * @category Flow shape\n */\nexport class FrameFilterNode extends ProcessingNode {\n  constructor(filterFn, options) {\n    super(options);\n    this.options.frameFilter = () => true;\n    this.filterFn = filterFn;\n  }\n  process(frame) {\n    return new Promise(resolve => {\n      if (this.filterFn(frame)) {\n        resolve(frame);\n      } else {\n        resolve(undefined);\n      }\n    });\n  }\n}","import { Node } from '../../Node';\n/**\n * @category Flow shape\n */\nexport class FrameFlattenNode extends Node {\n  constructor(options) {\n    super(options);\n    this.on('push', this._onPush.bind(this));\n  }\n  _onPush(frames, options) {\n    return new Promise(resolve => {\n      frames.map(frame => this.outlets.forEach(outlet => outlet.push(frame, options)));\n      resolve();\n    });\n  }\n}","import { Accuracy1D } from '../../data/values/Accuracy1D';\nimport { AngleUnit } from '../../utils';\nimport { MergeShape } from './MergeShape';\n/**\n * Merges two or more frames together based on a merge key.\n *\n * ## Usage\n * ```typescript\n * new FrameMergeNode();\n * ```\n *\n * @category Flow shape\n */\nexport class FrameMergeNode extends MergeShape {\n  /**\n   * Merge multiple data objects together\n   *\n   * @param {DataObject[]} objects Data objects\n   * @returns {DataObject} Merged data object\n   */\n  mergeObjects(objects) {\n    const baseObject = objects[0];\n    // Relative positions\n    for (let i = 1; i < objects.length; i++) {\n      objects[i].getRelativePositions().forEach(relativePos => {\n        baseObject.addRelativePosition(relativePos);\n      });\n    }\n    // Weighted position merging\n    const positions = objects.map(object => object.getPosition()).filter(position => position !== undefined);\n    if (positions.length === 0) {\n      return baseObject;\n    }\n    let newPosition = positions[0].clone();\n    for (let i = 1; i < positions.length; i++) {\n      newPosition = this.mergePositions(newPosition, positions[i].clone());\n    }\n    if (newPosition.accuracy) {\n      newPosition.accuracy.value = 1 / newPosition.accuracy.value;\n    }\n    if (newPosition.linearVelocity) {\n      newPosition.linearVelocity.setAccuracy(1 / newPosition.linearVelocity.accuracy.valueOf());\n    }\n    baseObject.setPosition(newPosition);\n    return baseObject;\n  }\n  mergePositions(positionA, positionB) {\n    const newPosition = positionA;\n    if (!positionB) {\n      return newPosition;\n    }\n    // Accuracy of the two positions\n    const posAccuracyA = positionA.accuracy || new Accuracy1D(1, positionA.unit);\n    let posAccuracyB = positionB.accuracy || new Accuracy1D(1, positionB.unit);\n    posAccuracyB = posAccuracyB.to(posAccuracyA.unit);\n    // Apply position merging\n    newPosition.fromVector(newPosition.toVector3().multiplyScalar(1 / posAccuracyA.valueOf()).add(positionB.toVector3(newPosition.unit).multiplyScalar(1 / posAccuracyB.valueOf())));\n    newPosition.fromVector(newPosition.toVector3().divideScalar(1 / posAccuracyA.valueOf() + 1 / posAccuracyB.valueOf()));\n    newPosition.accuracy.value = 1 / (posAccuracyA.valueOf() + posAccuracyB.valueOf());\n    newPosition.linearVelocity = this._mergeVelocity(newPosition.linearVelocity, positionB.linearVelocity);\n    newPosition.orientation = this._mergeOrientation(newPosition.orientation, positionB.orientation);\n    // Average timestamp\n    newPosition.timestamp = Math.round((positionA.timestamp * (1 / posAccuracyA.value) + positionB.timestamp * (1 / posAccuracyB.value)) / (1 / posAccuracyA.value + 1 / posAccuracyB.value));\n    return newPosition;\n  }\n  _mergeVelocity(velocityA, velocityB) {\n    if (velocityB) {\n      if (velocityA) {\n        const lvAccuracyA = velocityA.accuracy.valueOf() || 1;\n        const lvAccuracyB = velocityB.accuracy.valueOf() || 1;\n        // Merge linear velocity\n        velocityA.multiplyScalar(1 / lvAccuracyA).add(velocityB.multiplyScalar(1 / lvAccuracyB));\n        velocityA.divideScalar(1 / lvAccuracyA + 1 / lvAccuracyB);\n        velocityA.setAccuracy(1 / (lvAccuracyA + lvAccuracyB));\n      } else {\n        velocityA = velocityB;\n      }\n    }\n    return velocityA;\n  }\n  _mergeOrientation(orientationA, orientationB) {\n    if (orientationB) {\n      if (orientationA) {\n        const accuracyA = orientationA.accuracy || new Accuracy1D(1, AngleUnit.RADIAN);\n        const accuracyB = orientationB.accuracy || new Accuracy1D(1, AngleUnit.RADIAN);\n        const slerp = (1 / accuracyA.value + 1 / accuracyB.value) / accuracyB.value / 2;\n        orientationA.slerp(orientationB, slerp);\n      } else {\n        orientationA = orientationB;\n      }\n    }\n    return orientationA;\n  }\n  /**\n   * Merge the data frames\n   *\n   * @param {DataFrame[]} frames Data frames to merge\n   * @returns {Promise<DataFrame>} Promise of merged data frame\n   */\n  merge(frames) {\n    const mergedFrame = frames[0];\n    const mergedObjects = new Map();\n    mergedFrame.getObjects().forEach(object => {\n      if (mergedObjects.get(object.uid)) {\n        mergedObjects.get(object.uid).push(object);\n      } else {\n        mergedObjects.set(object.uid, [object]);\n      }\n    });\n    for (let i = 1; i < frames.length; i++) {\n      const frame = frames[i];\n      frame.getObjects().forEach(object => {\n        if (!mergedFrame.hasObject(object)) {\n          // Add object\n          mergedFrame.addObject(object);\n          mergedObjects.set(object.uid, [object]);\n        } else {\n          mergedObjects.get(object.uid).push(object);\n        }\n      });\n      // Merge properties\n      Object.keys(frame).forEach(propertyName => {\n        const value = mergedFrame[propertyName];\n        if (value === undefined || value === null) {\n          mergedFrame[propertyName] = frame[propertyName];\n        }\n      });\n    }\n    // Merge objects using the merging function\n    mergedObjects.forEach(values => {\n      const mergedObject = this.mergeObjects(values);\n      mergedFrame.addObject(mergedObject);\n    });\n    return mergedFrame;\n  }\n}","import { DataFrame } from '../../data/DataFrame';\nimport { DataFrameService, MemoryDataService } from '../../service';\nimport { BufferNode } from './BufferNode';\n/**\n * @category Flow shape\n */\nexport class MemoryBufferNode extends BufferNode {\n  constructor(options) {\n    super(options);\n    this.service = new DataFrameService(new MemoryDataService(DataFrame, {\n      serialize: d => d,\n      deserialize: d => d\n    }));\n  }\n}","import { ProcessingNode } from '../ProcessingNode';\nimport { TimeUnit } from '../../utils';\nimport { TimeService } from '../../service';\nimport { PushError } from '../../graph/events';\n/**\n * Merge data frames from two or more sources\n * using a certain merge key (e.g. source uid, parent uid, node uid).\n *\n * @category Flow shape\n */\nexport class MergeShape extends ProcessingNode {\n  constructor(mergeFn, groupFn, options) {\n    super(options);\n    this._queue = new Map();\n    this._mergeKeyFn = mergeFn;\n    this._groupFn = groupFn;\n    // Merge timeout\n    this.options.timeout = this.options.timeout || 100;\n    this.options.timeoutUnit = this.options.timeoutUnit || TimeUnit.MILLISECOND;\n    this._timeout = this.options.timeoutUnit.convert(this.options.timeout, TimeService.getUnit());\n    this.once('build', this._start.bind(this));\n    this.once('destroy', this._stop.bind(this));\n  }\n  /**\n   * Start the timeout timer\n   *\n   * @returns {Promise<void>} Timer promise\n   */\n  _start() {\n    return new Promise(resolve => {\n      this.options.minCount = this.options.minCount || this.inlets.length;\n      this.options.maxCount = this.options.maxCount || this.inlets.length;\n      const interval = this.options.checkInterval || TimeService.getUnit().convert(this._timeout, TimeUnit.MILLISECOND);\n      if (this._timeout > 0) {\n        this._timer = setInterval(this._timerTick.bind(this), interval);\n      }\n      resolve();\n    });\n  }\n  _timerTick() {\n    this._queue.forEach(queue => {\n      this._purgeQueue(queue);\n    });\n  }\n  _purgeQueue(queue) {\n    const currentTime = TimeService.now();\n    if (queue !== undefined && this._queue.has(queue.key) && currentTime - queue.timestamp >= this._timeout && queue.frames.size >= this.options.minCount) {\n      const frames = Array.from(queue.frames.values());\n      try {\n        // Merge node\n        this.outlets.forEach(outlet => outlet.push(this.merge(frames, queue.key)));\n        this._queue.delete(queue.key);\n        // Resolve pending promises\n        queue.promises.forEach(fn => {\n          fn(undefined);\n        });\n      } catch (ex) {\n        this.emit('error', new PushError(frames[0].uid, this.uid, ex));\n      }\n      return undefined;\n    } else {\n      return queue;\n    }\n  }\n  _stop() {\n    if (this._timer !== undefined) {\n      clearInterval(this._timer);\n    }\n  }\n  process(frame, options) {\n    return new Promise(resolve => {\n      if (this.options.maxCount === 1) {\n        return resolve(frame);\n      }\n      // Merge key(s)\n      const merge = this._mergeKeyFn(frame, options);\n      if (merge === undefined) {\n        return resolve(undefined);\n      }\n      (Array.isArray(merge) ? merge : [merge]).forEach(key => {\n        let queue = this._purgeQueue(this._queue.get(key));\n        if (queue === undefined) {\n          // Create a new queued data frame based on the key\n          queue = new QueuedMerge(key);\n          queue.promises.push(resolve);\n          // Group the frames by the grouping function\n          queue.frames.set(this._groupFn(frame, options), frame);\n          this._queue.set(key, queue);\n        } else {\n          const groupKey = this._groupFn(frame, options);\n          if (queue.frames.has(groupKey)) {\n            // Merge frames\n            queue.frames.set(groupKey, this.merge([queue.frames.get(groupKey), frame]));\n          } else {\n            queue.frames.set(groupKey, frame);\n          }\n          // Check if there are enough frames\n          if (queue.frames.size >= this.options.maxCount) {\n            this._queue.delete(key);\n            const mergedFrame = this.merge(Array.from(queue.frames.values()), key);\n            resolve(mergedFrame);\n            queue.promises.forEach(fn => {\n              fn(undefined);\n            });\n          } else {\n            queue.promises.push(resolve);\n          }\n        }\n      });\n    });\n  }\n}\n/**\n * Queued merge\n */\nclass QueuedMerge {\n  constructor(key) {\n    this.frames = new Map();\n    this.promises = [];\n    this.key = key;\n    this.timestamp = TimeService.now();\n  }\n}","import { FrameMergeNode } from './FrameMergeNode';\n/**\n * @category Flow shape\n */\nexport class ObjectMergeNode extends FrameMergeNode {\n  constructor(groupFn, options) {\n    super(frame => frame.getObjects().filter(value => this.options.objectFilter(value, frame)).map(object => object.uid), groupFn, options);\n    this.options.objectFilter = this.options.objectFilter || (() => true);\n  }\n  merge(frames) {\n    const mergedFrame = super.merge(frames);\n    mergedFrame.getObjects().filter(object => !this.options.objectFilter(object, mergedFrame)).forEach(obj => {\n      mergedFrame.removeObject(obj);\n    });\n    return mergedFrame;\n  }\n}","import { FrameMergeNode } from './FrameMergeNode';\n/**\n * Source merge node. This node merges the data frames from multiple sources into one.\n *\n * ## Usage\n * Merging is done by determining the incoming edges, once the amount of received frames from unique sources is\n * the same as the incoming edges, the frames are merged and pushed.\n *\n * It is possible to set a timeout, when this timeout is reached the frames that are received are merged and pushed.\n *\n * When frames of the same source are received they are overridden.\n *\n * @category Flow shape\n */\nexport class SourceMergeNode extends FrameMergeNode {\n  constructor(options) {\n    super(frame => {\n      if (frame.source === undefined) {\n        return null;\n      }\n      return frame.source.uid;\n    }, frame => frame.uid, options);\n  }\n}","import { MemoryBufferNode } from './MemoryBufferNode';\n/**\n * @category Flow shape\n */\nexport class ThrottleNode extends MemoryBufferNode {\n  constructor(options) {\n    super(options);\n    this._pushReady = true;\n    this.on('push', this.onThrottlePush.bind(this));\n  }\n  onThrottlePush() {\n    return this._handlePush();\n  }\n  _handlePush() {\n    return new Promise((resolve, reject) => {\n      if (this._pushReady) {\n        this._pushReady = false;\n        this.onPull().then(() => {\n          // Ready\n          this._pushReady = true;\n          return this.service.count();\n        }).then(count => {\n          if (count > 0) {\n            setTimeout(this._handlePush.bind(this), 10);\n          }\n          resolve();\n        }).catch(reject);\n      } else {\n        resolve();\n      }\n    });\n  }\n}","import { TimeService } from '../../service';\nimport { MemoryBufferNode } from './MemoryBufferNode';\n/**\n * Time synchronization node.\n *\n * @category Flow shape\n */\nexport class TimeSyncNode extends MemoryBufferNode {\n  constructor(options) {\n    super(options);\n    this.on('build', this._initTimer.bind(this));\n    this.on('destroy', this._stopTimer.bind(this));\n  }\n  _initTimer() {\n    this._timer = setInterval(() => {\n      this.triggerUpdate();\n    }, this.options.checkInterval || 100);\n  }\n  _stopTimer() {\n    clearInterval(this._timer);\n  }\n  onPush(frame, options) {\n    return new Promise((resolve, reject) => {\n      if (frame.createdTimestamp <= TimeService.now()) {\n        this.triggerUpdate().then(() => {\n          this.outlets.forEach(outlet => outlet.push(frame, options));\n          resolve();\n        }).catch(reject);\n      } else {\n        super.onPush(frame).then(() => {\n          resolve();\n        }).catch(reject);\n      }\n    });\n  }\n  triggerUpdate() {\n    return new Promise((resolve, reject) => {\n      this.shift().then(frame => {\n        if (frame) {\n          this.outlets.forEach(outlet => outlet.push(frame));\n          return this.triggerUpdate();\n        } else {\n          resolve();\n        }\n      }).then(resolve).catch(reject);\n    });\n  }\n  next() {\n    return new Promise((resolve, reject) => {\n      super.next().then(frame => {\n        if (frame && frame.createdTimestamp <= TimeService.now()) {\n          return resolve(frame);\n        }\n        resolve(undefined);\n      }).catch(reject);\n    });\n  }\n}","import { Node } from '../../Node';\nimport { TimeUnit } from '../../utils/unit';\n/**\n * @category Flow shape\n */\nexport class TimedPullNode extends Node {\n  constructor(interval, intervalUnit = TimeUnit.MILLISECOND, options) {\n    super(options);\n    this._pushFinished = true;\n    this._pullFinished = true;\n    this._interval = intervalUnit.convert(interval, TimeUnit.MILLISECOND);\n    this.options.autoStart = this.options.autoStart || true;\n    this.on('push', this._onPush.bind(this));\n    if (this.options.autoStart) {\n      this.once('build', this.start.bind(this));\n    }\n    this.once('destroy', this.stop.bind(this));\n  }\n  _onPush(frame, options) {\n    return new Promise((resolve, reject) => {\n      const pushPromises = [];\n      pushPromises.push(...this.outlets.map(outlet => outlet.push(frame, options)));\n      // Restart the timer\n      clearInterval(this._timer);\n      this._timer = setInterval(this._intervalFn.bind(this), this._interval);\n      this._pushFinished = false;\n      Promise.all(pushPromises).then(() => {\n        resolve();\n      }).catch(reject).finally(() => {\n        this._pushFinished = true;\n      });\n    });\n  }\n  _intervalFn() {\n    if (this._pushFinished && this._pullFinished || !this.options.throttlePull) {\n      this._pullFinished = true;\n      Promise.all(this.inlets.map(inlet => inlet.pull(this.options.pullOptions))).then(() => {\n        this._pullFinished = true;\n      }).catch(ex => {\n        this.logger('error', ex.message, ex);\n      });\n    }\n  }\n  /**\n   * Start the timed pull\n   *\n   * @returns {Promise<void>} Start promise\n   */\n  start() {\n    return new Promise(resolve => {\n      if (this._timer) {\n        this.stop();\n      }\n      this._timer = setInterval(this._intervalFn.bind(this), this._interval);\n      resolve();\n    });\n  }\n  stop() {\n    if (this._timer !== undefined) {\n      clearInterval(this._timer);\n      this._timer = undefined;\n    }\n  }\n}","import { ObjectProcessingNode } from '../ObjectProcessingNode';\n/**\n * This node converts the positions of data objects inside the frame\n * to another unit.\n *\n * @category Flow shape\n */\nexport class UnitConversionNode extends ObjectProcessingNode {\n  constructor(unit, options) {\n    super(options);\n    this._unit = unit;\n  }\n  processObject(object) {\n    return new Promise(resolve => {\n      const position = object.getPosition();\n      if (position && position.unit !== this._unit) {\n        position.fromVector(position.toVector3(this._unit));\n        position.unit = this._unit;\n        object.setPosition(position);\n      }\n      resolve(object);\n    });\n  }\n}","export * from './BalanceNode';\nexport * from './MemoryBufferNode';\nexport * from './TimedPullNode';\nexport * from './SourceMergeNode';\nexport * from './FrameMergeNode';\nexport * from './ObjectMergeNode';\nexport * from './FrameFilterNode';\nexport * from './FrameFlattenNode';\nexport * from './FrameChunkNode';\nexport * from './UnitConversionNode';\nexport * from './ThrottleNode';\nexport * from './FrameCloneNode';\nexport * from './MergeShape';\nexport * from './TimeSyncNode';\nexport * from './BufferNode';\nexport * from './FrameDelayNode';","import { SinkNode } from '../SinkNode';\n/**\n * @category Sink node\n */\nexport class CallbackSinkNode extends SinkNode {\n  constructor(callback = () => null, options) {\n    super(options);\n    this.callback = callback;\n  }\n  onPush(frame, options) {\n    return new Promise((resolve, reject) => {\n      Promise.resolve(this.callback(frame, options)).then(resolve).catch(reject);\n    });\n  }\n}","import { CallbackSinkNode } from './CallbackSinkNode';\n/**\n * This sink node will serialize the data frames pushed to this\n * output layer, and log them to the console using the logging function\n * specified in the constructor.\n *\n * @category Sink node\n */\nexport class LoggingSinkNode extends CallbackSinkNode {\n  /**\n   * Create a new logger output sink\n   *\n   * @param {Function} loggingFn Logging function\n   * @param {SinkNodeOptions} options Sink node options\n   */\n  constructor(loggingFn, options) {\n    super(loggingFn, options);\n    if (loggingFn === undefined) {\n      this.callback = frame => {\n        this.logger('debug', `Received a data frame in node ${this.uid}`, frame);\n      };\n    }\n  }\n}","import { RemoteNode } from '../RemoteNode';\nimport { SinkNode } from '../SinkNode';\nimport { Edge } from '../../graph/Edge';\n/**\n * Remote sink node\n */\nexport class RemoteSinkNode extends SinkNode {\n  constructor(options) {\n    var _a;\n    super(options);\n    this.remoteNode = new ((_a = options.type) !== null && _a !== void 0 ? _a : RemoteNode)(options, this);\n    this.uid = `${this.uid}-sink`;\n    this.once('build', this._onRemoteBuild.bind(this));\n    this.once('destroy', this._onRemoteDestroy.bind(this));\n  }\n  _onRemoteBuild(graphBuilder) {\n    this.remoteNode.graph = this.graph;\n    graphBuilder.addNode(this.remoteNode);\n    graphBuilder.addEdge(new Edge(this, this.remoteNode));\n    return this.remoteNode.emitAsync('build', graphBuilder);\n  }\n  _onRemoteDestroy() {\n    return this.remoteNode.emitAsync('destroy');\n  }\n  onPush(data, options) {\n    // Force push to remote node, sink nodes do not push by default\n    return this.remoteNode.push(data, options);\n  }\n}","export * from './LoggingSinkNode';\nexport * from './CallbackSinkNode';\nexport * from './RemoteSinkNode';","import { SourceNode } from '../SourceNode';\n/**\n * @category Source node\n */\nexport class CallbackSourceNode extends SourceNode {\n  constructor(callback = () => null, options) {\n    super(options);\n    this.callback = callback;\n  }\n  onPull(options) {\n    return new Promise((resolve, reject) => {\n      Promise.resolve(this.callback(options)).then(output => {\n        resolve(output);\n      }).catch(reject);\n    });\n  }\n}","import { DataObject } from '../../data';\nimport { DataFrame } from '../../data/DataFrame';\nimport { SourceNode } from '../SourceNode';\n/**\n * @category Source node\n */\nexport class HistorySourceNode extends SourceNode {\n  constructor(options) {\n    super(options);\n  }\n  onPull(options = {\n    requestedObjects: []\n  }) {\n    return new Promise((resolve, reject) => {\n      const service = this.model.findDataService(DataObject);\n      const requestPromises = [];\n      options.requestedObjects.forEach(uid => {\n        requestPromises.push(new Promise(resolve => {\n          service.findByUID(uid).then(object => {\n            resolve(object);\n          }).catch(() => {\n            // Ignore\n            resolve(undefined);\n          });\n        }));\n      });\n      // Complete service requests\n      Promise.all(requestPromises).then(objects => {\n        // Create a new dataframe from these objects\n        const frame = new DataFrame(this.source);\n        objects.forEach(object => {\n          if (object) {\n            frame.addObject(object);\n          }\n        });\n        resolve(frame);\n      }).catch(reject);\n    });\n  }\n}","import { SourceNode } from '../SourceNode';\n/**\n * This source node is initialized with an array of data. This data\n * is popped when pulling from this node.\n *\n * @category Source node\n */\nexport class ListSourceNode extends SourceNode {\n  constructor(inputData, options) {\n    super(options);\n    this._inputData = [];\n    this._inputData = inputData;\n  }\n  get inputData() {\n    return this._inputData;\n  }\n  set inputData(inputData) {\n    this._inputData = inputData;\n  }\n  get size() {\n    return this._inputData.length;\n  }\n  onPull() {\n    return new Promise(resolve => {\n      if (this._inputData.length !== 0) {\n        resolve(this._inputData.shift());\n      }\n      resolve(null);\n    });\n  }\n}","import { RemoteNode } from '../RemoteNode';\nimport { Edge } from '../../graph/Edge';\nimport { SourceNode } from '../SourceNode';\n/**\n * Remote source node\n */\nexport class RemoteSourceNode extends SourceNode {\n  constructor(options) {\n    var _a;\n    super(options);\n    this.remoteNode = new ((_a = options.type) !== null && _a !== void 0 ? _a : RemoteNode)(options, this);\n    this.uid = `${this.uid}-source`;\n    this.once('build', this._onRemoteBuild.bind(this));\n    this.on('error', this._onDownstreamError.bind(this));\n    this.on('completed', this._onDownstreamCompleted.bind(this));\n  }\n  _onRemoteBuild(graphBuilder) {\n    // Add a remote node before this node\n    this.remoteNode.graph = this.graph;\n    graphBuilder.addNode(this.remoteNode);\n    graphBuilder.addEdge(new Edge(this.remoteNode, this));\n    return this.remoteNode.emitAsync('build', graphBuilder);\n  }\n  onPull() {\n    return new Promise((resolve, reject) => {\n      this.remoteNode.pull().then(() => {\n        resolve(undefined);\n      }).catch(reject);\n    });\n  }\n  _onDownstreamError(error) {\n    this.remoteNode.emit('error', error);\n  }\n  _onDownstreamCompleted(event) {\n    this.remoteNode.emit('completed', event);\n  }\n}","export * from './ListSourceNode';\nexport * from './CallbackSourceNode';\nexport * from './HistorySourceNode';\nexport * from './RemoteSourceNode';","import { DataObject } from '../data';\nimport { DataService } from './DataService';\n/**\n * The data frame service manages storage of complete data frames.\n */\nexport class DataFrameService extends DataService {\n  constructor(dataServiceDriver) {\n    super(dataServiceDriver);\n  }\n  /**\n   * Insert a new data frame\n   *\n   * @param {DataFrame} frame Data frame to insert\n   * @returns {DataFrame} Inserted frame\n   */\n  insertFrame(frame) {\n    return this.insert(frame.uid, frame);\n  }\n  /**\n   * Find data frames created before a certain timestamp\n   *\n   * @param {number} timestamp Timestamp\n   * @param {FindOptions} [options] Find options\n   * @returns {DataFrame[]} Array of data frames before the specified timestamp\n   */\n  findBefore(timestamp, options) {\n    return this._findTimestamp({\n      $lte: timestamp\n    }, options);\n  }\n  /**\n   * Find data frames created after a certain timestamp\n   *\n   * @param {number} timestamp Timestamp\n   * @param {FindOptions} [options] Find options\n   * @returns {DataFrame[]} Array of data frames after the specified timestamp\n   */\n  findAfter(timestamp, options) {\n    return this._findTimestamp({\n      $gte: timestamp\n    }, options);\n  }\n  /**\n   * Find data frames by data object\n   *\n   * @param {DataObject | string} dataObject Data object to get frames for\n   * @param {FindOptions} [options] Find options. By default sorted by createdTimestamp in descending order\n   * @returns {DataFrame[]} Array of data frames that contain the specified object\n   */\n  findByDataObject(dataObject, options) {\n    return this.findAll({\n      objects: {\n        $elemMatch: {\n          uid: dataObject instanceof DataObject ? dataObject.uid : dataObject\n        }\n      }\n    }, options || {\n      sort: [['createdTimestamp', -1]]\n    });\n  }\n  _findTimestamp(timestampFilter, options) {\n    return this.findAll({\n      createdTimestamp: timestampFilter\n    }, options);\n  }\n}","import { Absolute3DPosition } from '../data';\nimport { DataService } from './DataService';\n/**\n * The object service manages the data of objects that are currently being\n * processed in the model and objects that need to be tracked.\n */\nexport class DataObjectService extends DataService {\n  constructor(dataServiceDriver) {\n    super(dataServiceDriver);\n  }\n  /**\n   * Insert a new data object\n   *\n   * @param {DataObject} object Data object to insert\n   * @returns {DataObject} Inserted object\n   */\n  insertObject(object) {\n    return this.insert(object.uid, object);\n  }\n  insert(id, object) {\n    return new Promise((resolve, reject) => {\n      this.driver.insert(id, object).then(obj => {\n        resolve(obj);\n      }).catch(reject);\n    });\n  }\n  /**\n   * Find a data object by its display name\n   *\n   * @param {string} displayName Name to search for\n   * @returns {DataObject[]} Array of data objects that match the display name\n   */\n  findByDisplayName(displayName) {\n    return this.findAll({\n      displayName\n    });\n  }\n  /**\n   * Find a data object by its current absolute position\n   *\n   * @param {AbsolutePosition} position Current absolute position\n   * @returns {DataObject[]} Array of data objects that match the position\n   */\n  findByPosition(position) {\n    const vector = position.toVector3();\n    let filter;\n    if (position instanceof Absolute3DPosition) {\n      filter = {\n        'position.x': vector.x,\n        'position.y': vector.y,\n        'position.z': vector.z\n      };\n    } else {\n      filter = {\n        'position.x': vector.x,\n        'position.y': vector.y\n      };\n    }\n    return this.findAll(filter);\n  }\n  /**\n   * Find all data objects with a parent UID\n   *\n   * @param {string} parentUID string Parent UID\n   * @returns {DataObject[]} Array of data objects that match the parent UID\n   */\n  findByParentUID(parentUID) {\n    return this.findAll({\n      parentUID\n    });\n  }\n  /**\n   * Find data objects created before a certain timestamp\n   *\n   * @param {number} timestamp Timestamp\n   * @returns {DataObject[]} Array of data objects before the specified timestamp\n   */\n  findBefore(timestamp) {\n    return this._findTimestamp({\n      $lte: timestamp\n    });\n  }\n  /**\n   * Find data objects created after a certain timestamp\n   *\n   * @param {number} timestamp Timestamp\n   * @returns {DataObject[]} Array of data objects after the specified timestamp\n   */\n  findAfter(timestamp) {\n    return this._findTimestamp({\n      $gte: timestamp\n    });\n  }\n  _findTimestamp(timestampFilter) {\n    return this.findAll({\n      createdTimestamp: timestampFilter\n    });\n  }\n}","import { __decorate, __metadata } from \"tslib\";\nimport { SerializableMember, SerializableObject } from '../data/decorators';\nimport { DataServiceDriver } from './DataServiceDriver';\nimport { Service } from './Service';\n/**\n * DataService\n *\n * ## Usage\n *\n * ### Finding a DataService\n * ```typescript\n * import { Node, DataFrame } from '@openhps/core';\n *\n * export class CustomNode extends Node<DataFrame> {\n *     // Data services can be found in any function inside a node\n *     // that is added to a model\n *     functionInsideNode(): void {\n *         // Get a service by its type\n *         let service = this.model.findDataService(DataObject);\n *         let service = this.model.findDataServiceByName(\"DataObject\");\n *     }\n * }\n * ```\n */\nlet DataService = class DataService extends Service {\n  constructor(dataServiceDriver) {\n    super();\n    this.priority = -1;\n    this.driver = dataServiceDriver;\n    if (this.driver) {\n      this.uid = this.driver.dataType.name;\n    }\n    this.once('build', this._buildDriver.bind(this));\n    this.once('destroy', () => this.driver.emitAsync('destroy'));\n  }\n  _buildDriver() {\n    return new Promise((resolve, reject) => {\n      this.driver.model = this.model;\n      this.driver.emitAsync('build').then(resolve).catch(reject);\n    });\n  }\n  get dataType() {\n    if (this.driver) {\n      return this.driver.dataType;\n    }\n    return undefined;\n  }\n  /**\n   * Set the priority of the data service\n   * a higher number means a higher priority.\n   *\n   * @param {number} value Priority value\n   * @returns {DataService} data service instance\n   */\n  setPriority(value) {\n    this.priority = value;\n    return this;\n  }\n  findByUID(uid) {\n    return this.driver.findByUID(uid);\n  }\n  findOne(query, options) {\n    return this.driver.findOne(query, options);\n  }\n  findAll(query, options) {\n    return this.driver.findAll(query, options);\n  }\n  insert(id, object) {\n    return this.driver.insert(id, object);\n  }\n  count(query) {\n    return this.driver.count(query);\n  }\n  delete(id) {\n    return this.driver.delete(id);\n  }\n  deleteAll(filter) {\n    return this.driver.deleteAll(filter);\n  }\n};\n__decorate([SerializableMember(), __metadata(\"design:type\", DataServiceDriver)], DataService.prototype, \"driver\", void 0);\n__decorate([SerializableMember(), __metadata(\"design:type\", Object)], DataService.prototype, \"priority\", void 0);\nDataService = __decorate([SerializableObject(), __metadata(\"design:paramtypes\", [DataServiceDriver])], DataService);\nexport { DataService };","import { __decorate, __metadata } from \"tslib\";\nimport { Service } from './Service';\nimport { DataSerializer } from '../data/DataSerializer';\nimport { SerializableMember, SerializableObject } from '../data/decorators';\n/**\n * DataService driver for storing and querying data objects\n * of a specific data type using a certain implementation.\n */\nlet DataServiceDriver = class DataServiceDriver extends Service {\n  constructor(dataType, options = {}) {\n    super();\n    this.options = options;\n    this.options.serialize = this.options.serialize || (obj => DataSerializer.serialize(obj));\n    this.options.deserialize = this.options.deserialize || (obj => DataSerializer.deserialize(obj));\n    if (dataType) {\n      this.uid = dataType.name;\n      this.dataType = dataType;\n    }\n  }\n};\n__decorate([SerializableMember({\n  serializer: dataType => dataType.name,\n  deserializer: dataTypeString => DataSerializer.findTypeByName(dataTypeString)\n}), __metadata(\"design:type\", Object)], DataServiceDriver.prototype, \"dataType\", void 0);\n__decorate([SerializableMember(), __metadata(\"design:type\", Object)], DataServiceDriver.prototype, \"options\", void 0);\nDataServiceDriver = __decorate([SerializableObject(), __metadata(\"design:paramtypes\", [Object, Object])], DataServiceDriver);\nexport { DataServiceDriver };","import { DataService } from './DataService';\nexport class DummyDataService extends DataService {\n  constructor(uid, dataType) {\n    super(undefined);\n    this.uid = uid;\n    this._dataType = dataType;\n  }\n  get dataType() {\n    return this._dataType;\n  }\n}","import { Service } from './Service';\nexport class DummyService extends Service {\n  constructor(uid) {\n    super();\n    this.uid = uid;\n  }\n}","import { DataService } from './DataService';\nimport { MemoryDataService } from './MemoryDataService';\n/**\n * Basic key value data service. This data service can be used to communicate\n * between workers and the main thread.\n */\nexport class KeyValueDataService extends DataService {\n  constructor(uid, dataServiceDriver) {\n    super(dataServiceDriver);\n    if (!dataServiceDriver) {\n      this.driver = new MemoryDataService(Object, {\n        serialize: d => d,\n        deserialize: d => d\n      });\n      this.driver.dataType = Object;\n    }\n    this.uid = uid || this.constructor.name;\n  }\n  /**\n   * Get the value of a key\n   *\n   * @param {string} key Key\n   * @returns {Promise<any>} Promise of the value\n   */\n  getValue(key) {\n    return this.findByUID(key);\n  }\n  /**\n   * Set a value\n   *\n   * @param {string} key Key to use\n   * @param {any} value Value to store\n   * @returns {Promise<void>} Promise of setting the value\n   */\n  setValue(key, value) {\n    this.emit('set', key, value);\n    return this.insert(key, value);\n  }\n}","import { DataObject } from '../data';\nimport { TimeUnit } from '../utils';\nimport { Service } from './Service';\nimport { TimeService } from './TimeService';\n/**\n * Location-Based Service\n *\n * ## Usage\n *\n * ### Creation\n * ```typescript\n * const service = new LocationBasedService<\n *  DataObject,\n *  GeographicalPosition\n * >();\n *\n * ModelBuilder.create()\n *  .addService(service)\n *  .from()\n *  .to().build();\n * ```\n *\n * ### Getting the current position\n *\n * ### Setting the current position\n *\n * ### Watching the position of an object\n */\nexport class LocationBasedService extends Service {\n  constructor(options) {\n    super();\n    this.watchers = new Map();\n    this.watchedObjects = new Map();\n    this.watchIndex = 1;\n    this.options = options || {};\n    this.once('build', this._initLBS.bind(this));\n    this.once('destroy', this._destroy.bind(this));\n  }\n  _initLBS() {\n    // Default options\n    this.options.pullNode = this.options.pullNode || this.model.internalSink.uid;\n    this.options.dataService = this.options.dataService || DataObject;\n    this.service = this.model.findDataService(this.options.dataService);\n    this.service.on('insert', (uid, storedObject) => {\n      const watchIds = this.watchedObjects.get(uid);\n      if (watchIds) {\n        const position = storedObject.position;\n        watchIds.forEach(watchId => {\n          const watcher = this.watchers.get(watchId);\n          if (position) {\n            watcher.callback(position);\n          }\n        });\n      }\n    });\n  }\n  _destroy() {\n    Array.from(this.watchers.keys()).forEach(watcher => {\n      this.clearWatch(watcher);\n    });\n  }\n  /**\n   * Set the current position of an object\n   *\n   * @param {DataObject | string} object Data object to get the current position of or uid\n   * @param {AbsolutePosition} position Position to update\n   * @returns {Promise<void>} Promise of updating\n   */\n  setCurrentPosition(object, position) {\n    return new Promise((resolve, reject) => {\n      const uid = object instanceof DataObject ? object.uid : object;\n      this.service.findByUID(uid).then(storedObj => {\n        storedObj.setPosition(position);\n        return this.service.insertObject(storedObj);\n      }).then(() => {\n        resolve();\n      }).catch(reject);\n    });\n  }\n  /**\n   * Get the current position of a specific data object.\n   *\n   * @param {DataObject | string} object Data object to get the current position of or uid\n   * @param {GeoOptions} [options] Current position options\n   * @returns {Promise<AbsolutePosition>} Promise of latest absolute position\n   */\n  getCurrentPosition(object, options = {}) {\n    return new Promise((resolve, reject) => {\n      const maximumAge = options.maximumAge || Infinity;\n      options.timeout = options.timeout || 10000;\n      const uid = object instanceof DataObject ? object.uid : object;\n      // Force update\n      if (options.forceUpdate) {\n        this.model.findNodeByUID(this.options.pullNode).pull({\n          requestedObjects: [uid]\n        });\n        const timeout = setTimeout(() => {\n          this.clearWatch(watchId);\n          reject(new Error('Timeout error for getting current position!'));\n        }, options.timeout);\n        const watchId = this.watchPosition(object, (pos, err) => {\n          this.clearWatch(watchId);\n          clearTimeout(timeout);\n          if (err) {\n            return reject(err);\n          }\n          resolve(pos);\n        }, Object.assign(Object.assign({}, options), {\n          interval: -1,\n          forceUpdate: false\n        }));\n      } else {\n        this.service.findByUID(uid).then(storedObj => {\n          const position = storedObj.position;\n          const time = TimeService.getUnit().convert(TimeService.now(), TimeUnit.MILLISECOND);\n          if (position && position.timestamp >= time - maximumAge) {\n            // Stored position satisfies maximum age\n            resolve(position);\n          } else {\n            return this.getCurrentPosition(object, Object.assign(Object.assign({}, options), {\n              forceUpdate: true\n            }));\n          }\n        }).then(resolve).catch(reject);\n      }\n    });\n  }\n  /**\n   * Watch for position changes\n   *\n   * @param {DataObject | string} object Data object to watch for position changes for\n   * @param {(position: AbsolutePosition, err?: Error) => void} callback Callback function\n   * @param {GeoWatchOptions} [options] Watch options\n   * @returns {number} Watch number\n   */\n  watchPosition(object, callback, options = {}) {\n    var _a;\n    const uid = object instanceof DataObject ? object.uid : object;\n    const watchId = this.watchIndex++;\n    const interval = (_a = options.interval) !== null && _a !== void 0 ? _a : 1000;\n    const timer = interval !== -1 ? setInterval(() => {\n      this.getCurrentPosition(object, options).then(callback).catch(ex => {\n        callback(undefined, ex);\n      });\n    }, interval) : undefined;\n    this.watchers.set(watchId, {\n      timer,\n      uid,\n      callback\n    });\n    this.watchObject(uid, watchId);\n    return watchId;\n  }\n  watchObject(uid, watchId) {\n    var _a;\n    const existingIds = (_a = this.watchedObjects.get(uid)) !== null && _a !== void 0 ? _a : [];\n    existingIds.push(watchId);\n    this.watchedObjects.set(uid, existingIds);\n  }\n  unwatchObject(uid, watchId) {\n    var _a;\n    const existingIds = (_a = this.watchedObjects.get(uid)) !== null && _a !== void 0 ? _a : [];\n    existingIds.splice(existingIds.indexOf(watchId), 1);\n    if (existingIds.length === 0) {\n      this.watchedObjects.delete(uid);\n    } else {\n      this.watchedObjects.set(uid, existingIds);\n    }\n  }\n  /**\n   * Clear a running position watch\n   *\n   * @param {number} watchId Watch identifier\n   */\n  clearWatch(watchId) {\n    const watcher = this.watchers.get(watchId);\n    if (watcher.timer !== undefined) {\n      clearInterval(watcher.timer);\n    }\n    this.watchers.delete(watchId);\n    this.unwatchObject(watcher.uid, watchId);\n  }\n}","import { DataServiceDriver } from './DataServiceDriver';\nimport { MemoryQueryEvaluator } from './MemoryQueryEvaluator';\nexport class MemoryDataService extends DataServiceDriver {\n  constructor(dataType, options) {\n    super(dataType, options);\n    this._data = new Map();\n  }\n  findByUID(uid) {\n    return new Promise((resolve, reject) => {\n      if (this._data.has(uid)) {\n        resolve(this.options.deserialize(this._data.get(uid)));\n      } else {\n        reject(`${this.dataType.name} with identifier #${uid} not found!`);\n      }\n    });\n  }\n  findOne(query, options = {}) {\n    return new Promise((resolve, reject) => {\n      this.findAll(query, {\n        limit: 1,\n        sort: options.sort\n      }).then(results => {\n        if (results.length > 0) {\n          return resolve(results[0]);\n        } else {\n          resolve(undefined);\n        }\n      }).catch(reject);\n    });\n  }\n  findAll(query, options = {}) {\n    return new Promise(resolve => {\n      options.limit = options.limit || this._data.size;\n      let data = [];\n      this._data.forEach(object => {\n        if (MemoryQueryEvaluator.evaluate(object, query)) {\n          data.push(object);\n          if (!options.sort && data.length >= options.limit) {\n            return;\n          }\n        }\n      });\n      if (options.sort) {\n        data = data.sort((a, b) => options.sort.map(s => {\n          const res1 = MemoryQueryEvaluator.getValueFromPath(s[1] > 0 ? a : b, s[0])[1];\n          const res2 = MemoryQueryEvaluator.getValueFromPath(s[1] > 0 ? b : a, s[0])[1];\n          if (typeof res1 === 'number') {\n            return res1 - res2;\n          } else if (typeof res1 === 'string') {\n            return res1.localeCompare(res2);\n          } else {\n            return 0;\n          }\n        }).reduce((a, b) => a + b)).slice(0, options.limit);\n      }\n      data = data.map(this.options.deserialize);\n      resolve(data);\n    });\n  }\n  insert(id, object) {\n    return new Promise(resolve => {\n      if (id && object) {\n        this._data.set(id, this.options.serialize(object));\n        resolve(object);\n      } else {\n        resolve(undefined);\n      }\n    });\n  }\n  delete(id) {\n    return new Promise((resolve, reject) => {\n      if (this._data.has(id)) {\n        this._data.delete(id);\n        resolve();\n      } else {\n        reject(`Unable to delete! ${this.dataType.name} with identifier #${id} not found!`);\n      }\n    });\n  }\n  count(filter) {\n    return new Promise(resolve => {\n      if (filter === undefined) {\n        resolve(this._data.size);\n      } else {\n        let count = 0;\n        for (const [, value] of this._data) {\n          if (MemoryQueryEvaluator.evaluate(value, filter)) {\n            count++;\n          }\n        }\n        resolve(count);\n      }\n    });\n  }\n  deleteAll(filter) {\n    return new Promise(resolve => {\n      if (filter === undefined) {\n        this._data = new Map();\n      } else {\n        for (const [key, value] of this._data) {\n          if (MemoryQueryEvaluator.evaluate(value, filter)) {\n            this.delete(key);\n          }\n        }\n      }\n      resolve();\n    });\n  }\n}","/**\n * Query evaluator for {@link FilterQuery}s with {@link MemoryDataService}.\n */\nexport class MemoryQueryEvaluator {\n  static isRegexQuery(query) {\n    return Object.prototype.toString.call(query) === '[object RegExp]';\n  }\n  static evaluateComponent(object, key, query) {\n    let result = true;\n    const value = object[key];\n    if (key.startsWith('$')) {\n      result = result && MemoryQueryEvaluator.evaluateOp(key, object, query);\n    } else if (key.includes('.')) {\n      result = result && MemoryQueryEvaluator.evaluatePath(object, key, query);\n    } else if (MemoryQueryEvaluator.isRegexQuery(query)) {\n      result = result && value.match(query) ? true : false;\n    } else if (typeof query === 'object') {\n      result = result && MemoryQueryEvaluator.evaluateSelector(value, query);\n    } else {\n      result = result && value === query;\n    }\n    return result;\n  }\n  static evaluate(object, query) {\n    let result = true;\n    if (query) {\n      for (const key of Object.keys(query)) {\n        result = result && MemoryQueryEvaluator.evaluateComponent(object, key, query[key]);\n      }\n    }\n    return result;\n  }\n  static getValueFromPath(object, path) {\n    // https://stackoverflow.com/questions/6491463/accessing-nested-javascript-objects-and-arays-by-string-path\n    let o = object;\n    path = path.replace(/\\[(\\w+)\\]/g, '.$1'); // convert indexes to properties\n    path = path.replace(/^\\./, ''); // strip a leading dot\n    const a = path.split('.');\n    for (let i = 0, n = a.length; i < n; ++i) {\n      const k = a[i];\n      if (!o) {\n        return undefined;\n      } else if (k in o) {\n        if (i < n - 1) {\n          o = o[k];\n        } else {\n          return [o, o[k], k];\n        }\n      } else {\n        return undefined;\n      }\n    }\n  }\n  static evaluatePath(object, path, query) {\n    const data = MemoryQueryEvaluator.getValueFromPath(object, path);\n    if (!data) {\n      return false;\n    }\n    return MemoryQueryEvaluator.evaluateComponent(data[0], data[2], query);\n  }\n  static evaluateSelector(value, subquery) {\n    let result = true;\n    for (const selector of Object.keys(subquery)) {\n      result = result && MemoryQueryEvaluator.evaluateComparisonSelector(selector, value, subquery);\n      result = result && MemoryQueryEvaluator.evaluateArraySelector(selector, value, subquery);\n    }\n    return result;\n  }\n  static evaluateComparisonSelector(selector, value, subquery) {\n    let result = true;\n    switch (selector) {\n      case '$gt':\n        result = result && value > subquery[selector];\n        break;\n      case '$gte':\n        result = result && value >= subquery[selector];\n        break;\n      case '$lt':\n        result = result && value < subquery[selector];\n        break;\n      case '$lte':\n        result = result && value <= subquery[selector];\n        break;\n      case '$eq':\n        result = result && value === subquery[selector];\n        break;\n    }\n    return result;\n  }\n  static evaluateArraySelector(selector, value, subquery) {\n    let result = true;\n    switch (selector) {\n      case '$in':\n        result = result && Array.from(value).includes(subquery[selector]);\n        break;\n      case '$nin':\n        result = result && !Array.from(value).includes(subquery[selector]);\n        break;\n      case '$elemMatch':\n        result = false;\n        if (value instanceof Array) {\n          Array.from(value).forEach(element => {\n            if (element['key'] && element['value']) {\n              result = result || MemoryQueryEvaluator.evaluate(element['value'], subquery[selector]);\n            } else {\n              result = result || MemoryQueryEvaluator.evaluate(element, subquery[selector]);\n            }\n          });\n        } else if (value instanceof Map) {\n          value.forEach(element => {\n            result = result || MemoryQueryEvaluator.evaluate(element, subquery[selector]);\n          });\n        }\n        result = result && result;\n        break;\n    }\n    return result;\n  }\n  static evaluateOp(key, object, subquery) {\n    let result;\n    switch (key) {\n      case '$and':\n        result = true;\n        for (const query of subquery) {\n          result = result && MemoryQueryEvaluator.evaluate(object, query);\n        }\n        break;\n      case '$or':\n        result = false;\n        for (const query of subquery) {\n          result = result || MemoryQueryEvaluator.evaluate(object, query);\n        }\n        break;\n    }\n    return result;\n  }\n}","import { __decorate, __metadata } from \"tslib\";\nimport { SerializableMember, SerializableObject } from '../data/decorators';\nimport { DataService } from './DataService';\nimport { v5 as uuidv5 } from 'uuid';\nexport class NodeDataService extends DataService {\n  /**\n   * Find node data\n   *\n   * @param {string} nodeUID Node identifier\n   * @param {DataObject} dataObject Data object to get node data for\n   * @returns {Promise<any>} Promise of node data for data object\n   */\n  findData(nodeUID, dataObject) {\n    return new Promise(resolve => {\n      this.findByUID(this.getUID(nodeUID, typeof dataObject === 'string' ? dataObject : dataObject.uid)).then(nodeData => {\n        resolve(nodeData.data);\n      }).catch(() => {\n        resolve(undefined);\n      });\n    });\n  }\n  insertData(nodeUID, dataObject, data) {\n    const uid = this.getUID(nodeUID, typeof dataObject === 'string' ? dataObject : dataObject.uid);\n    return this.insert(uid, new NodeData(uid, data));\n  }\n  getUID(nodeUID, dataObjectUID) {\n    return uuidv5(dataObjectUID + nodeUID, '97b9cc7e-19ca-4f20-8190-161d7b39e93a');\n  }\n}\nlet NodeData = class NodeData {\n  constructor(uid, data = {}) {\n    this.uid = uid;\n    this.data = data;\n  }\n};\n__decorate([SerializableMember(), __metadata(\"design:type\", String)], NodeData.prototype, \"uid\", void 0);\n__decorate([SerializableMember({\n  serializer: data => {\n    return data;\n  },\n  deserializer: json => {\n    return json;\n  }\n}), __metadata(\"design:type\", Object)], NodeData.prototype, \"data\", void 0);\nNodeData = __decorate([SerializableObject(), __metadata(\"design:paramtypes\", [String, Object])], NodeData);\nexport { NodeData };","import { __decorate, __metadata } from \"tslib\";\nimport { Node } from '../Node';\nimport { Service } from './Service';\nimport { SerializableObject } from '../data/decorators';\n/**\n * Remote node service\n */\nlet RemoteService = class RemoteService extends Service {\n  constructor() {\n    super();\n    this.nodes = new Set();\n    this.localServices = new Set();\n    this.remoteServices = new Set();\n    this.promises = new Map();\n    this.once('build', this._registerServices.bind(this));\n  }\n  _registerServices() {\n    return new Promise(resolve => {\n      if (!this.model) {\n        return resolve(); // No services to add when not added to model\n      }\n\n      this.model.once('ready', () => {\n        // Only register services after the model is ready\n        // this is why we resolve the promise before this is completed\n        this.model.findAllServices().forEach(service => {\n          this.registerService(service);\n        });\n      });\n      resolve();\n    });\n  }\n  registerPromise(resolve, reject, id) {\n    const uuid = id !== null && id !== void 0 ? id : this.generateUUID();\n    this.promises.set(uuid, {\n      resolve,\n      reject\n    });\n    return uuid;\n  }\n  getPromise(uuid) {\n    const promise = this.promises.get(uuid);\n    if (promise) {\n      this.promises.delete(uuid);\n    }\n    return promise;\n  }\n  /**\n   * Local positioning model push\n   *\n   * @param {string} uid UID of the node\n   * @param {DataFrame | any} frame Data frame\n   * @param {RemotePushOptions} options Push options\n   */\n  localPush(uid, frame, options) {\n    options = options || {};\n    if (this.nodes.has(uid)) {\n      // Parse frame and options\n      const node = this.model.findNodeByUID(uid);\n      node.emit('localpush', frame, options);\n    }\n  }\n  /**\n   * Local positioning model pull\n   *\n   * @param {string} uid UID of the node\n   * @param {RemotePullOptions} options Pull options\n   */\n  localPull(uid, options) {\n    options = options || {};\n    if (this.nodes.has(uid)) {\n      this.model.findNodeByUID(uid).emit('localpull', options);\n    }\n  }\n  /**\n   * Local positioning model event\n   *\n   * @param {string} uid UID of the node\n   * @param {string} event Event name\n   * @param {any[]} [args] Argument\n   */\n  localEvent(uid, event, ...args) {\n    if (this.nodes.has(uid)) {\n      this.model.findNodeByUID(uid).emit('localevent', event, ...args);\n    }\n  }\n  /**\n   * Local service call\n   *\n   * @param {string} uid Service uid\n   * @param {string} method Method name\n   * @param {any[]} [args] optional arguments\n   * @returns {Promise<any> | any | void} service call output\n   */\n  localServiceCall(uid, method, ...args) {\n    if (this.localServices.has(uid)) {\n      const service = this.model.findService(uid) || this.model.findDataService(uid);\n      return service[method](...args);\n    }\n  }\n  /**\n   * Register a node as a remotely available node\n   *\n   * @param {Node<any, any> | string} node Node to register\n   * @returns {Promise<void>} Promise of registration\n   */\n  registerNode(node) {\n    return new Promise(resolve => {\n      const existingNode = node instanceof Node ? node : this.model.findNodeByUID(node);\n      this.nodes.add(existingNode.uid);\n      this.logger('debug', `Registered remote server node ${existingNode.uid}`);\n      resolve();\n    });\n  }\n  /**\n   * Register a service to be remotely available\n   *\n   * @param {Service} service Service to register\n   * @returns {Promise<void>} Promise of registration\n   */\n  registerService(service) {\n    return new Promise(resolve => {\n      if (!(service instanceof RemoteServiceProxy)) {\n        this.localServices.add(service.uid);\n      } else {\n        this.remoteServices.add(service.uid);\n      }\n      resolve();\n    });\n  }\n};\nRemoteService = __decorate([SerializableObject(), __metadata(\"design:paramtypes\", [])], RemoteService);\nexport { RemoteService };\nexport class RemoteServiceProxy extends Service {\n  constructor(options) {\n    super();\n    this.options = options;\n    this.uid = options.uid;\n  }\n  get(target, p) {\n    const ownResult = this[p];\n    if (ownResult) {\n      return ownResult;\n    }\n    return this.createHandler(target, p);\n  }\n  set(target, p, value) {\n    target[p] = value;\n    return true;\n  }\n  /**\n   * Create handler function for a specific property key\n   *\n   * @param {Service} target Target service\n   * @param {string|number|symbol} p Property\n   * @returns {Function} Handler function\n   */\n  createHandler(target, p) {\n    if (!this.service) {\n      this.service = target.model.findService(this.options.service);\n      if (this.service === undefined || this.service === null) {\n        return () => undefined;\n      }\n      this.service.registerService(this);\n    }\n    return (...args) => this.service.remoteServiceCall(target.uid, p, ...args);\n  }\n}","import { __decorate, __metadata } from \"tslib\";\nimport { AsyncEventEmitter } from '../_internal/AsyncEventEmitter';\nimport { v4 as uuidv4 } from 'uuid';\nimport { SerializableMember, SerializableObject } from '../data/decorators';\n/**\n * Service is accessible by each {@link Node} inside the {@link Model}\n */\nlet Service = class Service extends AsyncEventEmitter {\n  constructor() {\n    super();\n    this._ready = false;\n    this.uid = this.constructor.name;\n    this.prependOnceListener('ready', () => {\n      this._ready = true;\n    });\n  }\n  generateUUID() {\n    return uuidv4();\n  }\n  setUID(uid) {\n    this.uid = uid;\n    return this;\n  }\n  isReady() {\n    return this._ready;\n  }\n  emit(name, ...args) {\n    return super.emit(name, ...args);\n  }\n  once(name, listener) {\n    if (name === 'ready' && this.isReady()) {\n      listener();\n      return this;\n    }\n    return super.once(name, listener);\n  }\n  /**\n   * Graph logger\n   *\n   * @param {string} level Logging level\n   * @param {string} message Message\n   * @param {any} data Data to include in log\n   */\n  logger(level, message, data) {\n    if (this.model) {\n      this.model.logger(level, message, data);\n    }\n  }\n};\n__decorate([SerializableMember(), __metadata(\"design:type\", String)], Service.prototype, \"uid\", void 0);\nService = __decorate([SerializableObject(), __metadata(\"design:paramtypes\", [])], Service);\nexport { Service };","var TimeService_1;\nimport { __decorate, __metadata } from \"tslib\";\nimport { Service } from './Service';\nimport { TimeUnit } from '../utils';\nimport { SerializableMember, SerializableMemberFunction, SerializableObject } from '../data/decorators';\n/**\n * Time service for retrieving the current time.\n */\nlet TimeService = TimeService_1 = class TimeService extends Service {\n  constructor(timeCallback, unit = TimeUnit.MILLISECOND) {\n    super();\n    this._timeCallback = timeCallback;\n    this._timeUnit = unit;\n    this.uid = this.constructor.name;\n    // Specify the default time callback used by class initializers\n    if (!TimeService_1._defaultTimeCallback) {\n      TimeService_1.initialize();\n    }\n    // If time callback is undefined, use the default\n    if (!this._timeCallback) {\n      this._timeCallback = TimeService_1.now;\n      this._timeUnit = TimeService_1.getUnit();\n    } else {\n      TimeService_1._defaultTimeCallback = timeCallback;\n      TimeService_1._defaultUnit = unit;\n    }\n  }\n  get isDefault() {\n    return TimeService_1._defaultTimeCallback === this._timeCallback;\n  }\n  set isDefault(value) {\n    if (value) {\n      TimeService_1._defaultTimeCallback = this._timeCallback;\n      TimeService_1._defaultUnit = this._timeUnit;\n    }\n  }\n  static initialize() {\n    TimeService_1._defaultTimeCallback = Date.now;\n    TimeService_1._defaultUnit = TimeUnit.MILLISECOND;\n    // Specify the default time callback used by class initializers\n    try {\n      // eslint-disable-next-line\n      const microtime = require('microtime');\n      // Check if function exists, needed for webpack\n      if (microtime.now) {\n        TimeService_1._defaultTimeCallback = microtime.now;\n        TimeService_1._defaultUnit = TimeUnit.MICROSECOND;\n      }\n    } catch (ex) {\n      return;\n    }\n  }\n  /**\n   * Get the current time\n   *\n   * @returns {number} Current time\n   */\n  getTime() {\n    return this._timeCallback();\n  }\n  /**\n   * Get the time unit\n   *\n   * @returns {TimeUnit} Unit of time service\n   */\n  getUnit() {\n    return this._timeUnit;\n  }\n  /**\n   * Get the current time\n   *\n   * @returns {number} Current time in a specific unit\n   */\n  static now() {\n    if (!TimeService_1._defaultTimeCallback) {\n      TimeService_1.initialize();\n    }\n    return TimeService_1._defaultTimeCallback();\n  }\n  static getUnit() {\n    if (!TimeService_1._defaultTimeCallback) {\n      TimeService_1.initialize();\n    }\n    return TimeService_1._defaultUnit;\n  }\n};\n__decorate([SerializableMemberFunction(), __metadata(\"design:type\", Function)], TimeService.prototype, \"_timeCallback\", void 0);\n__decorate([SerializableMember(), __metadata(\"design:type\", TimeUnit)], TimeService.prototype, \"_timeUnit\", void 0);\n__decorate([SerializableMember(), __metadata(\"design:type\", Boolean), __metadata(\"design:paramtypes\", [Boolean])], TimeService.prototype, \"isDefault\", null);\nTimeService = TimeService_1 = __decorate([SerializableObject(), __metadata(\"design:paramtypes\", [Function, TimeUnit])], TimeService);\nexport { TimeService };","import { __awaiter } from \"tslib\";\nimport { DataObject } from '../data/object/DataObject';\nimport { DataService } from './DataService';\n/**\n * A trajectory service stores the position of a data object\n * in a continuous trajectory.\n */\nexport class TrajectoryService extends DataService {\n  constructor(dataServiceDriver, options) {\n    var _a;\n    super(dataServiceDriver);\n    this.options = options || {};\n    this.options.autoBind = this.options.autoBind === undefined ? true : this.options.autoBind;\n    this.options.dataService = this.options.dataService || DataObject;\n    this.options.defaultUID = (_a = this.options.defaultUID) !== null && _a !== void 0 ? _a : object => object.uid;\n    if (this.options.autoBind) {\n      this.once('build', this._bindService.bind(this));\n    }\n  }\n  _bindService() {\n    return new Promise((resolve, reject) => {\n      if (!this.model) {\n        // No model\n        return resolve();\n      }\n      const dataObjectService = this.model.findDataService(this.options.dataService);\n      if (dataObjectService) {\n        dataObjectService.on('insert', (_, object) => __awaiter(this, void 0, void 0, function* () {\n          yield this.appendPosition(object);\n        }));\n        resolve();\n      } else {\n        reject(new Error(`Data object service not found for '${this.options.dataService}'`));\n      }\n    });\n  }\n  /**\n   * Find the latest trajectory\n   *\n   * @param {DataObject | string} object Data object to get trajectories for\n   * @returns {Promise<Trajectory>} Trajectory promise if found\n   */\n  findCurrentTrajectory(object) {\n    return new Promise((resolve, reject) => {\n      this.findOne({\n        objectUID: object instanceof DataObject ? object.uid : object\n      }, {\n        sort: [['createdTimestamp', -1]]\n      }).then(resolve).catch(reject);\n    });\n  }\n  /**\n   * Find the trajectory of an object from start to end date\n   *\n   * @param {DataObject | string} object Data object to get trajectory for\n   * @param {Date | number} start Start time or date\n   * @param {Date | number} end End time or date\n   * @returns {Trajectory} Trajectory match\n   */\n  findTrajectoryByRange(object, start, end) {\n    return new Promise((resolve, reject) => {\n      this.findOne({\n        objectUID: object instanceof DataObject ? object.uid : object,\n        positions: {\n          $elemMatch: {\n            timestamp: {\n              $lte: end ? end instanceof Date ? end.getTime() : end : Number.MAX_VALUE,\n              $gte: start ? start instanceof Date ? start.getTime() : start : -1\n            }\n          }\n        }\n      }).then(trajectory => {\n        resolve(trajectory);\n      }).catch(reject);\n    });\n  }\n  /**\n   * Find all trajectories of an object\n   *\n   * @param {DataObject | string} object Data object to get trajectories for\n   * @returns {Promise<string[]>} List of trajectory UIDs\n   */\n  findTrajectories(object) {\n    return new Promise(resolve => {\n      this.findAll({\n        objectUID: object instanceof DataObject ? object.uid : object\n      }).then(trajectories => {\n        resolve(trajectories.map(trajectory => trajectory.uid));\n      });\n    });\n  }\n  /**\n   * Append a position to the trajectory service\n   *\n   * @param {DataObject} object Data object to store\n   * @param {string} uid Trajectory uid\n   * @returns {Promise<Trajectory>} Stored trajectory\n   */\n  appendPosition(object, uid) {\n    return new Promise((resolve, reject) => {\n      const position = object.getPosition();\n      if (position) {\n        Promise.resolve(uid ? this.findOne({\n          uid\n        }) : this.findCurrentTrajectory(object)).then(trajectory => {\n          if (!trajectory) {\n            trajectory = new this.driver.dataType();\n            trajectory.objectUID = object.uid;\n            trajectory.uid = uid !== null && uid !== void 0 ? uid : this.options.defaultUID(object);\n          }\n          trajectory.positions.push(object.position);\n          return this.insert(trajectory.uid, trajectory);\n        }).then(resolve).catch(reject);\n      } else {\n        return reject();\n      }\n    });\n  }\n}","import { DataSerializer } from '../data/DataSerializer';\nimport { v4 as uuidv4 } from 'uuid';\nimport { ServiceProxy } from './_internal/ServiceProxy';\n/**\n * A worker service proxy will forward function calls to an observable.\n * This observable can be a remote process or worker. It is mainly used\n * to proxy function calls from a worker thread to the main thread.\n */\nexport class WorkerServiceProxy extends ServiceProxy {\n  constructor(options) {\n    super();\n    this._promises = new Map();\n    this.options = options;\n    this.uid = options.uid;\n    if (this.options.responseObservable) {\n      this.options.responseObservable.subscribe(this._onOutput.bind(this));\n    }\n  }\n  _onOutput(next) {\n    if (this._promises.has(next.id)) {\n      const promise = this._promises.get(next.id);\n      if (next.success) {\n        if (next.result === undefined) {\n          promise.resolve();\n        } else if (Array.isArray(next.result)) {\n          const result = [];\n          next.result.forEach(r => {\n            if (r['__type']) {\n              result.push(DataSerializer.deserialize(r));\n            } else {\n              result.push(r);\n            }\n          });\n          promise.resolve(result);\n        } else {\n          if (next.result['__type']) {\n            promise.resolve(DataSerializer.deserialize(next.result));\n          } else {\n            promise.resolve(next.result);\n          }\n        }\n      } else {\n        promise.reject(next.result);\n      }\n      this._promises.delete(next.id);\n    }\n  }\n  get(target, p) {\n    const ownResult = this[p];\n    if (ownResult) {\n      return ownResult;\n    } else if (p === 'target') {\n      return target;\n    }\n    return this.createHandler(target, p);\n  }\n  /**\n   * Create handler function for a specific property key\n   *\n   * @param {Service} target Target service\n   * @param {string|number|symbol} p Property\n   * @returns {Function} Handler function\n   */\n  createHandler(target, p) {\n    return (...args) => new Promise((resolve, reject) => {\n      const uuid = uuidv4();\n      this._promises.set(uuid, {\n        resolve,\n        reject\n      });\n      const serializedArgs = [];\n      args.forEach(arg => {\n        if (DataSerializer.findTypeByName(arg.constructor.name)) {\n          serializedArgs.push(DataSerializer.serialize(arg));\n        } else {\n          serializedArgs.push(arg);\n        }\n      });\n      // Service call\n      const call = {\n        id: uuid,\n        serviceUID: this.uid,\n        method: p,\n        parameters: serializedArgs\n      };\n      if (this.options.callObservable) {\n        // Forward call to observable\n        this.options.callObservable.next(call);\n      } else {\n        // Forward call to promise\n        this.options.callFunction(call).then(response => {\n          this._onOutput(response);\n        }).catch(response => {\n          this._onOutput(response);\n        });\n      }\n    });\n  }\n}","import { ServiceProxy } from './ServiceProxy';\nexport class DataServiceProxy extends ServiceProxy {\n  get(target, p) {\n    if (p === 'dataType') {\n      return target.dataType;\n    }\n    return super.get(target, p);\n  }\n}","import { Service } from '../Service';\nexport class ServiceProxy extends Service {\n  get(target, p) {\n    if (p === 'target') {\n      return target;\n    } else if (p === 'constructor') {\n      return target.constructor;\n    } else if (typeof target[p] === 'function') {\n      return this.createHandler(target, p);\n    }\n    return target[p];\n  }\n  set(target, p, value) {\n    target[p] = value;\n    return true;\n  }\n  createHandler(target, p) {\n    const key = p;\n    return (...args) => {\n      if (key !== 'emit' && key !== 'emitAsync' && key !== 'on' && key !== 'once') {\n        target.emit(key, ...args);\n      }\n      return target[p](...args);\n    };\n  }\n}","export * from './DataObjectService';\nexport * from './Service';\nexport * from './DataServiceDriver';\nexport * from './WorkerServiceProxy';\nexport * from './TrajectoryService';\nexport * from './NodeDataService';\nexport * from './TimeService';\nexport * from './FilterQuery';\nexport * from './MemoryDataService';\nexport * from './DataService';\nexport * from './KeyValueDataService';\nexport * from './DataFrameService';\nexport * from './FindOptions';\nexport * from './LocationBasedService';\nexport * from './RemoteService';\nexport * from './MemoryQueryEvaluator';\nexport * from './DummyDataService';\nexport * from './DummyService';","import { Quaternion } from './Quaternion.js';\nimport { Matrix4 } from './Matrix4.js';\nimport { clamp } from './MathUtils.js';\nconst _matrix = /*@__PURE__*/new Matrix4();\nconst _quaternion = /*@__PURE__*/new Quaternion();\nclass Euler {\n  constructor(x = 0, y = 0, z = 0, order = Euler.DEFAULT_ORDER) {\n    this.isEuler = true;\n    this._x = x;\n    this._y = y;\n    this._z = z;\n    this._order = order;\n  }\n  get x() {\n    return this._x;\n  }\n  set x(value) {\n    this._x = value;\n    this._onChangeCallback();\n  }\n  get y() {\n    return this._y;\n  }\n  set y(value) {\n    this._y = value;\n    this._onChangeCallback();\n  }\n  get z() {\n    return this._z;\n  }\n  set z(value) {\n    this._z = value;\n    this._onChangeCallback();\n  }\n  get order() {\n    return this._order;\n  }\n  set order(value) {\n    this._order = value;\n    this._onChangeCallback();\n  }\n  set(x, y, z, order = this._order) {\n    this._x = x;\n    this._y = y;\n    this._z = z;\n    this._order = order;\n    this._onChangeCallback();\n    return this;\n  }\n  clone() {\n    return new this.constructor(this._x, this._y, this._z, this._order);\n  }\n  copy(euler) {\n    this._x = euler._x;\n    this._y = euler._y;\n    this._z = euler._z;\n    this._order = euler._order;\n    this._onChangeCallback();\n    return this;\n  }\n  setFromRotationMatrix(m, order = this._order, update = true) {\n    // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\n\n    const te = m.elements;\n    const m11 = te[0],\n      m12 = te[4],\n      m13 = te[8];\n    const m21 = te[1],\n      m22 = te[5],\n      m23 = te[9];\n    const m31 = te[2],\n      m32 = te[6],\n      m33 = te[10];\n    switch (order) {\n      case 'XYZ':\n        this._y = Math.asin(clamp(m13, -1, 1));\n        if (Math.abs(m13) < 0.9999999) {\n          this._x = Math.atan2(-m23, m33);\n          this._z = Math.atan2(-m12, m11);\n        } else {\n          this._x = Math.atan2(m32, m22);\n          this._z = 0;\n        }\n        break;\n      case 'YXZ':\n        this._x = Math.asin(-clamp(m23, -1, 1));\n        if (Math.abs(m23) < 0.9999999) {\n          this._y = Math.atan2(m13, m33);\n          this._z = Math.atan2(m21, m22);\n        } else {\n          this._y = Math.atan2(-m31, m11);\n          this._z = 0;\n        }\n        break;\n      case 'ZXY':\n        this._x = Math.asin(clamp(m32, -1, 1));\n        if (Math.abs(m32) < 0.9999999) {\n          this._y = Math.atan2(-m31, m33);\n          this._z = Math.atan2(-m12, m22);\n        } else {\n          this._y = 0;\n          this._z = Math.atan2(m21, m11);\n        }\n        break;\n      case 'ZYX':\n        this._y = Math.asin(-clamp(m31, -1, 1));\n        if (Math.abs(m31) < 0.9999999) {\n          this._x = Math.atan2(m32, m33);\n          this._z = Math.atan2(m21, m11);\n        } else {\n          this._x = 0;\n          this._z = Math.atan2(-m12, m22);\n        }\n        break;\n      case 'YZX':\n        this._z = Math.asin(clamp(m21, -1, 1));\n        if (Math.abs(m21) < 0.9999999) {\n          this._x = Math.atan2(-m23, m22);\n          this._y = Math.atan2(-m31, m11);\n        } else {\n          this._x = 0;\n          this._y = Math.atan2(m13, m33);\n        }\n        break;\n      case 'XZY':\n        this._z = Math.asin(-clamp(m12, -1, 1));\n        if (Math.abs(m12) < 0.9999999) {\n          this._x = Math.atan2(m32, m22);\n          this._y = Math.atan2(m13, m11);\n        } else {\n          this._x = Math.atan2(-m23, m33);\n          this._y = 0;\n        }\n        break;\n      default:\n        console.warn('THREE.Euler: .setFromRotationMatrix() encountered an unknown order: ' + order);\n    }\n    this._order = order;\n    if (update === true) this._onChangeCallback();\n    return this;\n  }\n  setFromQuaternion(q, order, update) {\n    _matrix.makeRotationFromQuaternion(q);\n    return this.setFromRotationMatrix(_matrix, order, update);\n  }\n  setFromVector3(v, order = this._order) {\n    return this.set(v.x, v.y, v.z, order);\n  }\n  reorder(newOrder) {\n    // WARNING: this discards revolution information -bhouston\n\n    _quaternion.setFromEuler(this);\n    return this.setFromQuaternion(_quaternion, newOrder);\n  }\n  equals(euler) {\n    return euler._x === this._x && euler._y === this._y && euler._z === this._z && euler._order === this._order;\n  }\n  fromArray(array) {\n    this._x = array[0];\n    this._y = array[1];\n    this._z = array[2];\n    if (array[3] !== undefined) this._order = array[3];\n    this._onChangeCallback();\n    return this;\n  }\n  toArray(array = [], offset = 0) {\n    array[offset] = this._x;\n    array[offset + 1] = this._y;\n    array[offset + 2] = this._z;\n    array[offset + 3] = this._order;\n    return array;\n  }\n  _onChange(callback) {\n    this._onChangeCallback = callback;\n    return this;\n  }\n  _onChangeCallback() {}\n  *[Symbol.iterator]() {\n    yield this._x;\n    yield this._y;\n    yield this._z;\n    yield this._order;\n  }\n}\nEuler.DEFAULT_ORDER = 'XYZ';\nexport { Euler };","const _lut = ['00', '01', '02', '03', '04', '05', '06', '07', '08', '09', '0a', '0b', '0c', '0d', '0e', '0f', '10', '11', '12', '13', '14', '15', '16', '17', '18', '19', '1a', '1b', '1c', '1d', '1e', '1f', '20', '21', '22', '23', '24', '25', '26', '27', '28', '29', '2a', '2b', '2c', '2d', '2e', '2f', '30', '31', '32', '33', '34', '35', '36', '37', '38', '39', '3a', '3b', '3c', '3d', '3e', '3f', '40', '41', '42', '43', '44', '45', '46', '47', '48', '49', '4a', '4b', '4c', '4d', '4e', '4f', '50', '51', '52', '53', '54', '55', '56', '57', '58', '59', '5a', '5b', '5c', '5d', '5e', '5f', '60', '61', '62', '63', '64', '65', '66', '67', '68', '69', '6a', '6b', '6c', '6d', '6e', '6f', '70', '71', '72', '73', '74', '75', '76', '77', '78', '79', '7a', '7b', '7c', '7d', '7e', '7f', '80', '81', '82', '83', '84', '85', '86', '87', '88', '89', '8a', '8b', '8c', '8d', '8e', '8f', '90', '91', '92', '93', '94', '95', '96', '97', '98', '99', '9a', '9b', '9c', '9d', '9e', '9f', 'a0', 'a1', 'a2', 'a3', 'a4', 'a5', 'a6', 'a7', 'a8', 'a9', 'aa', 'ab', 'ac', 'ad', 'ae', 'af', 'b0', 'b1', 'b2', 'b3', 'b4', 'b5', 'b6', 'b7', 'b8', 'b9', 'ba', 'bb', 'bc', 'bd', 'be', 'bf', 'c0', 'c1', 'c2', 'c3', 'c4', 'c5', 'c6', 'c7', 'c8', 'c9', 'ca', 'cb', 'cc', 'cd', 'ce', 'cf', 'd0', 'd1', 'd2', 'd3', 'd4', 'd5', 'd6', 'd7', 'd8', 'd9', 'da', 'db', 'dc', 'dd', 'de', 'df', 'e0', 'e1', 'e2', 'e3', 'e4', 'e5', 'e6', 'e7', 'e8', 'e9', 'ea', 'eb', 'ec', 'ed', 'ee', 'ef', 'f0', 'f1', 'f2', 'f3', 'f4', 'f5', 'f6', 'f7', 'f8', 'f9', 'fa', 'fb', 'fc', 'fd', 'fe', 'ff'];\nlet _seed = 1234567;\nconst DEG2RAD = Math.PI / 180;\nconst RAD2DEG = 180 / Math.PI;\n\n// http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/21963136#21963136\nfunction generateUUID() {\n  const d0 = Math.random() * 0xffffffff | 0;\n  const d1 = Math.random() * 0xffffffff | 0;\n  const d2 = Math.random() * 0xffffffff | 0;\n  const d3 = Math.random() * 0xffffffff | 0;\n  const uuid = _lut[d0 & 0xff] + _lut[d0 >> 8 & 0xff] + _lut[d0 >> 16 & 0xff] + _lut[d0 >> 24 & 0xff] + '-' + _lut[d1 & 0xff] + _lut[d1 >> 8 & 0xff] + '-' + _lut[d1 >> 16 & 0x0f | 0x40] + _lut[d1 >> 24 & 0xff] + '-' + _lut[d2 & 0x3f | 0x80] + _lut[d2 >> 8 & 0xff] + '-' + _lut[d2 >> 16 & 0xff] + _lut[d2 >> 24 & 0xff] + _lut[d3 & 0xff] + _lut[d3 >> 8 & 0xff] + _lut[d3 >> 16 & 0xff] + _lut[d3 >> 24 & 0xff];\n\n  // .toLowerCase() here flattens concatenated strings to save heap memory space.\n  return uuid.toLowerCase();\n}\nfunction clamp(value, min, max) {\n  return Math.max(min, Math.min(max, value));\n}\n\n// compute euclidean modulo of m % n\n// https://en.wikipedia.org/wiki/Modulo_operation\nfunction euclideanModulo(n, m) {\n  return (n % m + m) % m;\n}\n\n// Linear mapping from range <a1, a2> to range <b1, b2>\nfunction mapLinear(x, a1, a2, b1, b2) {\n  return b1 + (x - a1) * (b2 - b1) / (a2 - a1);\n}\n\n// https://www.gamedev.net/tutorials/programming/general-and-gameplay-programming/inverse-lerp-a-super-useful-yet-often-overlooked-function-r5230/\nfunction inverseLerp(x, y, value) {\n  if (x !== y) {\n    return (value - x) / (y - x);\n  } else {\n    return 0;\n  }\n}\n\n// https://en.wikipedia.org/wiki/Linear_interpolation\nfunction lerp(x, y, t) {\n  return (1 - t) * x + t * y;\n}\n\n// http://www.rorydriscoll.com/2016/03/07/frame-rate-independent-damping-using-lerp/\nfunction damp(x, y, lambda, dt) {\n  return lerp(x, y, 1 - Math.exp(-lambda * dt));\n}\n\n// https://www.desmos.com/calculator/vcsjnyz7x4\nfunction pingpong(x, length = 1) {\n  return length - Math.abs(euclideanModulo(x, length * 2) - length);\n}\n\n// http://en.wikipedia.org/wiki/Smoothstep\nfunction smoothstep(x, min, max) {\n  if (x <= min) return 0;\n  if (x >= max) return 1;\n  x = (x - min) / (max - min);\n  return x * x * (3 - 2 * x);\n}\nfunction smootherstep(x, min, max) {\n  if (x <= min) return 0;\n  if (x >= max) return 1;\n  x = (x - min) / (max - min);\n  return x * x * x * (x * (x * 6 - 15) + 10);\n}\n\n// Random integer from <low, high> interval\nfunction randInt(low, high) {\n  return low + Math.floor(Math.random() * (high - low + 1));\n}\n\n// Random float from <low, high> interval\nfunction randFloat(low, high) {\n  return low + Math.random() * (high - low);\n}\n\n// Random float from <-range/2, range/2> interval\nfunction randFloatSpread(range) {\n  return range * (0.5 - Math.random());\n}\n\n// Deterministic pseudo-random float in the interval [ 0, 1 ]\nfunction seededRandom(s) {\n  if (s !== undefined) _seed = s;\n\n  // Mulberry32 generator\n\n  let t = _seed += 0x6D2B79F5;\n  t = Math.imul(t ^ t >>> 15, t | 1);\n  t ^= t + Math.imul(t ^ t >>> 7, t | 61);\n  return ((t ^ t >>> 14) >>> 0) / 4294967296;\n}\nfunction degToRad(degrees) {\n  return degrees * DEG2RAD;\n}\nfunction radToDeg(radians) {\n  return radians * RAD2DEG;\n}\nfunction isPowerOfTwo(value) {\n  return (value & value - 1) === 0 && value !== 0;\n}\nfunction ceilPowerOfTwo(value) {\n  return Math.pow(2, Math.ceil(Math.log(value) / Math.LN2));\n}\nfunction floorPowerOfTwo(value) {\n  return Math.pow(2, Math.floor(Math.log(value) / Math.LN2));\n}\nfunction setQuaternionFromProperEuler(q, a, b, c, order) {\n  // Intrinsic Proper Euler Angles - see https://en.wikipedia.org/wiki/Euler_angles\n\n  // rotations are applied to the axes in the order specified by 'order'\n  // rotation by angle 'a' is applied first, then by angle 'b', then by angle 'c'\n  // angles are in radians\n\n  const cos = Math.cos;\n  const sin = Math.sin;\n  const c2 = cos(b / 2);\n  const s2 = sin(b / 2);\n  const c13 = cos((a + c) / 2);\n  const s13 = sin((a + c) / 2);\n  const c1_3 = cos((a - c) / 2);\n  const s1_3 = sin((a - c) / 2);\n  const c3_1 = cos((c - a) / 2);\n  const s3_1 = sin((c - a) / 2);\n  switch (order) {\n    case 'XYX':\n      q.set(c2 * s13, s2 * c1_3, s2 * s1_3, c2 * c13);\n      break;\n    case 'YZY':\n      q.set(s2 * s1_3, c2 * s13, s2 * c1_3, c2 * c13);\n      break;\n    case 'ZXZ':\n      q.set(s2 * c1_3, s2 * s1_3, c2 * s13, c2 * c13);\n      break;\n    case 'XZX':\n      q.set(c2 * s13, s2 * s3_1, s2 * c3_1, c2 * c13);\n      break;\n    case 'YXY':\n      q.set(s2 * c3_1, c2 * s13, s2 * s3_1, c2 * c13);\n      break;\n    case 'ZYZ':\n      q.set(s2 * s3_1, s2 * c3_1, c2 * s13, c2 * c13);\n      break;\n    default:\n      console.warn('THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: ' + order);\n  }\n}\nfunction denormalize(value, array) {\n  switch (array.constructor) {\n    case Float32Array:\n      return value;\n    case Uint16Array:\n      return value / 65535.0;\n    case Uint8Array:\n      return value / 255.0;\n    case Int16Array:\n      return Math.max(value / 32767.0, -1.0);\n    case Int8Array:\n      return Math.max(value / 127.0, -1.0);\n    default:\n      throw new Error('Invalid component type.');\n  }\n}\nfunction normalize(value, array) {\n  switch (array.constructor) {\n    case Float32Array:\n      return value;\n    case Uint16Array:\n      return Math.round(value * 65535.0);\n    case Uint8Array:\n      return Math.round(value * 255.0);\n    case Int16Array:\n      return Math.round(value * 32767.0);\n    case Int8Array:\n      return Math.round(value * 127.0);\n    default:\n      throw new Error('Invalid component type.');\n  }\n}\nexport { DEG2RAD, RAD2DEG, generateUUID, clamp, euclideanModulo, mapLinear, inverseLerp, lerp, damp, pingpong, smoothstep, smootherstep, randInt, randFloat, randFloatSpread, seededRandom, degToRad, radToDeg, isPowerOfTwo, ceilPowerOfTwo, floorPowerOfTwo, setQuaternionFromProperEuler, normalize, denormalize };","class Matrix3 {\n  constructor() {\n    Matrix3.prototype.isMatrix3 = true;\n    this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1];\n  }\n  set(n11, n12, n13, n21, n22, n23, n31, n32, n33) {\n    const te = this.elements;\n    te[0] = n11;\n    te[1] = n21;\n    te[2] = n31;\n    te[3] = n12;\n    te[4] = n22;\n    te[5] = n32;\n    te[6] = n13;\n    te[7] = n23;\n    te[8] = n33;\n    return this;\n  }\n  identity() {\n    this.set(1, 0, 0, 0, 1, 0, 0, 0, 1);\n    return this;\n  }\n  copy(m) {\n    const te = this.elements;\n    const me = m.elements;\n    te[0] = me[0];\n    te[1] = me[1];\n    te[2] = me[2];\n    te[3] = me[3];\n    te[4] = me[4];\n    te[5] = me[5];\n    te[6] = me[6];\n    te[7] = me[7];\n    te[8] = me[8];\n    return this;\n  }\n  extractBasis(xAxis, yAxis, zAxis) {\n    xAxis.setFromMatrix3Column(this, 0);\n    yAxis.setFromMatrix3Column(this, 1);\n    zAxis.setFromMatrix3Column(this, 2);\n    return this;\n  }\n  setFromMatrix4(m) {\n    const me = m.elements;\n    this.set(me[0], me[4], me[8], me[1], me[5], me[9], me[2], me[6], me[10]);\n    return this;\n  }\n  multiply(m) {\n    return this.multiplyMatrices(this, m);\n  }\n  premultiply(m) {\n    return this.multiplyMatrices(m, this);\n  }\n  multiplyMatrices(a, b) {\n    const ae = a.elements;\n    const be = b.elements;\n    const te = this.elements;\n    const a11 = ae[0],\n      a12 = ae[3],\n      a13 = ae[6];\n    const a21 = ae[1],\n      a22 = ae[4],\n      a23 = ae[7];\n    const a31 = ae[2],\n      a32 = ae[5],\n      a33 = ae[8];\n    const b11 = be[0],\n      b12 = be[3],\n      b13 = be[6];\n    const b21 = be[1],\n      b22 = be[4],\n      b23 = be[7];\n    const b31 = be[2],\n      b32 = be[5],\n      b33 = be[8];\n    te[0] = a11 * b11 + a12 * b21 + a13 * b31;\n    te[3] = a11 * b12 + a12 * b22 + a13 * b32;\n    te[6] = a11 * b13 + a12 * b23 + a13 * b33;\n    te[1] = a21 * b11 + a22 * b21 + a23 * b31;\n    te[4] = a21 * b12 + a22 * b22 + a23 * b32;\n    te[7] = a21 * b13 + a22 * b23 + a23 * b33;\n    te[2] = a31 * b11 + a32 * b21 + a33 * b31;\n    te[5] = a31 * b12 + a32 * b22 + a33 * b32;\n    te[8] = a31 * b13 + a32 * b23 + a33 * b33;\n    return this;\n  }\n  multiplyScalar(s) {\n    const te = this.elements;\n    te[0] *= s;\n    te[3] *= s;\n    te[6] *= s;\n    te[1] *= s;\n    te[4] *= s;\n    te[7] *= s;\n    te[2] *= s;\n    te[5] *= s;\n    te[8] *= s;\n    return this;\n  }\n  determinant() {\n    const te = this.elements;\n    const a = te[0],\n      b = te[1],\n      c = te[2],\n      d = te[3],\n      e = te[4],\n      f = te[5],\n      g = te[6],\n      h = te[7],\n      i = te[8];\n    return a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;\n  }\n  invert() {\n    const te = this.elements,\n      n11 = te[0],\n      n21 = te[1],\n      n31 = te[2],\n      n12 = te[3],\n      n22 = te[4],\n      n32 = te[5],\n      n13 = te[6],\n      n23 = te[7],\n      n33 = te[8],\n      t11 = n33 * n22 - n32 * n23,\n      t12 = n32 * n13 - n33 * n12,\n      t13 = n23 * n12 - n22 * n13,\n      det = n11 * t11 + n21 * t12 + n31 * t13;\n    if (det === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);\n    const detInv = 1 / det;\n    te[0] = t11 * detInv;\n    te[1] = (n31 * n23 - n33 * n21) * detInv;\n    te[2] = (n32 * n21 - n31 * n22) * detInv;\n    te[3] = t12 * detInv;\n    te[4] = (n33 * n11 - n31 * n13) * detInv;\n    te[5] = (n31 * n12 - n32 * n11) * detInv;\n    te[6] = t13 * detInv;\n    te[7] = (n21 * n13 - n23 * n11) * detInv;\n    te[8] = (n22 * n11 - n21 * n12) * detInv;\n    return this;\n  }\n  transpose() {\n    let tmp;\n    const m = this.elements;\n    tmp = m[1];\n    m[1] = m[3];\n    m[3] = tmp;\n    tmp = m[2];\n    m[2] = m[6];\n    m[6] = tmp;\n    tmp = m[5];\n    m[5] = m[7];\n    m[7] = tmp;\n    return this;\n  }\n  getNormalMatrix(matrix4) {\n    return this.setFromMatrix4(matrix4).invert().transpose();\n  }\n  transposeIntoArray(r) {\n    const m = this.elements;\n    r[0] = m[0];\n    r[1] = m[3];\n    r[2] = m[6];\n    r[3] = m[1];\n    r[4] = m[4];\n    r[5] = m[7];\n    r[6] = m[2];\n    r[7] = m[5];\n    r[8] = m[8];\n    return this;\n  }\n  setUvTransform(tx, ty, sx, sy, rotation, cx, cy) {\n    const c = Math.cos(rotation);\n    const s = Math.sin(rotation);\n    this.set(sx * c, sx * s, -sx * (c * cx + s * cy) + cx + tx, -sy * s, sy * c, -sy * (-s * cx + c * cy) + cy + ty, 0, 0, 1);\n    return this;\n  }\n\n  //\n\n  scale(sx, sy) {\n    this.premultiply(_m3.makeScale(sx, sy));\n    return this;\n  }\n  rotate(theta) {\n    this.premultiply(_m3.makeRotation(-theta));\n    return this;\n  }\n  translate(tx, ty) {\n    this.premultiply(_m3.makeTranslation(tx, ty));\n    return this;\n  }\n\n  // for 2D Transforms\n\n  makeTranslation(x, y) {\n    this.set(1, 0, x, 0, 1, y, 0, 0, 1);\n    return this;\n  }\n  makeRotation(theta) {\n    // counterclockwise\n\n    const c = Math.cos(theta);\n    const s = Math.sin(theta);\n    this.set(c, -s, 0, s, c, 0, 0, 0, 1);\n    return this;\n  }\n  makeScale(x, y) {\n    this.set(x, 0, 0, 0, y, 0, 0, 0, 1);\n    return this;\n  }\n\n  //\n\n  equals(matrix) {\n    const te = this.elements;\n    const me = matrix.elements;\n    for (let i = 0; i < 9; i++) {\n      if (te[i] !== me[i]) return false;\n    }\n    return true;\n  }\n  fromArray(array, offset = 0) {\n    for (let i = 0; i < 9; i++) {\n      this.elements[i] = array[i + offset];\n    }\n    return this;\n  }\n  toArray(array = [], offset = 0) {\n    const te = this.elements;\n    array[offset] = te[0];\n    array[offset + 1] = te[1];\n    array[offset + 2] = te[2];\n    array[offset + 3] = te[3];\n    array[offset + 4] = te[4];\n    array[offset + 5] = te[5];\n    array[offset + 6] = te[6];\n    array[offset + 7] = te[7];\n    array[offset + 8] = te[8];\n    return array;\n  }\n  clone() {\n    return new this.constructor().fromArray(this.elements);\n  }\n}\nconst _m3 = /*@__PURE__*/new Matrix3();\nexport { Matrix3 };","import { Vector3 } from './Vector3.js';\nclass Matrix4 {\n  constructor() {\n    Matrix4.prototype.isMatrix4 = true;\n    this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];\n  }\n  set(n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44) {\n    const te = this.elements;\n    te[0] = n11;\n    te[4] = n12;\n    te[8] = n13;\n    te[12] = n14;\n    te[1] = n21;\n    te[5] = n22;\n    te[9] = n23;\n    te[13] = n24;\n    te[2] = n31;\n    te[6] = n32;\n    te[10] = n33;\n    te[14] = n34;\n    te[3] = n41;\n    te[7] = n42;\n    te[11] = n43;\n    te[15] = n44;\n    return this;\n  }\n  identity() {\n    this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);\n    return this;\n  }\n  clone() {\n    return new Matrix4().fromArray(this.elements);\n  }\n  copy(m) {\n    const te = this.elements;\n    const me = m.elements;\n    te[0] = me[0];\n    te[1] = me[1];\n    te[2] = me[2];\n    te[3] = me[3];\n    te[4] = me[4];\n    te[5] = me[5];\n    te[6] = me[6];\n    te[7] = me[7];\n    te[8] = me[8];\n    te[9] = me[9];\n    te[10] = me[10];\n    te[11] = me[11];\n    te[12] = me[12];\n    te[13] = me[13];\n    te[14] = me[14];\n    te[15] = me[15];\n    return this;\n  }\n  copyPosition(m) {\n    const te = this.elements,\n      me = m.elements;\n    te[12] = me[12];\n    te[13] = me[13];\n    te[14] = me[14];\n    return this;\n  }\n  setFromMatrix3(m) {\n    const me = m.elements;\n    this.set(me[0], me[3], me[6], 0, me[1], me[4], me[7], 0, me[2], me[5], me[8], 0, 0, 0, 0, 1);\n    return this;\n  }\n  extractBasis(xAxis, yAxis, zAxis) {\n    xAxis.setFromMatrixColumn(this, 0);\n    yAxis.setFromMatrixColumn(this, 1);\n    zAxis.setFromMatrixColumn(this, 2);\n    return this;\n  }\n  makeBasis(xAxis, yAxis, zAxis) {\n    this.set(xAxis.x, yAxis.x, zAxis.x, 0, xAxis.y, yAxis.y, zAxis.y, 0, xAxis.z, yAxis.z, zAxis.z, 0, 0, 0, 0, 1);\n    return this;\n  }\n  extractRotation(m) {\n    // this method does not support reflection matrices\n\n    const te = this.elements;\n    const me = m.elements;\n    const scaleX = 1 / _v1.setFromMatrixColumn(m, 0).length();\n    const scaleY = 1 / _v1.setFromMatrixColumn(m, 1).length();\n    const scaleZ = 1 / _v1.setFromMatrixColumn(m, 2).length();\n    te[0] = me[0] * scaleX;\n    te[1] = me[1] * scaleX;\n    te[2] = me[2] * scaleX;\n    te[3] = 0;\n    te[4] = me[4] * scaleY;\n    te[5] = me[5] * scaleY;\n    te[6] = me[6] * scaleY;\n    te[7] = 0;\n    te[8] = me[8] * scaleZ;\n    te[9] = me[9] * scaleZ;\n    te[10] = me[10] * scaleZ;\n    te[11] = 0;\n    te[12] = 0;\n    te[13] = 0;\n    te[14] = 0;\n    te[15] = 1;\n    return this;\n  }\n  makeRotationFromEuler(euler) {\n    const te = this.elements;\n    const x = euler.x,\n      y = euler.y,\n      z = euler.z;\n    const a = Math.cos(x),\n      b = Math.sin(x);\n    const c = Math.cos(y),\n      d = Math.sin(y);\n    const e = Math.cos(z),\n      f = Math.sin(z);\n    if (euler.order === 'XYZ') {\n      const ae = a * e,\n        af = a * f,\n        be = b * e,\n        bf = b * f;\n      te[0] = c * e;\n      te[4] = -c * f;\n      te[8] = d;\n      te[1] = af + be * d;\n      te[5] = ae - bf * d;\n      te[9] = -b * c;\n      te[2] = bf - ae * d;\n      te[6] = be + af * d;\n      te[10] = a * c;\n    } else if (euler.order === 'YXZ') {\n      const ce = c * e,\n        cf = c * f,\n        de = d * e,\n        df = d * f;\n      te[0] = ce + df * b;\n      te[4] = de * b - cf;\n      te[8] = a * d;\n      te[1] = a * f;\n      te[5] = a * e;\n      te[9] = -b;\n      te[2] = cf * b - de;\n      te[6] = df + ce * b;\n      te[10] = a * c;\n    } else if (euler.order === 'ZXY') {\n      const ce = c * e,\n        cf = c * f,\n        de = d * e,\n        df = d * f;\n      te[0] = ce - df * b;\n      te[4] = -a * f;\n      te[8] = de + cf * b;\n      te[1] = cf + de * b;\n      te[5] = a * e;\n      te[9] = df - ce * b;\n      te[2] = -a * d;\n      te[6] = b;\n      te[10] = a * c;\n    } else if (euler.order === 'ZYX') {\n      const ae = a * e,\n        af = a * f,\n        be = b * e,\n        bf = b * f;\n      te[0] = c * e;\n      te[4] = be * d - af;\n      te[8] = ae * d + bf;\n      te[1] = c * f;\n      te[5] = bf * d + ae;\n      te[9] = af * d - be;\n      te[2] = -d;\n      te[6] = b * c;\n      te[10] = a * c;\n    } else if (euler.order === 'YZX') {\n      const ac = a * c,\n        ad = a * d,\n        bc = b * c,\n        bd = b * d;\n      te[0] = c * e;\n      te[4] = bd - ac * f;\n      te[8] = bc * f + ad;\n      te[1] = f;\n      te[5] = a * e;\n      te[9] = -b * e;\n      te[2] = -d * e;\n      te[6] = ad * f + bc;\n      te[10] = ac - bd * f;\n    } else if (euler.order === 'XZY') {\n      const ac = a * c,\n        ad = a * d,\n        bc = b * c,\n        bd = b * d;\n      te[0] = c * e;\n      te[4] = -f;\n      te[8] = d * e;\n      te[1] = ac * f + bd;\n      te[5] = a * e;\n      te[9] = ad * f - bc;\n      te[2] = bc * f - ad;\n      te[6] = b * e;\n      te[10] = bd * f + ac;\n    }\n\n    // bottom row\n    te[3] = 0;\n    te[7] = 0;\n    te[11] = 0;\n\n    // last column\n    te[12] = 0;\n    te[13] = 0;\n    te[14] = 0;\n    te[15] = 1;\n    return this;\n  }\n  makeRotationFromQuaternion(q) {\n    return this.compose(_zero, q, _one);\n  }\n  lookAt(eye, target, up) {\n    const te = this.elements;\n    _z.subVectors(eye, target);\n    if (_z.lengthSq() === 0) {\n      // eye and target are in the same position\n\n      _z.z = 1;\n    }\n    _z.normalize();\n    _x.crossVectors(up, _z);\n    if (_x.lengthSq() === 0) {\n      // up and z are parallel\n\n      if (Math.abs(up.z) === 1) {\n        _z.x += 0.0001;\n      } else {\n        _z.z += 0.0001;\n      }\n      _z.normalize();\n      _x.crossVectors(up, _z);\n    }\n    _x.normalize();\n    _y.crossVectors(_z, _x);\n    te[0] = _x.x;\n    te[4] = _y.x;\n    te[8] = _z.x;\n    te[1] = _x.y;\n    te[5] = _y.y;\n    te[9] = _z.y;\n    te[2] = _x.z;\n    te[6] = _y.z;\n    te[10] = _z.z;\n    return this;\n  }\n  multiply(m) {\n    return this.multiplyMatrices(this, m);\n  }\n  premultiply(m) {\n    return this.multiplyMatrices(m, this);\n  }\n  multiplyMatrices(a, b) {\n    const ae = a.elements;\n    const be = b.elements;\n    const te = this.elements;\n    const a11 = ae[0],\n      a12 = ae[4],\n      a13 = ae[8],\n      a14 = ae[12];\n    const a21 = ae[1],\n      a22 = ae[5],\n      a23 = ae[9],\n      a24 = ae[13];\n    const a31 = ae[2],\n      a32 = ae[6],\n      a33 = ae[10],\n      a34 = ae[14];\n    const a41 = ae[3],\n      a42 = ae[7],\n      a43 = ae[11],\n      a44 = ae[15];\n    const b11 = be[0],\n      b12 = be[4],\n      b13 = be[8],\n      b14 = be[12];\n    const b21 = be[1],\n      b22 = be[5],\n      b23 = be[9],\n      b24 = be[13];\n    const b31 = be[2],\n      b32 = be[6],\n      b33 = be[10],\n      b34 = be[14];\n    const b41 = be[3],\n      b42 = be[7],\n      b43 = be[11],\n      b44 = be[15];\n    te[0] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;\n    te[4] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;\n    te[8] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;\n    te[12] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;\n    te[1] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;\n    te[5] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;\n    te[9] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;\n    te[13] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;\n    te[2] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;\n    te[6] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;\n    te[10] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;\n    te[14] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;\n    te[3] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;\n    te[7] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;\n    te[11] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;\n    te[15] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;\n    return this;\n  }\n  multiplyScalar(s) {\n    const te = this.elements;\n    te[0] *= s;\n    te[4] *= s;\n    te[8] *= s;\n    te[12] *= s;\n    te[1] *= s;\n    te[5] *= s;\n    te[9] *= s;\n    te[13] *= s;\n    te[2] *= s;\n    te[6] *= s;\n    te[10] *= s;\n    te[14] *= s;\n    te[3] *= s;\n    te[7] *= s;\n    te[11] *= s;\n    te[15] *= s;\n    return this;\n  }\n  determinant() {\n    const te = this.elements;\n    const n11 = te[0],\n      n12 = te[4],\n      n13 = te[8],\n      n14 = te[12];\n    const n21 = te[1],\n      n22 = te[5],\n      n23 = te[9],\n      n24 = te[13];\n    const n31 = te[2],\n      n32 = te[6],\n      n33 = te[10],\n      n34 = te[14];\n    const n41 = te[3],\n      n42 = te[7],\n      n43 = te[11],\n      n44 = te[15];\n\n    //TODO: make this more efficient\n    //( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )\n\n    return n41 * (+n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34) + n42 * (+n11 * n23 * n34 - n11 * n24 * n33 + n14 * n21 * n33 - n13 * n21 * n34 + n13 * n24 * n31 - n14 * n23 * n31) + n43 * (+n11 * n24 * n32 - n11 * n22 * n34 - n14 * n21 * n32 + n12 * n21 * n34 + n14 * n22 * n31 - n12 * n24 * n31) + n44 * (-n13 * n22 * n31 - n11 * n23 * n32 + n11 * n22 * n33 + n13 * n21 * n32 - n12 * n21 * n33 + n12 * n23 * n31);\n  }\n  transpose() {\n    const te = this.elements;\n    let tmp;\n    tmp = te[1];\n    te[1] = te[4];\n    te[4] = tmp;\n    tmp = te[2];\n    te[2] = te[8];\n    te[8] = tmp;\n    tmp = te[6];\n    te[6] = te[9];\n    te[9] = tmp;\n    tmp = te[3];\n    te[3] = te[12];\n    te[12] = tmp;\n    tmp = te[7];\n    te[7] = te[13];\n    te[13] = tmp;\n    tmp = te[11];\n    te[11] = te[14];\n    te[14] = tmp;\n    return this;\n  }\n  setPosition(x, y, z) {\n    const te = this.elements;\n    if (x.isVector3) {\n      te[12] = x.x;\n      te[13] = x.y;\n      te[14] = x.z;\n    } else {\n      te[12] = x;\n      te[13] = y;\n      te[14] = z;\n    }\n    return this;\n  }\n  invert() {\n    // based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm\n    const te = this.elements,\n      n11 = te[0],\n      n21 = te[1],\n      n31 = te[2],\n      n41 = te[3],\n      n12 = te[4],\n      n22 = te[5],\n      n32 = te[6],\n      n42 = te[7],\n      n13 = te[8],\n      n23 = te[9],\n      n33 = te[10],\n      n43 = te[11],\n      n14 = te[12],\n      n24 = te[13],\n      n34 = te[14],\n      n44 = te[15],\n      t11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44,\n      t12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44,\n      t13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44,\n      t14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;\n    const det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;\n    if (det === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);\n    const detInv = 1 / det;\n    te[0] = t11 * detInv;\n    te[1] = (n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44) * detInv;\n    te[2] = (n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44) * detInv;\n    te[3] = (n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43) * detInv;\n    te[4] = t12 * detInv;\n    te[5] = (n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44) * detInv;\n    te[6] = (n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44) * detInv;\n    te[7] = (n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43) * detInv;\n    te[8] = t13 * detInv;\n    te[9] = (n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44) * detInv;\n    te[10] = (n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44) * detInv;\n    te[11] = (n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43) * detInv;\n    te[12] = t14 * detInv;\n    te[13] = (n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34) * detInv;\n    te[14] = (n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34) * detInv;\n    te[15] = (n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33) * detInv;\n    return this;\n  }\n  scale(v) {\n    const te = this.elements;\n    const x = v.x,\n      y = v.y,\n      z = v.z;\n    te[0] *= x;\n    te[4] *= y;\n    te[8] *= z;\n    te[1] *= x;\n    te[5] *= y;\n    te[9] *= z;\n    te[2] *= x;\n    te[6] *= y;\n    te[10] *= z;\n    te[3] *= x;\n    te[7] *= y;\n    te[11] *= z;\n    return this;\n  }\n  getMaxScaleOnAxis() {\n    const te = this.elements;\n    const scaleXSq = te[0] * te[0] + te[1] * te[1] + te[2] * te[2];\n    const scaleYSq = te[4] * te[4] + te[5] * te[5] + te[6] * te[6];\n    const scaleZSq = te[8] * te[8] + te[9] * te[9] + te[10] * te[10];\n    return Math.sqrt(Math.max(scaleXSq, scaleYSq, scaleZSq));\n  }\n  makeTranslation(x, y, z) {\n    this.set(1, 0, 0, x, 0, 1, 0, y, 0, 0, 1, z, 0, 0, 0, 1);\n    return this;\n  }\n  makeRotationX(theta) {\n    const c = Math.cos(theta),\n      s = Math.sin(theta);\n    this.set(1, 0, 0, 0, 0, c, -s, 0, 0, s, c, 0, 0, 0, 0, 1);\n    return this;\n  }\n  makeRotationY(theta) {\n    const c = Math.cos(theta),\n      s = Math.sin(theta);\n    this.set(c, 0, s, 0, 0, 1, 0, 0, -s, 0, c, 0, 0, 0, 0, 1);\n    return this;\n  }\n  makeRotationZ(theta) {\n    const c = Math.cos(theta),\n      s = Math.sin(theta);\n    this.set(c, -s, 0, 0, s, c, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);\n    return this;\n  }\n  makeRotationAxis(axis, angle) {\n    // Based on http://www.gamedev.net/reference/articles/article1199.asp\n\n    const c = Math.cos(angle);\n    const s = Math.sin(angle);\n    const t = 1 - c;\n    const x = axis.x,\n      y = axis.y,\n      z = axis.z;\n    const tx = t * x,\n      ty = t * y;\n    this.set(tx * x + c, tx * y - s * z, tx * z + s * y, 0, tx * y + s * z, ty * y + c, ty * z - s * x, 0, tx * z - s * y, ty * z + s * x, t * z * z + c, 0, 0, 0, 0, 1);\n    return this;\n  }\n  makeScale(x, y, z) {\n    this.set(x, 0, 0, 0, 0, y, 0, 0, 0, 0, z, 0, 0, 0, 0, 1);\n    return this;\n  }\n  makeShear(xy, xz, yx, yz, zx, zy) {\n    this.set(1, yx, zx, 0, xy, 1, zy, 0, xz, yz, 1, 0, 0, 0, 0, 1);\n    return this;\n  }\n  compose(position, quaternion, scale) {\n    const te = this.elements;\n    const x = quaternion._x,\n      y = quaternion._y,\n      z = quaternion._z,\n      w = quaternion._w;\n    const x2 = x + x,\n      y2 = y + y,\n      z2 = z + z;\n    const xx = x * x2,\n      xy = x * y2,\n      xz = x * z2;\n    const yy = y * y2,\n      yz = y * z2,\n      zz = z * z2;\n    const wx = w * x2,\n      wy = w * y2,\n      wz = w * z2;\n    const sx = scale.x,\n      sy = scale.y,\n      sz = scale.z;\n    te[0] = (1 - (yy + zz)) * sx;\n    te[1] = (xy + wz) * sx;\n    te[2] = (xz - wy) * sx;\n    te[3] = 0;\n    te[4] = (xy - wz) * sy;\n    te[5] = (1 - (xx + zz)) * sy;\n    te[6] = (yz + wx) * sy;\n    te[7] = 0;\n    te[8] = (xz + wy) * sz;\n    te[9] = (yz - wx) * sz;\n    te[10] = (1 - (xx + yy)) * sz;\n    te[11] = 0;\n    te[12] = position.x;\n    te[13] = position.y;\n    te[14] = position.z;\n    te[15] = 1;\n    return this;\n  }\n  decompose(position, quaternion, scale) {\n    const te = this.elements;\n    let sx = _v1.set(te[0], te[1], te[2]).length();\n    const sy = _v1.set(te[4], te[5], te[6]).length();\n    const sz = _v1.set(te[8], te[9], te[10]).length();\n\n    // if determine is negative, we need to invert one scale\n    const det = this.determinant();\n    if (det < 0) sx = -sx;\n    position.x = te[12];\n    position.y = te[13];\n    position.z = te[14];\n\n    // scale the rotation part\n    _m1.copy(this);\n    const invSX = 1 / sx;\n    const invSY = 1 / sy;\n    const invSZ = 1 / sz;\n    _m1.elements[0] *= invSX;\n    _m1.elements[1] *= invSX;\n    _m1.elements[2] *= invSX;\n    _m1.elements[4] *= invSY;\n    _m1.elements[5] *= invSY;\n    _m1.elements[6] *= invSY;\n    _m1.elements[8] *= invSZ;\n    _m1.elements[9] *= invSZ;\n    _m1.elements[10] *= invSZ;\n    quaternion.setFromRotationMatrix(_m1);\n    scale.x = sx;\n    scale.y = sy;\n    scale.z = sz;\n    return this;\n  }\n  makePerspective(left, right, top, bottom, near, far) {\n    const te = this.elements;\n    const x = 2 * near / (right - left);\n    const y = 2 * near / (top - bottom);\n    const a = (right + left) / (right - left);\n    const b = (top + bottom) / (top - bottom);\n    const c = -(far + near) / (far - near);\n    const d = -2 * far * near / (far - near);\n    te[0] = x;\n    te[4] = 0;\n    te[8] = a;\n    te[12] = 0;\n    te[1] = 0;\n    te[5] = y;\n    te[9] = b;\n    te[13] = 0;\n    te[2] = 0;\n    te[6] = 0;\n    te[10] = c;\n    te[14] = d;\n    te[3] = 0;\n    te[7] = 0;\n    te[11] = -1;\n    te[15] = 0;\n    return this;\n  }\n  makeOrthographic(left, right, top, bottom, near, far) {\n    const te = this.elements;\n    const w = 1.0 / (right - left);\n    const h = 1.0 / (top - bottom);\n    const p = 1.0 / (far - near);\n    const x = (right + left) * w;\n    const y = (top + bottom) * h;\n    const z = (far + near) * p;\n    te[0] = 2 * w;\n    te[4] = 0;\n    te[8] = 0;\n    te[12] = -x;\n    te[1] = 0;\n    te[5] = 2 * h;\n    te[9] = 0;\n    te[13] = -y;\n    te[2] = 0;\n    te[6] = 0;\n    te[10] = -2 * p;\n    te[14] = -z;\n    te[3] = 0;\n    te[7] = 0;\n    te[11] = 0;\n    te[15] = 1;\n    return this;\n  }\n  equals(matrix) {\n    const te = this.elements;\n    const me = matrix.elements;\n    for (let i = 0; i < 16; i++) {\n      if (te[i] !== me[i]) return false;\n    }\n    return true;\n  }\n  fromArray(array, offset = 0) {\n    for (let i = 0; i < 16; i++) {\n      this.elements[i] = array[i + offset];\n    }\n    return this;\n  }\n  toArray(array = [], offset = 0) {\n    const te = this.elements;\n    array[offset] = te[0];\n    array[offset + 1] = te[1];\n    array[offset + 2] = te[2];\n    array[offset + 3] = te[3];\n    array[offset + 4] = te[4];\n    array[offset + 5] = te[5];\n    array[offset + 6] = te[6];\n    array[offset + 7] = te[7];\n    array[offset + 8] = te[8];\n    array[offset + 9] = te[9];\n    array[offset + 10] = te[10];\n    array[offset + 11] = te[11];\n    array[offset + 12] = te[12];\n    array[offset + 13] = te[13];\n    array[offset + 14] = te[14];\n    array[offset + 15] = te[15];\n    return array;\n  }\n}\nconst _v1 = /*@__PURE__*/new Vector3();\nconst _m1 = /*@__PURE__*/new Matrix4();\nconst _zero = /*@__PURE__*/new Vector3(0, 0, 0);\nconst _one = /*@__PURE__*/new Vector3(1, 1, 1);\nconst _x = /*@__PURE__*/new Vector3();\nconst _y = /*@__PURE__*/new Vector3();\nconst _z = /*@__PURE__*/new Vector3();\nexport { Matrix4 };","import * as MathUtils from './MathUtils.js';\nclass Quaternion {\n  constructor(x = 0, y = 0, z = 0, w = 1) {\n    this.isQuaternion = true;\n    this._x = x;\n    this._y = y;\n    this._z = z;\n    this._w = w;\n  }\n  static slerpFlat(dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t) {\n    // fuzz-free, array-based Quaternion SLERP operation\n\n    let x0 = src0[srcOffset0 + 0],\n      y0 = src0[srcOffset0 + 1],\n      z0 = src0[srcOffset0 + 2],\n      w0 = src0[srcOffset0 + 3];\n    const x1 = src1[srcOffset1 + 0],\n      y1 = src1[srcOffset1 + 1],\n      z1 = src1[srcOffset1 + 2],\n      w1 = src1[srcOffset1 + 3];\n    if (t === 0) {\n      dst[dstOffset + 0] = x0;\n      dst[dstOffset + 1] = y0;\n      dst[dstOffset + 2] = z0;\n      dst[dstOffset + 3] = w0;\n      return;\n    }\n    if (t === 1) {\n      dst[dstOffset + 0] = x1;\n      dst[dstOffset + 1] = y1;\n      dst[dstOffset + 2] = z1;\n      dst[dstOffset + 3] = w1;\n      return;\n    }\n    if (w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1) {\n      let s = 1 - t;\n      const cos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1,\n        dir = cos >= 0 ? 1 : -1,\n        sqrSin = 1 - cos * cos;\n\n      // Skip the Slerp for tiny steps to avoid numeric problems:\n      if (sqrSin > Number.EPSILON) {\n        const sin = Math.sqrt(sqrSin),\n          len = Math.atan2(sin, cos * dir);\n        s = Math.sin(s * len) / sin;\n        t = Math.sin(t * len) / sin;\n      }\n      const tDir = t * dir;\n      x0 = x0 * s + x1 * tDir;\n      y0 = y0 * s + y1 * tDir;\n      z0 = z0 * s + z1 * tDir;\n      w0 = w0 * s + w1 * tDir;\n\n      // Normalize in case we just did a lerp:\n      if (s === 1 - t) {\n        const f = 1 / Math.sqrt(x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0);\n        x0 *= f;\n        y0 *= f;\n        z0 *= f;\n        w0 *= f;\n      }\n    }\n    dst[dstOffset] = x0;\n    dst[dstOffset + 1] = y0;\n    dst[dstOffset + 2] = z0;\n    dst[dstOffset + 3] = w0;\n  }\n  static multiplyQuaternionsFlat(dst, dstOffset, src0, srcOffset0, src1, srcOffset1) {\n    const x0 = src0[srcOffset0];\n    const y0 = src0[srcOffset0 + 1];\n    const z0 = src0[srcOffset0 + 2];\n    const w0 = src0[srcOffset0 + 3];\n    const x1 = src1[srcOffset1];\n    const y1 = src1[srcOffset1 + 1];\n    const z1 = src1[srcOffset1 + 2];\n    const w1 = src1[srcOffset1 + 3];\n    dst[dstOffset] = x0 * w1 + w0 * x1 + y0 * z1 - z0 * y1;\n    dst[dstOffset + 1] = y0 * w1 + w0 * y1 + z0 * x1 - x0 * z1;\n    dst[dstOffset + 2] = z0 * w1 + w0 * z1 + x0 * y1 - y0 * x1;\n    dst[dstOffset + 3] = w0 * w1 - x0 * x1 - y0 * y1 - z0 * z1;\n    return dst;\n  }\n  get x() {\n    return this._x;\n  }\n  set x(value) {\n    this._x = value;\n    this._onChangeCallback();\n  }\n  get y() {\n    return this._y;\n  }\n  set y(value) {\n    this._y = value;\n    this._onChangeCallback();\n  }\n  get z() {\n    return this._z;\n  }\n  set z(value) {\n    this._z = value;\n    this._onChangeCallback();\n  }\n  get w() {\n    return this._w;\n  }\n  set w(value) {\n    this._w = value;\n    this._onChangeCallback();\n  }\n  set(x, y, z, w) {\n    this._x = x;\n    this._y = y;\n    this._z = z;\n    this._w = w;\n    this._onChangeCallback();\n    return this;\n  }\n  clone() {\n    return new this.constructor(this._x, this._y, this._z, this._w);\n  }\n  copy(quaternion) {\n    this._x = quaternion.x;\n    this._y = quaternion.y;\n    this._z = quaternion.z;\n    this._w = quaternion.w;\n    this._onChangeCallback();\n    return this;\n  }\n  setFromEuler(euler, update) {\n    const x = euler._x,\n      y = euler._y,\n      z = euler._z,\n      order = euler._order;\n\n    // http://www.mathworks.com/matlabcentral/fileexchange/\n    // \t20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/\n    //\tcontent/SpinCalc.m\n\n    const cos = Math.cos;\n    const sin = Math.sin;\n    const c1 = cos(x / 2);\n    const c2 = cos(y / 2);\n    const c3 = cos(z / 2);\n    const s1 = sin(x / 2);\n    const s2 = sin(y / 2);\n    const s3 = sin(z / 2);\n    switch (order) {\n      case 'XYZ':\n        this._x = s1 * c2 * c3 + c1 * s2 * s3;\n        this._y = c1 * s2 * c3 - s1 * c2 * s3;\n        this._z = c1 * c2 * s3 + s1 * s2 * c3;\n        this._w = c1 * c2 * c3 - s1 * s2 * s3;\n        break;\n      case 'YXZ':\n        this._x = s1 * c2 * c3 + c1 * s2 * s3;\n        this._y = c1 * s2 * c3 - s1 * c2 * s3;\n        this._z = c1 * c2 * s3 - s1 * s2 * c3;\n        this._w = c1 * c2 * c3 + s1 * s2 * s3;\n        break;\n      case 'ZXY':\n        this._x = s1 * c2 * c3 - c1 * s2 * s3;\n        this._y = c1 * s2 * c3 + s1 * c2 * s3;\n        this._z = c1 * c2 * s3 + s1 * s2 * c3;\n        this._w = c1 * c2 * c3 - s1 * s2 * s3;\n        break;\n      case 'ZYX':\n        this._x = s1 * c2 * c3 - c1 * s2 * s3;\n        this._y = c1 * s2 * c3 + s1 * c2 * s3;\n        this._z = c1 * c2 * s3 - s1 * s2 * c3;\n        this._w = c1 * c2 * c3 + s1 * s2 * s3;\n        break;\n      case 'YZX':\n        this._x = s1 * c2 * c3 + c1 * s2 * s3;\n        this._y = c1 * s2 * c3 + s1 * c2 * s3;\n        this._z = c1 * c2 * s3 - s1 * s2 * c3;\n        this._w = c1 * c2 * c3 - s1 * s2 * s3;\n        break;\n      case 'XZY':\n        this._x = s1 * c2 * c3 - c1 * s2 * s3;\n        this._y = c1 * s2 * c3 - s1 * c2 * s3;\n        this._z = c1 * c2 * s3 + s1 * s2 * c3;\n        this._w = c1 * c2 * c3 + s1 * s2 * s3;\n        break;\n      default:\n        console.warn('THREE.Quaternion: .setFromEuler() encountered an unknown order: ' + order);\n    }\n    if (update !== false) this._onChangeCallback();\n    return this;\n  }\n  setFromAxisAngle(axis, angle) {\n    // http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm\n\n    // assumes axis is normalized\n\n    const halfAngle = angle / 2,\n      s = Math.sin(halfAngle);\n    this._x = axis.x * s;\n    this._y = axis.y * s;\n    this._z = axis.z * s;\n    this._w = Math.cos(halfAngle);\n    this._onChangeCallback();\n    return this;\n  }\n  setFromRotationMatrix(m) {\n    // http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm\n\n    // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\n\n    const te = m.elements,\n      m11 = te[0],\n      m12 = te[4],\n      m13 = te[8],\n      m21 = te[1],\n      m22 = te[5],\n      m23 = te[9],\n      m31 = te[2],\n      m32 = te[6],\n      m33 = te[10],\n      trace = m11 + m22 + m33;\n    if (trace > 0) {\n      const s = 0.5 / Math.sqrt(trace + 1.0);\n      this._w = 0.25 / s;\n      this._x = (m32 - m23) * s;\n      this._y = (m13 - m31) * s;\n      this._z = (m21 - m12) * s;\n    } else if (m11 > m22 && m11 > m33) {\n      const s = 2.0 * Math.sqrt(1.0 + m11 - m22 - m33);\n      this._w = (m32 - m23) / s;\n      this._x = 0.25 * s;\n      this._y = (m12 + m21) / s;\n      this._z = (m13 + m31) / s;\n    } else if (m22 > m33) {\n      const s = 2.0 * Math.sqrt(1.0 + m22 - m11 - m33);\n      this._w = (m13 - m31) / s;\n      this._x = (m12 + m21) / s;\n      this._y = 0.25 * s;\n      this._z = (m23 + m32) / s;\n    } else {\n      const s = 2.0 * Math.sqrt(1.0 + m33 - m11 - m22);\n      this._w = (m21 - m12) / s;\n      this._x = (m13 + m31) / s;\n      this._y = (m23 + m32) / s;\n      this._z = 0.25 * s;\n    }\n    this._onChangeCallback();\n    return this;\n  }\n  setFromUnitVectors(vFrom, vTo) {\n    // assumes direction vectors vFrom and vTo are normalized\n\n    let r = vFrom.dot(vTo) + 1;\n    if (r < Number.EPSILON) {\n      // vFrom and vTo point in opposite directions\n\n      r = 0;\n      if (Math.abs(vFrom.x) > Math.abs(vFrom.z)) {\n        this._x = -vFrom.y;\n        this._y = vFrom.x;\n        this._z = 0;\n        this._w = r;\n      } else {\n        this._x = 0;\n        this._y = -vFrom.z;\n        this._z = vFrom.y;\n        this._w = r;\n      }\n    } else {\n      // crossVectors( vFrom, vTo ); // inlined to avoid cyclic dependency on Vector3\n\n      this._x = vFrom.y * vTo.z - vFrom.z * vTo.y;\n      this._y = vFrom.z * vTo.x - vFrom.x * vTo.z;\n      this._z = vFrom.x * vTo.y - vFrom.y * vTo.x;\n      this._w = r;\n    }\n    return this.normalize();\n  }\n  angleTo(q) {\n    return 2 * Math.acos(Math.abs(MathUtils.clamp(this.dot(q), -1, 1)));\n  }\n  rotateTowards(q, step) {\n    const angle = this.angleTo(q);\n    if (angle === 0) return this;\n    const t = Math.min(1, step / angle);\n    this.slerp(q, t);\n    return this;\n  }\n  identity() {\n    return this.set(0, 0, 0, 1);\n  }\n  invert() {\n    // quaternion is assumed to have unit length\n\n    return this.conjugate();\n  }\n  conjugate() {\n    this._x *= -1;\n    this._y *= -1;\n    this._z *= -1;\n    this._onChangeCallback();\n    return this;\n  }\n  dot(v) {\n    return this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;\n  }\n  lengthSq() {\n    return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;\n  }\n  length() {\n    return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);\n  }\n  normalize() {\n    let l = this.length();\n    if (l === 0) {\n      this._x = 0;\n      this._y = 0;\n      this._z = 0;\n      this._w = 1;\n    } else {\n      l = 1 / l;\n      this._x = this._x * l;\n      this._y = this._y * l;\n      this._z = this._z * l;\n      this._w = this._w * l;\n    }\n    this._onChangeCallback();\n    return this;\n  }\n  multiply(q) {\n    return this.multiplyQuaternions(this, q);\n  }\n  premultiply(q) {\n    return this.multiplyQuaternions(q, this);\n  }\n  multiplyQuaternions(a, b) {\n    // from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm\n\n    const qax = a._x,\n      qay = a._y,\n      qaz = a._z,\n      qaw = a._w;\n    const qbx = b._x,\n      qby = b._y,\n      qbz = b._z,\n      qbw = b._w;\n    this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;\n    this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;\n    this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;\n    this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;\n    this._onChangeCallback();\n    return this;\n  }\n  slerp(qb, t) {\n    if (t === 0) return this;\n    if (t === 1) return this.copy(qb);\n    const x = this._x,\n      y = this._y,\n      z = this._z,\n      w = this._w;\n\n    // http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/\n\n    let cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;\n    if (cosHalfTheta < 0) {\n      this._w = -qb._w;\n      this._x = -qb._x;\n      this._y = -qb._y;\n      this._z = -qb._z;\n      cosHalfTheta = -cosHalfTheta;\n    } else {\n      this.copy(qb);\n    }\n    if (cosHalfTheta >= 1.0) {\n      this._w = w;\n      this._x = x;\n      this._y = y;\n      this._z = z;\n      return this;\n    }\n    const sqrSinHalfTheta = 1.0 - cosHalfTheta * cosHalfTheta;\n    if (sqrSinHalfTheta <= Number.EPSILON) {\n      const s = 1 - t;\n      this._w = s * w + t * this._w;\n      this._x = s * x + t * this._x;\n      this._y = s * y + t * this._y;\n      this._z = s * z + t * this._z;\n      this.normalize();\n      this._onChangeCallback();\n      return this;\n    }\n    const sinHalfTheta = Math.sqrt(sqrSinHalfTheta);\n    const halfTheta = Math.atan2(sinHalfTheta, cosHalfTheta);\n    const ratioA = Math.sin((1 - t) * halfTheta) / sinHalfTheta,\n      ratioB = Math.sin(t * halfTheta) / sinHalfTheta;\n    this._w = w * ratioA + this._w * ratioB;\n    this._x = x * ratioA + this._x * ratioB;\n    this._y = y * ratioA + this._y * ratioB;\n    this._z = z * ratioA + this._z * ratioB;\n    this._onChangeCallback();\n    return this;\n  }\n  slerpQuaternions(qa, qb, t) {\n    return this.copy(qa).slerp(qb, t);\n  }\n  random() {\n    // Derived from http://planning.cs.uiuc.edu/node198.html\n    // Note, this source uses w, x, y, z ordering,\n    // so we swap the order below.\n\n    const u1 = Math.random();\n    const sqrt1u1 = Math.sqrt(1 - u1);\n    const sqrtu1 = Math.sqrt(u1);\n    const u2 = 2 * Math.PI * Math.random();\n    const u3 = 2 * Math.PI * Math.random();\n    return this.set(sqrt1u1 * Math.cos(u2), sqrtu1 * Math.sin(u3), sqrtu1 * Math.cos(u3), sqrt1u1 * Math.sin(u2));\n  }\n  equals(quaternion) {\n    return quaternion._x === this._x && quaternion._y === this._y && quaternion._z === this._z && quaternion._w === this._w;\n  }\n  fromArray(array, offset = 0) {\n    this._x = array[offset];\n    this._y = array[offset + 1];\n    this._z = array[offset + 2];\n    this._w = array[offset + 3];\n    this._onChangeCallback();\n    return this;\n  }\n  toArray(array = [], offset = 0) {\n    array[offset] = this._x;\n    array[offset + 1] = this._y;\n    array[offset + 2] = this._z;\n    array[offset + 3] = this._w;\n    return array;\n  }\n  fromBufferAttribute(attribute, index) {\n    this._x = attribute.getX(index);\n    this._y = attribute.getY(index);\n    this._z = attribute.getZ(index);\n    this._w = attribute.getW(index);\n    return this;\n  }\n  _onChange(callback) {\n    this._onChangeCallback = callback;\n    return this;\n  }\n  _onChangeCallback() {}\n  *[Symbol.iterator]() {\n    yield this._x;\n    yield this._y;\n    yield this._z;\n    yield this._w;\n  }\n}\nexport { Quaternion };","class Vector2 {\n  constructor(x = 0, y = 0) {\n    Vector2.prototype.isVector2 = true;\n    this.x = x;\n    this.y = y;\n  }\n  get width() {\n    return this.x;\n  }\n  set width(value) {\n    this.x = value;\n  }\n  get height() {\n    return this.y;\n  }\n  set height(value) {\n    this.y = value;\n  }\n  set(x, y) {\n    this.x = x;\n    this.y = y;\n    return this;\n  }\n  setScalar(scalar) {\n    this.x = scalar;\n    this.y = scalar;\n    return this;\n  }\n  setX(x) {\n    this.x = x;\n    return this;\n  }\n  setY(y) {\n    this.y = y;\n    return this;\n  }\n  setComponent(index, value) {\n    switch (index) {\n      case 0:\n        this.x = value;\n        break;\n      case 1:\n        this.y = value;\n        break;\n      default:\n        throw new Error('index is out of range: ' + index);\n    }\n    return this;\n  }\n  getComponent(index) {\n    switch (index) {\n      case 0:\n        return this.x;\n      case 1:\n        return this.y;\n      default:\n        throw new Error('index is out of range: ' + index);\n    }\n  }\n  clone() {\n    return new this.constructor(this.x, this.y);\n  }\n  copy(v) {\n    this.x = v.x;\n    this.y = v.y;\n    return this;\n  }\n  add(v) {\n    this.x += v.x;\n    this.y += v.y;\n    return this;\n  }\n  addScalar(s) {\n    this.x += s;\n    this.y += s;\n    return this;\n  }\n  addVectors(a, b) {\n    this.x = a.x + b.x;\n    this.y = a.y + b.y;\n    return this;\n  }\n  addScaledVector(v, s) {\n    this.x += v.x * s;\n    this.y += v.y * s;\n    return this;\n  }\n  sub(v) {\n    this.x -= v.x;\n    this.y -= v.y;\n    return this;\n  }\n  subScalar(s) {\n    this.x -= s;\n    this.y -= s;\n    return this;\n  }\n  subVectors(a, b) {\n    this.x = a.x - b.x;\n    this.y = a.y - b.y;\n    return this;\n  }\n  multiply(v) {\n    this.x *= v.x;\n    this.y *= v.y;\n    return this;\n  }\n  multiplyScalar(scalar) {\n    this.x *= scalar;\n    this.y *= scalar;\n    return this;\n  }\n  divide(v) {\n    this.x /= v.x;\n    this.y /= v.y;\n    return this;\n  }\n  divideScalar(scalar) {\n    return this.multiplyScalar(1 / scalar);\n  }\n  applyMatrix3(m) {\n    const x = this.x,\n      y = this.y;\n    const e = m.elements;\n    this.x = e[0] * x + e[3] * y + e[6];\n    this.y = e[1] * x + e[4] * y + e[7];\n    return this;\n  }\n  min(v) {\n    this.x = Math.min(this.x, v.x);\n    this.y = Math.min(this.y, v.y);\n    return this;\n  }\n  max(v) {\n    this.x = Math.max(this.x, v.x);\n    this.y = Math.max(this.y, v.y);\n    return this;\n  }\n  clamp(min, max) {\n    // assumes min < max, componentwise\n\n    this.x = Math.max(min.x, Math.min(max.x, this.x));\n    this.y = Math.max(min.y, Math.min(max.y, this.y));\n    return this;\n  }\n  clampScalar(minVal, maxVal) {\n    this.x = Math.max(minVal, Math.min(maxVal, this.x));\n    this.y = Math.max(minVal, Math.min(maxVal, this.y));\n    return this;\n  }\n  clampLength(min, max) {\n    const length = this.length();\n    return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));\n  }\n  floor() {\n    this.x = Math.floor(this.x);\n    this.y = Math.floor(this.y);\n    return this;\n  }\n  ceil() {\n    this.x = Math.ceil(this.x);\n    this.y = Math.ceil(this.y);\n    return this;\n  }\n  round() {\n    this.x = Math.round(this.x);\n    this.y = Math.round(this.y);\n    return this;\n  }\n  roundToZero() {\n    this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);\n    this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);\n    return this;\n  }\n  negate() {\n    this.x = -this.x;\n    this.y = -this.y;\n    return this;\n  }\n  dot(v) {\n    return this.x * v.x + this.y * v.y;\n  }\n  cross(v) {\n    return this.x * v.y - this.y * v.x;\n  }\n  lengthSq() {\n    return this.x * this.x + this.y * this.y;\n  }\n  length() {\n    return Math.sqrt(this.x * this.x + this.y * this.y);\n  }\n  manhattanLength() {\n    return Math.abs(this.x) + Math.abs(this.y);\n  }\n  normalize() {\n    return this.divideScalar(this.length() || 1);\n  }\n  angle() {\n    // computes the angle in radians with respect to the positive x-axis\n\n    const angle = Math.atan2(-this.y, -this.x) + Math.PI;\n    return angle;\n  }\n  distanceTo(v) {\n    return Math.sqrt(this.distanceToSquared(v));\n  }\n  distanceToSquared(v) {\n    const dx = this.x - v.x,\n      dy = this.y - v.y;\n    return dx * dx + dy * dy;\n  }\n  manhattanDistanceTo(v) {\n    return Math.abs(this.x - v.x) + Math.abs(this.y - v.y);\n  }\n  setLength(length) {\n    return this.normalize().multiplyScalar(length);\n  }\n  lerp(v, alpha) {\n    this.x += (v.x - this.x) * alpha;\n    this.y += (v.y - this.y) * alpha;\n    return this;\n  }\n  lerpVectors(v1, v2, alpha) {\n    this.x = v1.x + (v2.x - v1.x) * alpha;\n    this.y = v1.y + (v2.y - v1.y) * alpha;\n    return this;\n  }\n  equals(v) {\n    return v.x === this.x && v.y === this.y;\n  }\n  fromArray(array, offset = 0) {\n    this.x = array[offset];\n    this.y = array[offset + 1];\n    return this;\n  }\n  toArray(array = [], offset = 0) {\n    array[offset] = this.x;\n    array[offset + 1] = this.y;\n    return array;\n  }\n  fromBufferAttribute(attribute, index) {\n    this.x = attribute.getX(index);\n    this.y = attribute.getY(index);\n    return this;\n  }\n  rotateAround(center, angle) {\n    const c = Math.cos(angle),\n      s = Math.sin(angle);\n    const x = this.x - center.x;\n    const y = this.y - center.y;\n    this.x = x * c - y * s + center.x;\n    this.y = x * s + y * c + center.y;\n    return this;\n  }\n  random() {\n    this.x = Math.random();\n    this.y = Math.random();\n    return this;\n  }\n  *[Symbol.iterator]() {\n    yield this.x;\n    yield this.y;\n  }\n}\nexport { Vector2 };","import * as MathUtils from './MathUtils.js';\nimport { Quaternion } from './Quaternion.js';\nclass Vector3 {\n  constructor(x = 0, y = 0, z = 0) {\n    Vector3.prototype.isVector3 = true;\n    this.x = x;\n    this.y = y;\n    this.z = z;\n  }\n  set(x, y, z) {\n    if (z === undefined) z = this.z; // sprite.scale.set(x,y)\n\n    this.x = x;\n    this.y = y;\n    this.z = z;\n    return this;\n  }\n  setScalar(scalar) {\n    this.x = scalar;\n    this.y = scalar;\n    this.z = scalar;\n    return this;\n  }\n  setX(x) {\n    this.x = x;\n    return this;\n  }\n  setY(y) {\n    this.y = y;\n    return this;\n  }\n  setZ(z) {\n    this.z = z;\n    return this;\n  }\n  setComponent(index, value) {\n    switch (index) {\n      case 0:\n        this.x = value;\n        break;\n      case 1:\n        this.y = value;\n        break;\n      case 2:\n        this.z = value;\n        break;\n      default:\n        throw new Error('index is out of range: ' + index);\n    }\n    return this;\n  }\n  getComponent(index) {\n    switch (index) {\n      case 0:\n        return this.x;\n      case 1:\n        return this.y;\n      case 2:\n        return this.z;\n      default:\n        throw new Error('index is out of range: ' + index);\n    }\n  }\n  clone() {\n    return new this.constructor(this.x, this.y, this.z);\n  }\n  copy(v) {\n    this.x = v.x;\n    this.y = v.y;\n    this.z = v.z;\n    return this;\n  }\n  add(v) {\n    this.x += v.x;\n    this.y += v.y;\n    this.z += v.z;\n    return this;\n  }\n  addScalar(s) {\n    this.x += s;\n    this.y += s;\n    this.z += s;\n    return this;\n  }\n  addVectors(a, b) {\n    this.x = a.x + b.x;\n    this.y = a.y + b.y;\n    this.z = a.z + b.z;\n    return this;\n  }\n  addScaledVector(v, s) {\n    this.x += v.x * s;\n    this.y += v.y * s;\n    this.z += v.z * s;\n    return this;\n  }\n  sub(v) {\n    this.x -= v.x;\n    this.y -= v.y;\n    this.z -= v.z;\n    return this;\n  }\n  subScalar(s) {\n    this.x -= s;\n    this.y -= s;\n    this.z -= s;\n    return this;\n  }\n  subVectors(a, b) {\n    this.x = a.x - b.x;\n    this.y = a.y - b.y;\n    this.z = a.z - b.z;\n    return this;\n  }\n  multiply(v) {\n    this.x *= v.x;\n    this.y *= v.y;\n    this.z *= v.z;\n    return this;\n  }\n  multiplyScalar(scalar) {\n    this.x *= scalar;\n    this.y *= scalar;\n    this.z *= scalar;\n    return this;\n  }\n  multiplyVectors(a, b) {\n    this.x = a.x * b.x;\n    this.y = a.y * b.y;\n    this.z = a.z * b.z;\n    return this;\n  }\n  applyEuler(euler) {\n    return this.applyQuaternion(_quaternion.setFromEuler(euler));\n  }\n  applyAxisAngle(axis, angle) {\n    return this.applyQuaternion(_quaternion.setFromAxisAngle(axis, angle));\n  }\n  applyMatrix3(m) {\n    const x = this.x,\n      y = this.y,\n      z = this.z;\n    const e = m.elements;\n    this.x = e[0] * x + e[3] * y + e[6] * z;\n    this.y = e[1] * x + e[4] * y + e[7] * z;\n    this.z = e[2] * x + e[5] * y + e[8] * z;\n    return this;\n  }\n  applyNormalMatrix(m) {\n    return this.applyMatrix3(m).normalize();\n  }\n  applyMatrix4(m) {\n    const x = this.x,\n      y = this.y,\n      z = this.z;\n    const e = m.elements;\n    const w = 1 / (e[3] * x + e[7] * y + e[11] * z + e[15]);\n    this.x = (e[0] * x + e[4] * y + e[8] * z + e[12]) * w;\n    this.y = (e[1] * x + e[5] * y + e[9] * z + e[13]) * w;\n    this.z = (e[2] * x + e[6] * y + e[10] * z + e[14]) * w;\n    return this;\n  }\n  applyQuaternion(q) {\n    const x = this.x,\n      y = this.y,\n      z = this.z;\n    const qx = q.x,\n      qy = q.y,\n      qz = q.z,\n      qw = q.w;\n\n    // calculate quat * vector\n\n    const ix = qw * x + qy * z - qz * y;\n    const iy = qw * y + qz * x - qx * z;\n    const iz = qw * z + qx * y - qy * x;\n    const iw = -qx * x - qy * y - qz * z;\n\n    // calculate result * inverse quat\n\n    this.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;\n    this.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;\n    this.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;\n    return this;\n  }\n  project(camera) {\n    return this.applyMatrix4(camera.matrixWorldInverse).applyMatrix4(camera.projectionMatrix);\n  }\n  unproject(camera) {\n    return this.applyMatrix4(camera.projectionMatrixInverse).applyMatrix4(camera.matrixWorld);\n  }\n  transformDirection(m) {\n    // input: THREE.Matrix4 affine matrix\n    // vector interpreted as a direction\n\n    const x = this.x,\n      y = this.y,\n      z = this.z;\n    const e = m.elements;\n    this.x = e[0] * x + e[4] * y + e[8] * z;\n    this.y = e[1] * x + e[5] * y + e[9] * z;\n    this.z = e[2] * x + e[6] * y + e[10] * z;\n    return this.normalize();\n  }\n  divide(v) {\n    this.x /= v.x;\n    this.y /= v.y;\n    this.z /= v.z;\n    return this;\n  }\n  divideScalar(scalar) {\n    return this.multiplyScalar(1 / scalar);\n  }\n  min(v) {\n    this.x = Math.min(this.x, v.x);\n    this.y = Math.min(this.y, v.y);\n    this.z = Math.min(this.z, v.z);\n    return this;\n  }\n  max(v) {\n    this.x = Math.max(this.x, v.x);\n    this.y = Math.max(this.y, v.y);\n    this.z = Math.max(this.z, v.z);\n    return this;\n  }\n  clamp(min, max) {\n    // assumes min < max, componentwise\n\n    this.x = Math.max(min.x, Math.min(max.x, this.x));\n    this.y = Math.max(min.y, Math.min(max.y, this.y));\n    this.z = Math.max(min.z, Math.min(max.z, this.z));\n    return this;\n  }\n  clampScalar(minVal, maxVal) {\n    this.x = Math.max(minVal, Math.min(maxVal, this.x));\n    this.y = Math.max(minVal, Math.min(maxVal, this.y));\n    this.z = Math.max(minVal, Math.min(maxVal, this.z));\n    return this;\n  }\n  clampLength(min, max) {\n    const length = this.length();\n    return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));\n  }\n  floor() {\n    this.x = Math.floor(this.x);\n    this.y = Math.floor(this.y);\n    this.z = Math.floor(this.z);\n    return this;\n  }\n  ceil() {\n    this.x = Math.ceil(this.x);\n    this.y = Math.ceil(this.y);\n    this.z = Math.ceil(this.z);\n    return this;\n  }\n  round() {\n    this.x = Math.round(this.x);\n    this.y = Math.round(this.y);\n    this.z = Math.round(this.z);\n    return this;\n  }\n  roundToZero() {\n    this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);\n    this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);\n    this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z);\n    return this;\n  }\n  negate() {\n    this.x = -this.x;\n    this.y = -this.y;\n    this.z = -this.z;\n    return this;\n  }\n  dot(v) {\n    return this.x * v.x + this.y * v.y + this.z * v.z;\n  }\n\n  // TODO lengthSquared?\n\n  lengthSq() {\n    return this.x * this.x + this.y * this.y + this.z * this.z;\n  }\n  length() {\n    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);\n  }\n  manhattanLength() {\n    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);\n  }\n  normalize() {\n    return this.divideScalar(this.length() || 1);\n  }\n  setLength(length) {\n    return this.normalize().multiplyScalar(length);\n  }\n  lerp(v, alpha) {\n    this.x += (v.x - this.x) * alpha;\n    this.y += (v.y - this.y) * alpha;\n    this.z += (v.z - this.z) * alpha;\n    return this;\n  }\n  lerpVectors(v1, v2, alpha) {\n    this.x = v1.x + (v2.x - v1.x) * alpha;\n    this.y = v1.y + (v2.y - v1.y) * alpha;\n    this.z = v1.z + (v2.z - v1.z) * alpha;\n    return this;\n  }\n  cross(v) {\n    return this.crossVectors(this, v);\n  }\n  crossVectors(a, b) {\n    const ax = a.x,\n      ay = a.y,\n      az = a.z;\n    const bx = b.x,\n      by = b.y,\n      bz = b.z;\n    this.x = ay * bz - az * by;\n    this.y = az * bx - ax * bz;\n    this.z = ax * by - ay * bx;\n    return this;\n  }\n  projectOnVector(v) {\n    const denominator = v.lengthSq();\n    if (denominator === 0) return this.set(0, 0, 0);\n    const scalar = v.dot(this) / denominator;\n    return this.copy(v).multiplyScalar(scalar);\n  }\n  projectOnPlane(planeNormal) {\n    _vector.copy(this).projectOnVector(planeNormal);\n    return this.sub(_vector);\n  }\n  reflect(normal) {\n    // reflect incident vector off plane orthogonal to normal\n    // normal is assumed to have unit length\n\n    return this.sub(_vector.copy(normal).multiplyScalar(2 * this.dot(normal)));\n  }\n  angleTo(v) {\n    const denominator = Math.sqrt(this.lengthSq() * v.lengthSq());\n    if (denominator === 0) return Math.PI / 2;\n    const theta = this.dot(v) / denominator;\n\n    // clamp, to handle numerical problems\n\n    return Math.acos(MathUtils.clamp(theta, -1, 1));\n  }\n  distanceTo(v) {\n    return Math.sqrt(this.distanceToSquared(v));\n  }\n  distanceToSquared(v) {\n    const dx = this.x - v.x,\n      dy = this.y - v.y,\n      dz = this.z - v.z;\n    return dx * dx + dy * dy + dz * dz;\n  }\n  manhattanDistanceTo(v) {\n    return Math.abs(this.x - v.x) + Math.abs(this.y - v.y) + Math.abs(this.z - v.z);\n  }\n  setFromSpherical(s) {\n    return this.setFromSphericalCoords(s.radius, s.phi, s.theta);\n  }\n  setFromSphericalCoords(radius, phi, theta) {\n    const sinPhiRadius = Math.sin(phi) * radius;\n    this.x = sinPhiRadius * Math.sin(theta);\n    this.y = Math.cos(phi) * radius;\n    this.z = sinPhiRadius * Math.cos(theta);\n    return this;\n  }\n  setFromCylindrical(c) {\n    return this.setFromCylindricalCoords(c.radius, c.theta, c.y);\n  }\n  setFromCylindricalCoords(radius, theta, y) {\n    this.x = radius * Math.sin(theta);\n    this.y = y;\n    this.z = radius * Math.cos(theta);\n    return this;\n  }\n  setFromMatrixPosition(m) {\n    const e = m.elements;\n    this.x = e[12];\n    this.y = e[13];\n    this.z = e[14];\n    return this;\n  }\n  setFromMatrixScale(m) {\n    const sx = this.setFromMatrixColumn(m, 0).length();\n    const sy = this.setFromMatrixColumn(m, 1).length();\n    const sz = this.setFromMatrixColumn(m, 2).length();\n    this.x = sx;\n    this.y = sy;\n    this.z = sz;\n    return this;\n  }\n  setFromMatrixColumn(m, index) {\n    return this.fromArray(m.elements, index * 4);\n  }\n  setFromMatrix3Column(m, index) {\n    return this.fromArray(m.elements, index * 3);\n  }\n  setFromEuler(e) {\n    this.x = e._x;\n    this.y = e._y;\n    this.z = e._z;\n    return this;\n  }\n  equals(v) {\n    return v.x === this.x && v.y === this.y && v.z === this.z;\n  }\n  fromArray(array, offset = 0) {\n    this.x = array[offset];\n    this.y = array[offset + 1];\n    this.z = array[offset + 2];\n    return this;\n  }\n  toArray(array = [], offset = 0) {\n    array[offset] = this.x;\n    array[offset + 1] = this.y;\n    array[offset + 2] = this.z;\n    return array;\n  }\n  fromBufferAttribute(attribute, index) {\n    this.x = attribute.getX(index);\n    this.y = attribute.getY(index);\n    this.z = attribute.getZ(index);\n    return this;\n  }\n  random() {\n    this.x = Math.random();\n    this.y = Math.random();\n    this.z = Math.random();\n    return this;\n  }\n  randomDirection() {\n    // Derived from https://mathworld.wolfram.com/SpherePointPicking.html\n\n    const u = (Math.random() - 0.5) * 2;\n    const t = Math.random() * Math.PI * 2;\n    const f = Math.sqrt(1 - u ** 2);\n    this.x = f * Math.cos(t);\n    this.y = f * Math.sin(t);\n    this.z = u;\n    return this;\n  }\n  *[Symbol.iterator]() {\n    yield this.x;\n    yield this.y;\n    yield this.z;\n  }\n}\nconst _vector = /*@__PURE__*/new Vector3();\nconst _quaternion = /*@__PURE__*/new Quaternion();\nexport { Vector3 };","class Vector4 {\n  constructor(x = 0, y = 0, z = 0, w = 1) {\n    Vector4.prototype.isVector4 = true;\n    this.x = x;\n    this.y = y;\n    this.z = z;\n    this.w = w;\n  }\n  get width() {\n    return this.z;\n  }\n  set width(value) {\n    this.z = value;\n  }\n  get height() {\n    return this.w;\n  }\n  set height(value) {\n    this.w = value;\n  }\n  set(x, y, z, w) {\n    this.x = x;\n    this.y = y;\n    this.z = z;\n    this.w = w;\n    return this;\n  }\n  setScalar(scalar) {\n    this.x = scalar;\n    this.y = scalar;\n    this.z = scalar;\n    this.w = scalar;\n    return this;\n  }\n  setX(x) {\n    this.x = x;\n    return this;\n  }\n  setY(y) {\n    this.y = y;\n    return this;\n  }\n  setZ(z) {\n    this.z = z;\n    return this;\n  }\n  setW(w) {\n    this.w = w;\n    return this;\n  }\n  setComponent(index, value) {\n    switch (index) {\n      case 0:\n        this.x = value;\n        break;\n      case 1:\n        this.y = value;\n        break;\n      case 2:\n        this.z = value;\n        break;\n      case 3:\n        this.w = value;\n        break;\n      default:\n        throw new Error('index is out of range: ' + index);\n    }\n    return this;\n  }\n  getComponent(index) {\n    switch (index) {\n      case 0:\n        return this.x;\n      case 1:\n        return this.y;\n      case 2:\n        return this.z;\n      case 3:\n        return this.w;\n      default:\n        throw new Error('index is out of range: ' + index);\n    }\n  }\n  clone() {\n    return new this.constructor(this.x, this.y, this.z, this.w);\n  }\n  copy(v) {\n    this.x = v.x;\n    this.y = v.y;\n    this.z = v.z;\n    this.w = v.w !== undefined ? v.w : 1;\n    return this;\n  }\n  add(v) {\n    this.x += v.x;\n    this.y += v.y;\n    this.z += v.z;\n    this.w += v.w;\n    return this;\n  }\n  addScalar(s) {\n    this.x += s;\n    this.y += s;\n    this.z += s;\n    this.w += s;\n    return this;\n  }\n  addVectors(a, b) {\n    this.x = a.x + b.x;\n    this.y = a.y + b.y;\n    this.z = a.z + b.z;\n    this.w = a.w + b.w;\n    return this;\n  }\n  addScaledVector(v, s) {\n    this.x += v.x * s;\n    this.y += v.y * s;\n    this.z += v.z * s;\n    this.w += v.w * s;\n    return this;\n  }\n  sub(v) {\n    this.x -= v.x;\n    this.y -= v.y;\n    this.z -= v.z;\n    this.w -= v.w;\n    return this;\n  }\n  subScalar(s) {\n    this.x -= s;\n    this.y -= s;\n    this.z -= s;\n    this.w -= s;\n    return this;\n  }\n  subVectors(a, b) {\n    this.x = a.x - b.x;\n    this.y = a.y - b.y;\n    this.z = a.z - b.z;\n    this.w = a.w - b.w;\n    return this;\n  }\n  multiply(v) {\n    this.x *= v.x;\n    this.y *= v.y;\n    this.z *= v.z;\n    this.w *= v.w;\n    return this;\n  }\n  multiplyScalar(scalar) {\n    this.x *= scalar;\n    this.y *= scalar;\n    this.z *= scalar;\n    this.w *= scalar;\n    return this;\n  }\n  applyMatrix4(m) {\n    const x = this.x,\n      y = this.y,\n      z = this.z,\n      w = this.w;\n    const e = m.elements;\n    this.x = e[0] * x + e[4] * y + e[8] * z + e[12] * w;\n    this.y = e[1] * x + e[5] * y + e[9] * z + e[13] * w;\n    this.z = e[2] * x + e[6] * y + e[10] * z + e[14] * w;\n    this.w = e[3] * x + e[7] * y + e[11] * z + e[15] * w;\n    return this;\n  }\n  divideScalar(scalar) {\n    return this.multiplyScalar(1 / scalar);\n  }\n  setAxisAngleFromQuaternion(q) {\n    // http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm\n\n    // q is assumed to be normalized\n\n    this.w = 2 * Math.acos(q.w);\n    const s = Math.sqrt(1 - q.w * q.w);\n    if (s < 0.0001) {\n      this.x = 1;\n      this.y = 0;\n      this.z = 0;\n    } else {\n      this.x = q.x / s;\n      this.y = q.y / s;\n      this.z = q.z / s;\n    }\n    return this;\n  }\n  setAxisAngleFromRotationMatrix(m) {\n    // http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm\n\n    // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\n\n    let angle, x, y, z; // variables for result\n    const epsilon = 0.01,\n      // margin to allow for rounding errors\n      epsilon2 = 0.1,\n      // margin to distinguish between 0 and 180 degrees\n\n      te = m.elements,\n      m11 = te[0],\n      m12 = te[4],\n      m13 = te[8],\n      m21 = te[1],\n      m22 = te[5],\n      m23 = te[9],\n      m31 = te[2],\n      m32 = te[6],\n      m33 = te[10];\n    if (Math.abs(m12 - m21) < epsilon && Math.abs(m13 - m31) < epsilon && Math.abs(m23 - m32) < epsilon) {\n      // singularity found\n      // first check for identity matrix which must have +1 for all terms\n      // in leading diagonal and zero in other terms\n\n      if (Math.abs(m12 + m21) < epsilon2 && Math.abs(m13 + m31) < epsilon2 && Math.abs(m23 + m32) < epsilon2 && Math.abs(m11 + m22 + m33 - 3) < epsilon2) {\n        // this singularity is identity matrix so angle = 0\n\n        this.set(1, 0, 0, 0);\n        return this; // zero angle, arbitrary axis\n      }\n\n      // otherwise this singularity is angle = 180\n\n      angle = Math.PI;\n      const xx = (m11 + 1) / 2;\n      const yy = (m22 + 1) / 2;\n      const zz = (m33 + 1) / 2;\n      const xy = (m12 + m21) / 4;\n      const xz = (m13 + m31) / 4;\n      const yz = (m23 + m32) / 4;\n      if (xx > yy && xx > zz) {\n        // m11 is the largest diagonal term\n\n        if (xx < epsilon) {\n          x = 0;\n          y = 0.707106781;\n          z = 0.707106781;\n        } else {\n          x = Math.sqrt(xx);\n          y = xy / x;\n          z = xz / x;\n        }\n      } else if (yy > zz) {\n        // m22 is the largest diagonal term\n\n        if (yy < epsilon) {\n          x = 0.707106781;\n          y = 0;\n          z = 0.707106781;\n        } else {\n          y = Math.sqrt(yy);\n          x = xy / y;\n          z = yz / y;\n        }\n      } else {\n        // m33 is the largest diagonal term so base result on this\n\n        if (zz < epsilon) {\n          x = 0.707106781;\n          y = 0.707106781;\n          z = 0;\n        } else {\n          z = Math.sqrt(zz);\n          x = xz / z;\n          y = yz / z;\n        }\n      }\n      this.set(x, y, z, angle);\n      return this; // return 180 deg rotation\n    }\n\n    // as we have reached here there are no singularities so we can handle normally\n\n    let s = Math.sqrt((m32 - m23) * (m32 - m23) + (m13 - m31) * (m13 - m31) + (m21 - m12) * (m21 - m12)); // used to normalize\n\n    if (Math.abs(s) < 0.001) s = 1;\n\n    // prevent divide by zero, should not happen if matrix is orthogonal and should be\n    // caught by singularity test above, but I've left it in just in case\n\n    this.x = (m32 - m23) / s;\n    this.y = (m13 - m31) / s;\n    this.z = (m21 - m12) / s;\n    this.w = Math.acos((m11 + m22 + m33 - 1) / 2);\n    return this;\n  }\n  min(v) {\n    this.x = Math.min(this.x, v.x);\n    this.y = Math.min(this.y, v.y);\n    this.z = Math.min(this.z, v.z);\n    this.w = Math.min(this.w, v.w);\n    return this;\n  }\n  max(v) {\n    this.x = Math.max(this.x, v.x);\n    this.y = Math.max(this.y, v.y);\n    this.z = Math.max(this.z, v.z);\n    this.w = Math.max(this.w, v.w);\n    return this;\n  }\n  clamp(min, max) {\n    // assumes min < max, componentwise\n\n    this.x = Math.max(min.x, Math.min(max.x, this.x));\n    this.y = Math.max(min.y, Math.min(max.y, this.y));\n    this.z = Math.max(min.z, Math.min(max.z, this.z));\n    this.w = Math.max(min.w, Math.min(max.w, this.w));\n    return this;\n  }\n  clampScalar(minVal, maxVal) {\n    this.x = Math.max(minVal, Math.min(maxVal, this.x));\n    this.y = Math.max(minVal, Math.min(maxVal, this.y));\n    this.z = Math.max(minVal, Math.min(maxVal, this.z));\n    this.w = Math.max(minVal, Math.min(maxVal, this.w));\n    return this;\n  }\n  clampLength(min, max) {\n    const length = this.length();\n    return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));\n  }\n  floor() {\n    this.x = Math.floor(this.x);\n    this.y = Math.floor(this.y);\n    this.z = Math.floor(this.z);\n    this.w = Math.floor(this.w);\n    return this;\n  }\n  ceil() {\n    this.x = Math.ceil(this.x);\n    this.y = Math.ceil(this.y);\n    this.z = Math.ceil(this.z);\n    this.w = Math.ceil(this.w);\n    return this;\n  }\n  round() {\n    this.x = Math.round(this.x);\n    this.y = Math.round(this.y);\n    this.z = Math.round(this.z);\n    this.w = Math.round(this.w);\n    return this;\n  }\n  roundToZero() {\n    this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);\n    this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);\n    this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z);\n    this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w);\n    return this;\n  }\n  negate() {\n    this.x = -this.x;\n    this.y = -this.y;\n    this.z = -this.z;\n    this.w = -this.w;\n    return this;\n  }\n  dot(v) {\n    return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;\n  }\n  lengthSq() {\n    return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;\n  }\n  length() {\n    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);\n  }\n  manhattanLength() {\n    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);\n  }\n  normalize() {\n    return this.divideScalar(this.length() || 1);\n  }\n  setLength(length) {\n    return this.normalize().multiplyScalar(length);\n  }\n  lerp(v, alpha) {\n    this.x += (v.x - this.x) * alpha;\n    this.y += (v.y - this.y) * alpha;\n    this.z += (v.z - this.z) * alpha;\n    this.w += (v.w - this.w) * alpha;\n    return this;\n  }\n  lerpVectors(v1, v2, alpha) {\n    this.x = v1.x + (v2.x - v1.x) * alpha;\n    this.y = v1.y + (v2.y - v1.y) * alpha;\n    this.z = v1.z + (v2.z - v1.z) * alpha;\n    this.w = v1.w + (v2.w - v1.w) * alpha;\n    return this;\n  }\n  equals(v) {\n    return v.x === this.x && v.y === this.y && v.z === this.z && v.w === this.w;\n  }\n  fromArray(array, offset = 0) {\n    this.x = array[offset];\n    this.y = array[offset + 1];\n    this.z = array[offset + 2];\n    this.w = array[offset + 3];\n    return this;\n  }\n  toArray(array = [], offset = 0) {\n    array[offset] = this.x;\n    array[offset + 1] = this.y;\n    array[offset + 2] = this.z;\n    array[offset + 3] = this.w;\n    return array;\n  }\n  fromBufferAttribute(attribute, index) {\n    this.x = attribute.getX(index);\n    this.y = attribute.getY(index);\n    this.z = attribute.getZ(index);\n    this.w = attribute.getW(index);\n    return this;\n  }\n  random() {\n    this.x = Math.random();\n    this.y = Math.random();\n    this.z = Math.random();\n    this.w = Math.random();\n    return this;\n  }\n  *[Symbol.iterator]() {\n    yield this.x;\n    yield this.y;\n    yield this.z;\n    yield this.w;\n  }\n}\nexport { Vector4 };","import { AngleUnit, GCS } from './unit';\n/**\n * Haversine formulate to calculate distance of two geographical points\n *\n * @param {number[]} pointA Point A\n * @param {number[]} pointB Point B\n * @returns {number} distance\n */\nexport function HAVERSINE(pointA, pointB) {\n  const latRadA = AngleUnit.DEGREE.convert(pointA[1], AngleUnit.RADIAN);\n  const latRadB = AngleUnit.DEGREE.convert(pointB[1], AngleUnit.RADIAN);\n  const deltaLat = AngleUnit.DEGREE.convert(pointB[1] - pointA[1], AngleUnit.RADIAN);\n  const deltaLon = AngleUnit.DEGREE.convert(pointB[0] - pointA[0], AngleUnit.RADIAN);\n  const a = Math.sin(deltaLat / 2) * Math.sin(deltaLat / 2) + Math.cos(latRadA) * Math.cos(latRadB) * Math.sin(deltaLon / 2) * Math.sin(deltaLon / 2);\n  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n  return GCS.EARTH_RADIUS_MEAN * c;\n}\n/**\n * Euclidean distance function\n *\n * @param {number[]} pointA n-dimensional point\n * @param {number[]} pointB n-dimensional point\n * @returns {number} distance\n */\nexport function EUCLIDEAN(pointA, pointB) {\n  let distance = 0;\n  for (let i = 0; i < pointA.length; i++) {\n    distance += Math.pow(pointA[i] - pointB[i], 2);\n  }\n  distance = Math.sqrt(distance);\n  return distance;\n}\n/**\n * Manhattan distance function\n *\n * @param {number[]} pointA n-dimensional point\n * @param {number[]} pointB n-dimensional point\n * @returns {number} distance\n */\nexport function MANHATTAN(pointA, pointB) {\n  let distance = 0;\n  for (let i = 0; i < pointA.length; i++) {\n    distance += Math.abs(pointA[i] - pointB[i]);\n  }\n  return distance;\n}\n/**\n * Canberra distance function\n *\n * @param {number[]} pointA n-dimensional point\n * @param {number[]} pointB n-dimensional point\n * @returns {number} distance\n */\nexport function CANBERRA(pointA, pointB) {\n  let distance = 0;\n  for (let i = 0; i < pointA.length; i++) {\n    distance += Math.abs(pointA[i] - pointB[i]) / (Math.abs(pointA[i]) + Math.abs(pointB[i]));\n  }\n  return distance;\n}\n/**\n * Chebyshev distance function\n *\n * @param {number[]} pointA n-dimensional point\n * @param {number[]} pointB n-dimensional point\n * @returns {number} distance\n */\nexport function CHEBYSHEV(pointA, pointB) {\n  let maxDistance = 0;\n  for (let i = 0; i < pointA.length; i++) {\n    maxDistance = Math.max(maxDistance, Math.abs(pointA[i] - pointB[i]));\n  }\n  return maxDistance;\n}","export * from './unit';\nexport * from './math';\nexport * from './DistanceFunction';","var AxisAngle_1;\nimport { __decorate, __metadata } from \"tslib\";\nimport { AngleUnit } from '../unit/AngleUnit';\nimport { SerializableObject, SerializableMember } from '../../data/decorators';\nimport { Matrix4 } from './Matrix4';\nimport { Vector3 } from './Vector3';\n/**\n * Axis-angle rotation\n */\nlet AxisAngle = AxisAngle_1 = class AxisAngle extends Vector3 {\n  constructor(x, y, z, angle = null, unit = AngleUnit.RADIAN) {\n    super(unit.convert(x ? x : 0, AngleUnit.RADIAN), unit.convert(y ? y : 0, AngleUnit.RADIAN), unit.convert(z ? z : 0, AngleUnit.RADIAN));\n    if (angle !== null) {\n      this.angle = unit.convert(angle, AngleUnit.RADIAN);\n    } else {\n      this.angle = Math.sqrt(Math.pow(this.x, 2) + Math.pow(this.y, 2) + Math.pow(this.z, 2));\n      this.normalize();\n    }\n  }\n  /**\n   * Convert quaternion to axis angles\n   *\n   * @param {THREE.Quaternion} quat Quaternion\n   * @returns {AxisAngle} Axis angle instance\n   */\n  static fromQuaternion(quat) {\n    const axis = new AxisAngle_1();\n    axis.angle = 2 * Math.acos(quat.w);\n    if (1 - quat.w * quat.w < 0.000001) {\n      axis.x = quat.x;\n      axis.y = quat.y;\n      axis.z = quat.z;\n    } else {\n      // http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/\n      const s = Math.sqrt(1 - quat.w * quat.w);\n      axis.x = quat.x / s;\n      axis.y = quat.y / s;\n      axis.z = quat.z / s;\n    }\n    return axis;\n  }\n  /**\n   * Convert axis angle to rotation matrix\n   *\n   * @returns {Matrix4} Rotation matrix\n   */\n  toRotationMatrix() {\n    return Matrix4.rotationFromAxisAngle(this, this.angle);\n  }\n  clone() {\n    const vector = new this.constructor();\n    vector.angle = this.angle;\n    return vector;\n  }\n};\n__decorate([SerializableMember(), __metadata(\"design:type\", Number)], AxisAngle.prototype, \"angle\", void 0);\nAxisAngle = AxisAngle_1 = __decorate([SerializableObject(), __metadata(\"design:paramtypes\", [Number, Number, Number, Number, AngleUnit])], AxisAngle);\nexport { AxisAngle };","var Euler_1;\nimport { __decorate, __metadata } from \"tslib\";\nimport { SerializableObject, SerializableMember, NumberType } from '../../data/decorators';\nimport * as THREE from './_internal';\nimport { Matrix4 } from './Matrix4';\nimport { AngleUnit } from '../unit/AngleUnit';\nimport { Vector3 } from './Vector3';\n/**\n * Serializable THREE.js Euler\n */\nlet Euler = Euler_1 = class Euler extends THREE.Euler {\n  constructor(x, y, z, order, unit) {\n    super(x, y, z, order);\n    if (unit) {\n      this.x = unit.convert(this.x, AngleUnit.RADIAN);\n      this.y = unit.convert(this.y, AngleUnit.RADIAN);\n      this.z = unit.convert(this.z, AngleUnit.RADIAN);\n    }\n  }\n  /**\n   * Convert quaternion to euler\n   *\n   * @param {THREE.Quaternion} quat Quaternion\n   * @param {string} [order='XYZ'] Euler order\n   * @returns {Euler} Euler instance\n   */\n  static fromQuaternion(quat, order = 'XYZ') {\n    const euler = new Euler_1();\n    euler.setFromQuaternion(quat, order);\n    return euler;\n  }\n  /**\n   * Convert rotation matrix to euler\n   *\n   * @param {Matrix4} matrix Rotation matrix\n   * @param {string} [order='XYZ'] Euler order\n   * @returns {Euler} Euler instance\n   */\n  static fromRotationMatrix(matrix, order = 'XYZ') {\n    const euler = new Euler_1();\n    euler.setFromRotationMatrix(matrix, order);\n    return euler;\n  }\n  /**\n   * Convert the Euler angles to a vector\n   *\n   * @param {AngleUnit} [unit] Angle unit to use in vector\n   * @returns {Vector3} Vector output of Euler angles\n   */\n  toVector(unit = AngleUnit.RADIAN) {\n    return new Vector3(AngleUnit.RADIAN.convert(this.x, unit), AngleUnit.RADIAN.convert(this.y, unit), AngleUnit.RADIAN.convert(this.z, unit));\n  }\n  /**\n   * Convert the Euler angles to a vector\n   *\n   * @deprecated use {@link Euler.toVector}\n   * @param {AngleUnit} [unit] Angle unit to use in vector\n   * @returns {Vector3} Vector output of Euler angles\n   */\n  toVector3(unit) {\n    return this.toVector(unit);\n  }\n  /**\n   * Convert quaternion to rotation matrix\n   *\n   * @returns {Matrix4} Rotation matrix\n   */\n  toRotationMatrix() {\n    return Matrix4.rotationFromEuler(this);\n  }\n  /**\n   * Get pitch in degrees\n   *\n   * @returns {number} Pitch in degrees\n   */\n  get pitch() {\n    return AngleUnit.RADIAN.convert(this.y, AngleUnit.DEGREE);\n  }\n  /**\n   * Get roll in degrees\n   *\n   * @returns {number} Roll in degrees\n   */\n  get roll() {\n    return AngleUnit.RADIAN.convert(this.x, AngleUnit.DEGREE);\n  }\n  /**\n   * Get yaw in degrees\n   *\n   * @returns {number} Yaw in degrees\n   */\n  get yaw() {\n    return AngleUnit.RADIAN.convert(this.z, AngleUnit.DEGREE);\n  }\n  clone() {\n    return new this.constructor().copy(this);\n  }\n};\n__decorate([SerializableMember({\n  numberType: NumberType.DECIMAL\n}), __metadata(\"design:type\", Number)], Euler.prototype, \"x\", void 0);\n__decorate([SerializableMember({\n  numberType: NumberType.DECIMAL\n}), __metadata(\"design:type\", Number)], Euler.prototype, \"y\", void 0);\n__decorate([SerializableMember({\n  numberType: NumberType.DECIMAL\n}), __metadata(\"design:type\", Number)], Euler.prototype, \"z\", void 0);\nEuler = Euler_1 = __decorate([SerializableObject(), __metadata(\"design:paramtypes\", [Number, Number, Number, String, AngleUnit])], Euler);\nexport { Euler };","import { __decorate, __metadata } from \"tslib\";\nimport { SerializableArrayMember, SerializableObject } from '../../data/decorators';\nimport * as THREE from './_internal';\n/**\n * Serializable THREE.js Matrix3\n */\nlet Matrix3 = class Matrix3 extends THREE.Matrix3 {\n  /**\n   * Create a matrix from array\n   *\n   * @param {number[][]} array Array\n   * @returns {Matrix3} Matrix3\n   */\n  static fromArray(array) {\n    const matrix = new this();\n    matrix.fromArray([].concat(...array));\n    matrix.transpose();\n    return matrix;\n  }\n  clone() {\n    return new this.constructor().fromArray(this.elements);\n  }\n};\n__decorate([SerializableArrayMember(Number), __metadata(\"design:type\", Array)], Matrix3.prototype, \"elements\", void 0);\nMatrix3 = __decorate([SerializableObject()], Matrix3);\nexport { Matrix3 };","import { __decorate, __metadata } from \"tslib\";\nimport { SerializableArrayMember, SerializableObject } from '../../data/decorators';\nimport * as THREE from './_internal';\n/**\n * Serializable THREE.js Matrix4\n */\nlet Matrix4 = class Matrix4 extends THREE.Matrix4 {\n  static round(value, decimals = 0) {\n    const pow = Math.pow(10, decimals);\n    value.elements.forEach((e, i) => {\n      value.elements[i] = Math.round(e * pow) / pow;\n    });\n    return value;\n  }\n  /**\n   * Create a matrix from array\n   *\n   * @param {number[][]} array Array\n   * @returns {Matrix4} Matrix4\n   */\n  static fromArray(array) {\n    const matrix = new this();\n    matrix.fromArray([].concat(...array));\n    matrix.transpose();\n    return matrix;\n  }\n  /**\n   * Create a rotation matrix from quaternion\n   *\n   * @param {THREE.Quaternion} quat Quaternion\n   * @returns {Matrix4} Rotation matrix\n   */\n  static rotationFromQuaternion(quat) {\n    const matrix = new this();\n    matrix.makeRotationFromQuaternion(quat);\n    return matrix;\n  }\n  /**\n   * Create a rotation matrix from euler angles\n   *\n   * @param {THREE.Euler} euler Euler angles\n   * @returns {Matrix4} Rotation matrix\n   */\n  static rotationFromEuler(euler) {\n    const matrix = new this();\n    matrix.makeRotationFromEuler(euler);\n    return matrix;\n  }\n  /**\n   * Create a rotation matrix from euler angles\n   *\n   * @param {THREE.Vector3} vector Vector\n   * @param {number} angle Angle\n   * @returns {Matrix4} Rotation matrix\n   */\n  static rotationFromAxisAngle(vector, angle) {\n    const matrix = new this();\n    matrix.makeRotationAxis(vector, angle);\n    return matrix;\n  }\n  clone() {\n    return new this.constructor().fromArray(this.elements);\n  }\n};\n__decorate([SerializableArrayMember(Number), __metadata(\"design:type\", Array)], Matrix4.prototype, \"elements\", void 0);\nMatrix4 = __decorate([SerializableObject()], Matrix4);\nexport { Matrix4 };","var Quaternion_1;\nimport { __decorate, __metadata } from \"tslib\";\nimport { SerializableObject, SerializableMember, NumberType } from '../../data/decorators';\nimport * as THREE from './_internal';\nimport { Euler } from './Euler';\nimport { Matrix4 } from './Matrix4';\nimport { AxisAngle } from './AxisAngle';\nimport { Vector3 } from './Vector3';\n/**\n * Serializable THREE.js Quaternion\n */\nlet Quaternion = Quaternion_1 = class Quaternion extends THREE.Quaternion {\n  /**\n   * Convert a threejs quaternion to serializable quaternion\n   *\n   * @param {THREE.Quaternion} threeQuaternion ThreeJS created quaternion\n   * @returns {Quaternion} Serializable quaternion\n   */\n  static fromThreeJS(threeQuaternion) {\n    const quaternion = new this();\n    quaternion.x = threeQuaternion.x;\n    quaternion.y = threeQuaternion.y;\n    quaternion.z = threeQuaternion.z;\n    quaternion.w = threeQuaternion.w;\n    return quaternion;\n  }\n  static fromEuler(euler) {\n    const quaternion = new this();\n    if (euler instanceof Euler) {\n      quaternion.setFromEuler(euler);\n    } else if (euler instanceof Vector3) {\n      quaternion.setFromEuler(new Euler(euler.x, euler.y, euler.z));\n    } else if (euler instanceof Array) {\n      quaternion.setFromEuler(new Euler(euler[0], euler[1], euler[2]));\n    } else if (euler['yaw'] === undefined) {\n      quaternion.setFromEuler(new Euler(euler.x, euler.y, euler.z, euler.order, euler.unit));\n    } else {\n      quaternion.setFromEuler(new Euler(euler.roll, euler.pitch, euler.yaw, 'ZYX', euler.unit));\n    }\n    return quaternion;\n  }\n  static fromAxisAngle(axis) {\n    const quaternion = new this();\n    if (axis instanceof AxisAngle) {\n      quaternion.setFromAxisAngle(new Vector3(axis.x, axis.y, axis.z), axis.angle);\n    } else if (axis instanceof Array) {\n      const axisAngle = new AxisAngle(axis[0], axis[1], axis[2], axis.length === 4 ? axis[3] : null);\n      quaternion.setFromAxisAngle(axisAngle, axisAngle.angle);\n    } else {\n      const axisAngle = new AxisAngle(axis.x, axis.y, axis.z, axis.angle ? axis.angle : null, axis.unit);\n      quaternion.setFromAxisAngle(axisAngle, axisAngle.angle);\n    }\n    return quaternion;\n  }\n  /**\n   * Convert rotation matrix to quaternion\n   *\n   * @param {Quaternion} this This type\n   * @param {Matrix4} matrix Rotation matrix\n   * @returns {Quaternion} Serializable quaternion\n   */\n  static fromRotationMatrix(matrix) {\n    const quaternion = new this();\n    quaternion.setFromRotationMatrix(matrix);\n    return quaternion;\n  }\n  /**\n   * Convert the quaternion to euler angles\n   *\n   * @param {EulerOrder} order Euler order\n   * @returns {Euler} Converted euler\n   */\n  toEuler(order) {\n    return Euler.fromQuaternion(this, order);\n  }\n  /**\n   * Convert the quaternion to axis angles\n   *\n   * @returns {AxisAngle} Converted axis angle\n   */\n  toAxisAngle() {\n    return AxisAngle.fromQuaternion(this);\n  }\n  /**\n   * Convert quaternion to rotation matrix\n   *\n   * @returns {Matrix4} Rotation matrix\n   */\n  toRotationMatrix() {\n    return Matrix4.rotationFromQuaternion(this);\n  }\n  clone() {\n    return new this.constructor().copy(this);\n  }\n};\n__decorate([SerializableMember({\n  numberType: NumberType.DECIMAL\n}), __metadata(\"design:type\", Number)], Quaternion.prototype, \"x\", void 0);\n__decorate([SerializableMember({\n  numberType: NumberType.DECIMAL\n}), __metadata(\"design:type\", Number)], Quaternion.prototype, \"y\", void 0);\n__decorate([SerializableMember({\n  numberType: NumberType.DECIMAL\n}), __metadata(\"design:type\", Number)], Quaternion.prototype, \"z\", void 0);\n__decorate([SerializableMember({\n  type: NumberType.DECIMAL\n}), __metadata(\"design:type\", Number)], Quaternion.prototype, \"w\", void 0);\nQuaternion = Quaternion_1 = __decorate([SerializableObject()], Quaternion);\nexport { Quaternion };","import { __decorate, __metadata } from \"tslib\";\nimport { SerializableObject, SerializableMember, NumberType } from '../../data/decorators';\nimport * as THREE from './_internal';\n/**\n * Serializable THREE.js Vector2\n */\nlet Vector2 = class Vector2 extends THREE.Vector2 {\n  static fromArray(array) {\n    return new this().fromArray(array);\n  }\n  clone() {\n    return new this.constructor().copy(this);\n  }\n};\n__decorate([SerializableMember({\n  numberType: NumberType.DECIMAL\n}), __metadata(\"design:type\", Number)], Vector2.prototype, \"x\", void 0);\n__decorate([SerializableMember({\n  numberType: NumberType.DECIMAL\n}), __metadata(\"design:type\", Number)], Vector2.prototype, \"y\", void 0);\nVector2 = __decorate([SerializableObject()], Vector2);\nexport { Vector2 };","import { __decorate, __metadata } from \"tslib\";\nimport { SerializableObject, SerializableMember, NumberType } from '../../data/decorators';\nimport * as THREE from './_internal';\n/**\n * Serializable THREE.js Vector3\n */\nlet Vector3 = class Vector3 extends THREE.Vector3 {\n  static fromArray(array) {\n    return new this().fromArray(array);\n  }\n  static fromVector(vector) {\n    return new this(vector.x, vector.y, vector.z);\n  }\n  clone() {\n    return new this.constructor().copy(this);\n  }\n};\n__decorate([SerializableMember({\n  numberType: NumberType.DECIMAL\n}), __metadata(\"design:type\", Number)], Vector3.prototype, \"x\", void 0);\n__decorate([SerializableMember({\n  numberType: NumberType.DECIMAL\n}), __metadata(\"design:type\", Number)], Vector3.prototype, \"y\", void 0);\n__decorate([SerializableMember({\n  numberType: NumberType.DECIMAL\n}), __metadata(\"design:type\", Number)], Vector3.prototype, \"z\", void 0);\nVector3 = __decorate([SerializableObject()], Vector3);\nexport { Vector3 };","import { __decorate, __metadata } from \"tslib\";\nimport { SerializableObject, SerializableMember, NumberType } from '../../data/decorators';\nimport * as THREE from './_internal';\n/**\n * Serializable THREE.js Vector4\n */\nlet Vector4 = class Vector4 extends THREE.Vector4 {\n  static fromArray(array) {\n    return new this().fromArray(array);\n  }\n  clone() {\n    return new this.constructor().copy(this);\n  }\n};\n__decorate([SerializableMember({\n  numberType: NumberType.DECIMAL\n}), __metadata(\"design:type\", Number)], Vector4.prototype, \"x\", void 0);\n__decorate([SerializableMember({\n  numberType: NumberType.DECIMAL\n}), __metadata(\"design:type\", Number)], Vector4.prototype, \"y\", void 0);\n__decorate([SerializableMember({\n  numberType: NumberType.DECIMAL\n}), __metadata(\"design:type\", Number)], Vector4.prototype, \"z\", void 0);\n__decorate([SerializableMember({\n  numberType: NumberType.DECIMAL\n}), __metadata(\"design:type\", Number)], Vector4.prototype, \"w\", void 0);\nVector4 = __decorate([SerializableObject()], Vector4);\nexport { Vector4 };","export * from './Euler';\nexport * from './Matrix4';\nexport * from './Quaternion';\nexport * from './Vector2';\nexport * from './Vector3';\nexport * from './Vector4';\nexport * from './AxisAngle';\nexport * from './Vector';\nexport * from './Matrix3';","var AccelerationUnit_1;\nimport { __decorate } from \"tslib\";\nimport { SerializableObject } from '../../data/decorators';\nimport { DerivedUnit } from './DerivedUnit';\nimport { LengthUnit } from './LengthUnit';\nimport { TimeUnit } from './TimeUnit';\n/**\n * @category Unit\n */\nlet AccelerationUnit = AccelerationUnit_1 = class AccelerationUnit extends DerivedUnit {};\nAccelerationUnit.METER_PER_SECOND_SQUARE = new AccelerationUnit_1('meter per second squared', {\n  baseName: 'acceleration',\n  aliases: ['m/s^2', 'm/s2', 'meters per second squared']\n}).addUnit(LengthUnit.METER, 1).addUnit(TimeUnit.SECOND, -2);\nAccelerationUnit.GRAVITATIONAL_FORCE = new AccelerationUnit_1('gravitational force', {\n  baseName: 'acceleration',\n  aliases: ['g-force', 'G', 'GS'],\n  definitions: [{\n    magnitude: 9.78033,\n    unit: 'm/s^2'\n  }]\n});\nAccelerationUnit = AccelerationUnit_1 = __decorate([SerializableObject()], AccelerationUnit);\nexport { AccelerationUnit };","var AngleUnit_1;\nimport { __decorate } from \"tslib\";\nimport { Unit } from './Unit';\nimport { SerializableObject } from '../../data/decorators';\n/**\n * @category Unit\n */\nlet AngleUnit = AngleUnit_1 = class AngleUnit extends Unit {};\nAngleUnit.RADIAN = new AngleUnit_1('radian', {\n  baseName: 'angle',\n  aliases: ['rad', 'rads', 'radians']\n});\nAngleUnit.DEGREE = new AngleUnit_1('degree', {\n  baseName: 'angle',\n  aliases: ['deg', 'degs', 'degrees'],\n  definitions: [{\n    magnitude: Math.PI / 180,\n    unit: 'rad'\n  }]\n});\nAngleUnit = AngleUnit_1 = __decorate([SerializableObject()], AngleUnit);\nexport { AngleUnit };","var AngularVelocityUnit_1;\nimport { __decorate } from \"tslib\";\nimport { SerializableObject } from '../../data/decorators';\nimport { DerivedUnit } from './DerivedUnit';\nimport { AngleUnit } from './AngleUnit';\nimport { TimeUnit } from './TimeUnit';\n/**\n * @category Unit\n */\nlet AngularVelocityUnit = AngularVelocityUnit_1 = class AngularVelocityUnit extends DerivedUnit {};\nAngularVelocityUnit.RADIAN_PER_SECOND = new AngularVelocityUnit_1('radian per second', {\n  baseName: 'angularvelocity',\n  aliases: ['rad/s', 'radians per second']\n}).addUnit(AngleUnit.RADIAN, 1).addUnit(TimeUnit.SECOND, -1);\nAngularVelocityUnit.DEGREE_PER_SECOND = AngularVelocityUnit_1.RADIAN_PER_SECOND.swap([AngleUnit.DEGREE], {\n  baseName: 'angularvelocity',\n  name: 'degree per second',\n  aliases: ['deg/s', 'degrees per second']\n});\nAngularVelocityUnit.RADIAN_PER_MINUTE = AngularVelocityUnit_1.RADIAN_PER_SECOND.swap([TimeUnit.MINUTE], {\n  baseName: 'angularvelocity',\n  name: 'radian per minute',\n  aliases: ['rad/min', 'radian per minute']\n});\nAngularVelocityUnit.DEGREE_PER_MINUTE = AngularVelocityUnit_1.RADIAN_PER_SECOND.swap([AngleUnit.DEGREE, TimeUnit.MINUTE], {\n  baseName: 'angularvelocity',\n  name: 'degree per minute',\n  aliases: ['deg/min', 'degrees per minute']\n});\nAngularVelocityUnit = AngularVelocityUnit_1 = __decorate([SerializableObject()], AngularVelocityUnit);\nexport { AngularVelocityUnit };","import { __decorate } from \"tslib\";\nimport { Unit } from './Unit';\nimport { SerializableObject } from '../../data/decorators';\n/**\n * Derived Unit\n *\n * @category Unit\n */\nlet DerivedUnit = class DerivedUnit extends Unit {\n  constructor() {\n    super(...arguments);\n    this._units = new Map();\n    this._unitPower = new Map();\n  }\n  addUnit(unit, power) {\n    if (this._units.has(unit.baseName)) {\n      throw new Error(`A unit with base name '${unit.baseName}' already exists for this unit!`);\n    }\n    this._units.set(unit.baseName, unit);\n    this._unitPower.set(unit.baseName, power);\n    return this;\n  }\n  swap(subunits, options) {\n    if (Unit.UNITS.has(options.name)) {\n      return Unit.UNITS.get(options.name);\n    }\n    const UnitConstructor = Object.getPrototypeOf(this).constructor;\n    const unit = new UnitConstructor();\n    unit._name = options.name;\n    unit._baseName = this.baseName;\n    unit._aliases = options.aliases ? options.aliases : [];\n    const definition = {\n      unit: this.name,\n      toUnit: undefined,\n      fromUnit: undefined\n    };\n    subunits.forEach(subunit => {\n      const currentUnit = this._units.get(subunit.baseName);\n      const unitPower = this._unitPower.get(subunit.baseName);\n      const newDefinition = subunit.createDefinition(currentUnit);\n      const newToFn = value => Math.pow(newDefinition.toUnit(value), unitPower);\n      const newFromFn = value => Math.pow(newDefinition.fromUnit(value), unitPower);\n      const existingToFn = definition.toUnit;\n      const existingFromFn = definition.fromUnit;\n      if (existingToFn && existingFromFn) {\n        definition.toUnit = value => existingToFn(newToFn(value));\n        definition.fromUnit = value => existingFromFn(newFromFn(value));\n      } else {\n        definition.toUnit = newToFn;\n        definition.fromUnit = newFromFn;\n      }\n    });\n    unit._definitions.set(this.name, definition);\n    return Unit.registerUnit(unit);\n  }\n};\nDerivedUnit = __decorate([SerializableObject()], DerivedUnit);\nexport { DerivedUnit };","var GCS_1;\nimport { __decorate } from \"tslib\";\nimport { SerializableObject } from '../../data/decorators';\nimport { Vector3 } from '../math/Vector3';\nimport { AngleUnit } from './AngleUnit';\nimport { Unit } from './Unit';\n/**\n * Geodetic coordinate system.\n */\nlet GCS = GCS_1 = class GCS extends Unit {\n  /**\n   * @deprecated Use GCS.EARTH_RADIUS_MEAN\n   * @returns {number} Mean earth radius\n   */\n  static get EARTH_RADIUS() {\n    return GCS_1.EARTH_RADIUS_MEAN;\n  }\n};\nGCS.EARTH_RADIUS_MEAN = 6371008.7714;\nGCS.EARTH_EQUATORIAL_RADIUS = 6378137;\nGCS.EARTH_POLAR_RADIUS = 6356752.3142;\nGCS.EARTH_ECCENTRICITY = 8.1819190842622e-2;\nGCS.EPSG4326 = new GCS_1('EPSG:4326', {\n  baseName: 'gcs',\n  aliases: ['WGS84', 'World Geodetic System']\n});\nGCS.WGS84 = GCS_1.EPSG4326;\nGCS.ECEF = new GCS_1('ECEF', {\n  baseName: 'gcs',\n  aliases: ['earth-centered, earth-fixed', 'ECR', 'earth centered rotational'],\n  definitions: [{\n    unit: 'EPSG:4326',\n    toUnit: input => {\n      /* @see {@link https://gis.stackexchange.com/questions/265909/converting-from-ecef-to-geodetic-coordinates} */\n      const f = 1.0 / 298.257223563;\n      const a = GCS_1.EARTH_EQUATORIAL_RADIUS;\n      const b = a - f * a;\n      const e = Math.sqrt(Math.pow(a, 2) - Math.pow(b, 2)) / a;\n      const clambda = Math.atan2(input.y, input.x);\n      const p = Math.sqrt(Math.pow(input.x, 2.0) + Math.pow(input.y, 2));\n      let h_old = 0.0;\n      // First guess with h=0 meters\n      let theta = Math.atan2(input.z, p * (1.0 - Math.pow(e, 2.0)));\n      let cs = Math.cos(theta);\n      let sn = Math.sin(theta);\n      let N = Math.pow(a, 2.0) / Math.sqrt(Math.pow(a * cs, 2.0) + Math.pow(b * sn, 2.0));\n      let h = p / cs - N;\n      while (Math.abs(h - h_old) > 1.0e-6) {\n        h_old = h;\n        theta = Math.atan2(input.z, p * (1.0 - Math.pow(e, 2.0) * N / (N + h)));\n        cs = Math.cos(theta);\n        sn = Math.sin(theta);\n        N = Math.pow(a, 2.0) / Math.sqrt(Math.pow(a * cs, 2.0) + Math.pow(b * sn, 2.0));\n        h = p / cs - N;\n      }\n      return new Vector3(AngleUnit.RADIAN.convert(clambda, AngleUnit.DEGREE), AngleUnit.RADIAN.convert(theta, AngleUnit.DEGREE), h);\n    },\n    fromUnit: input => {\n      var _a;\n      const phi = AngleUnit.DEGREE.convert(input.y, AngleUnit.RADIAN);\n      const lambda = AngleUnit.DEGREE.convert(input.x, AngleUnit.RADIAN);\n      const height = (_a = input.z) !== null && _a !== void 0 ? _a : 0;\n      const clat = Math.cos(phi);\n      const slat = Math.sin(phi);\n      const clon = Math.cos(lambda);\n      const slon = Math.sin(lambda);\n      const N = GCS_1.EARTH_EQUATORIAL_RADIUS / Math.sqrt(1.0 - Math.pow(GCS_1.EARTH_ECCENTRICITY, 2) * Math.pow(slat, 2));\n      return new Vector3((N + height) * clat * clon, (N + height) * clat * slon, (N * (1 - Math.pow(GCS_1.EARTH_ECCENTRICITY, 2)) + height) * slat);\n    }\n  }]\n});\nGCS.EPSG3857 = new GCS_1('EPSG:3857', {\n  baseName: 'gcs',\n  aliases: ['pseudo mercator', 'web mercator'],\n  definitions: [{\n    unit: 'EPSG:4326',\n    fromUnit: input => {\n      return new Vector3(input.x * 20037508.34 / 180, Math.log(Math.tan((90 + input.y) * Math.PI / 360)) / (Math.PI / 180) * 20037508.34 / 180, 0);\n    },\n    toUnit: input => {\n      return new Vector3(input.x * 180 / 20037508.34, Math.atan(Math.exp(input.y * Math.PI / 20037508.34)) * 360 / Math.PI - 90, input.z);\n    }\n  }]\n});\nGCS = GCS_1 = __decorate([SerializableObject()], GCS);\nexport { GCS };","var LengthUnit_1;\nimport { __decorate } from \"tslib\";\nimport { Unit } from './Unit';\nimport { SerializableObject } from '../../data/decorators';\nimport { UnitPrefix } from './UnitPrefix';\n/**\n * @category Unit\n */\nlet LengthUnit = LengthUnit_1 = class LengthUnit extends Unit {};\nLengthUnit.METER = new LengthUnit_1('meter', {\n  baseName: 'length',\n  aliases: ['m', 'meters'],\n  prefixes: 'decimal'\n});\nLengthUnit.CENTIMETER = LengthUnit_1.METER.specifier(UnitPrefix.CENTI);\nLengthUnit.MILLIMETER = LengthUnit_1.METER.specifier(UnitPrefix.MILLI);\nLengthUnit.KILOMETER = LengthUnit_1.METER.specifier(UnitPrefix.KILO);\nLengthUnit.MILE = new LengthUnit_1('mile', {\n  baseName: 'length',\n  aliases: ['mil', 'miles'],\n  definitions: [{\n    unit: 'meter',\n    magnitude: 1609.344\n  }]\n});\nLengthUnit = LengthUnit_1 = __decorate([SerializableObject()], LengthUnit);\nexport { LengthUnit };","var LinearVelocityUnit_1;\nimport { __decorate } from \"tslib\";\nimport { SerializableObject } from '../../data/decorators';\nimport { DerivedUnit } from './DerivedUnit';\nimport { LengthUnit } from './LengthUnit';\nimport { TimeUnit } from './TimeUnit';\n/**\n * @category Unit\n */\nlet LinearVelocityUnit = LinearVelocityUnit_1 = class LinearVelocityUnit extends DerivedUnit {};\nLinearVelocityUnit.METER_PER_SECOND = new LinearVelocityUnit_1('meter per second', {\n  baseName: 'linearvelocity',\n  aliases: ['m/s', 'meters per second']\n}).addUnit(LengthUnit.METER, 1).addUnit(TimeUnit.SECOND, -1);\nLinearVelocityUnit.CENTIMETER_PER_SECOND = LinearVelocityUnit_1.METER_PER_SECOND.swap([LengthUnit.CENTIMETER], {\n  baseName: 'linearvelocity',\n  name: 'centimeter per minute',\n  aliases: ['cm/min', 'centimeters per minute']\n});\nLinearVelocityUnit = LinearVelocityUnit_1 = __decorate([SerializableObject()], LinearVelocityUnit);\nexport { LinearVelocityUnit };","var LuminanceIntensityUnit_1;\nimport { __decorate } from \"tslib\";\nimport { Unit } from './Unit';\nimport { SerializableObject } from '../../data/decorators';\n/**\n * @category Unit\n */\nlet LuminanceIntensityUnit = LuminanceIntensityUnit_1 = class LuminanceIntensityUnit extends Unit {};\nLuminanceIntensityUnit.CANDELA = new LuminanceIntensityUnit_1('candela', {\n  baseName: 'luminanceintensity',\n  aliases: ['cd']\n});\nLuminanceIntensityUnit = LuminanceIntensityUnit_1 = __decorate([SerializableObject()], LuminanceIntensityUnit);\nexport { LuminanceIntensityUnit };","var LuminanceUnit_1;\nimport { __decorate } from \"tslib\";\nimport { Unit } from './Unit';\nimport { SerializableObject } from '../../data/decorators';\n/**\n * @category Unit\n */\nlet LuminanceUnit = LuminanceUnit_1 = class LuminanceUnit extends Unit {};\nLuminanceUnit.LUMEN = new LuminanceUnit_1('lumen', {\n  baseName: 'luminance',\n  aliases: ['lm'],\n  prefixes: 'decimal'\n});\nLuminanceUnit = LuminanceUnit_1 = __decorate([SerializableObject()], LuminanceUnit);\nexport { LuminanceUnit };","var MagnetismUnit_1;\nimport { __decorate } from \"tslib\";\nimport { Unit } from './Unit';\nimport { SerializableObject } from '../../data/decorators';\nimport { UnitPrefix } from './UnitPrefix';\n/**\n * @category Unit\n */\nlet MagnetismUnit = MagnetismUnit_1 = class MagnetismUnit extends Unit {};\nMagnetismUnit.TESLA = new MagnetismUnit_1('tesla', {\n  baseName: 'magnetism',\n  aliases: ['T'],\n  prefixes: 'decimal'\n});\nMagnetismUnit.MICROTESLA = MagnetismUnit_1.TESLA.specifier(UnitPrefix.MICRO);\nMagnetismUnit = MagnetismUnit_1 = __decorate([SerializableObject()], MagnetismUnit);\nexport { MagnetismUnit };","var PressureUnit_1;\nimport { __decorate } from \"tslib\";\nimport { Unit } from './Unit';\nimport { SerializableObject } from '../../data/decorators';\n/**\n * @category Unit\n */\nlet PressureUnit = PressureUnit_1 = class PressureUnit extends Unit {};\nPressureUnit.PASCAL = new PressureUnit_1('pascal', {\n  baseName: 'pressure',\n  aliases: ['P'],\n  prefixes: 'decimal'\n});\nPressureUnit = PressureUnit_1 = __decorate([SerializableObject()], PressureUnit);\nexport { PressureUnit };","var TemperatureUnit_1;\nimport { __decorate } from \"tslib\";\nimport { Unit } from './Unit';\nimport { SerializableObject } from '../../data/decorators';\n/**\n * @category Unit\n */\nlet TemperatureUnit = TemperatureUnit_1 = class TemperatureUnit extends Unit {};\nTemperatureUnit.CELCIUS = new TemperatureUnit_1('celcius', {\n  baseName: 'temperature'\n});\nTemperatureUnit.FAHRENHEIT = new TemperatureUnit_1('fahrenheit', {\n  baseName: 'temperature',\n  definitions: [{\n    unit: 'celcius',\n    offset: -32,\n    magnitude: 5 / 9\n  }]\n});\nTemperatureUnit.KELVIN = new TemperatureUnit_1('kelvin', {\n  baseName: 'temperature',\n  definitions: [{\n    unit: 'celcius',\n    offset: -273.15\n  }]\n});\nTemperatureUnit.RANKINE = new TemperatureUnit_1('rankine', {\n  baseName: 'temperature',\n  definitions: [{\n    unit: 'kelvin',\n    magnitude: 1 / 1.8\n  }]\n});\nTemperatureUnit = TemperatureUnit_1 = __decorate([SerializableObject()], TemperatureUnit);\nexport { TemperatureUnit };","var TimeUnit_1;\nimport { __decorate } from \"tslib\";\nimport { Unit } from './Unit';\nimport { SerializableObject } from '../../data/decorators';\nimport { UnitPrefix } from './UnitPrefix';\n/**\n * @category Unit\n */\nlet TimeUnit = TimeUnit_1 = class TimeUnit extends Unit {};\nTimeUnit.SECOND = new TimeUnit_1('second', {\n  baseName: 'time',\n  aliases: ['s', 'sec', 'seconds'],\n  prefixes: 'decimal'\n});\nTimeUnit.MILLISECOND = TimeUnit_1.SECOND.specifier(UnitPrefix.MILLI);\nTimeUnit.MICROSECOND = TimeUnit_1.SECOND.specifier(UnitPrefix.MICRO);\nTimeUnit.NANOSECOND = TimeUnit_1.SECOND.specifier(UnitPrefix.NANO);\nTimeUnit.MINUTE = new TimeUnit_1('minute', {\n  baseName: 'time',\n  aliases: ['m', 'min', 'minutes'],\n  definitions: [{\n    magnitude: 60,\n    unit: 's'\n  }]\n});\nTimeUnit.HOUR = new TimeUnit_1('hour', {\n  baseName: 'time',\n  aliases: ['h', 'hr', 'hrs', 'hours'],\n  definitions: [{\n    magnitude: 3600,\n    unit: 's'\n  }, {\n    magnitude: 60,\n    unit: 'min'\n  }]\n});\nTimeUnit = TimeUnit_1 = __decorate([SerializableObject()], TimeUnit);\nexport { TimeUnit };","var Unit_1;\nimport { __decorate, __metadata } from \"tslib\";\nimport 'reflect-metadata';\nimport { SerializableObject, SerializableMember } from '../../data/decorators';\nimport { UnitPrefix } from './UnitPrefix';\n/**\n * Unit\n *\n * ## Usage\n * ### Creation\n * ```typescript\n * const myUnit = new Unit(\"meter\", {\n *  baseName: \"length\",\n *  aliases: [\"m\", \"meters\"],\n *  prefixes: 'decimal'\n * })\n * ```\n *\n * ### Specifiers\n * You can specify the prefix using the ```specifier(...)``` function.\n * ```typescript\n * const nanoUnit = myUnit.specifier(UnitPrefix.NANO);\n * ```\n *\n * @category Unit\n */\nlet Unit = Unit_1 = class Unit {\n  /**\n   * Create a new unit\n   *\n   * @param {string} name Unit name\n   * @param {UnitOptions} options Unit options\n   */\n  constructor(name, options) {\n    this._definitions = new Map();\n    this._prefixType = 'none';\n    this._aliases = [];\n    const config = options || {\n      baseName: undefined\n    };\n    config.aliases = config.aliases || [];\n    config.prefixes = config.prefixes || 'none';\n    config.definitions = config.definitions || [];\n    // Unit config\n    this._name = name || config.name;\n    this._baseName = config.baseName;\n    this._aliases = config.aliases;\n    this._prefixType = config.prefixes;\n    // Unit definitions\n    config.definitions.forEach(this._initDefinition.bind(this));\n    if (this.name) {\n      Unit_1.registerUnit(this, config.override);\n    }\n  }\n  /**\n   * Get a unit from JSON\n   *\n   * @param {any} json JSON object\n   * @returns {Unit} Unit if found\n   */\n  static fromJSON(json) {\n    if (json.name !== undefined) {\n      const unit = Unit_1.findByName(json.name);\n      if (!unit) {\n        throw new Error(`Unit with name '${json.name}' not found! Unable to deserialize!`);\n      }\n      return unit;\n    } else {\n      throw new Error(`Unit does not define a serialization name! Unable to deserialize!`);\n    }\n  }\n  _initDefinition(definition) {\n    const referenceUnit = Unit_1.findByName(definition.unit, this.baseName);\n    const unitName = referenceUnit ? referenceUnit.name : definition.unit;\n    if ('toUnit' in definition) {\n      // UnitFunctionDefinition\n      this._initFunctionDefinition(definition, unitName);\n    } else {\n      // UnitBasicDefinition\n      this._initBasicDefinition(definition, unitName);\n    }\n  }\n  _initFunctionDefinition(definition, unitName) {\n    const functionDefinition = definition;\n    this._definitions.set(unitName, functionDefinition);\n  }\n  _initBasicDefinition(definition, unitName) {\n    const definitionKeys = Object.keys(definition);\n    const basicDefinition = definition;\n    const magnitudeOrder = definitionKeys.indexOf('magnitude');\n    const offsetOrder = definitionKeys.indexOf('offset');\n    const magnitude = basicDefinition.magnitude || 1;\n    const offset = basicDefinition.offset !== undefined ? basicDefinition.offset : 0;\n    const offsetPriority = magnitudeOrder === -1 ? true : offsetOrder < magnitudeOrder;\n    let toUnitFn;\n    let fromUnitFn;\n    if (offsetPriority) {\n      toUnitFn = value => (value + offset) * magnitude;\n      fromUnitFn = value => value / magnitude - offset;\n    } else {\n      toUnitFn = value => value * magnitude + offset;\n      fromUnitFn = value => (value - offset) / magnitude;\n    }\n    this._definitions.set(unitName, {\n      unit: basicDefinition.unit,\n      toUnit: toUnitFn,\n      fromUnit: fromUnitFn\n    });\n  }\n  /**\n   * Unit name\n   *\n   * @returns {string} Name\n   */\n  get name() {\n    return this._name;\n  }\n  set name(name) {\n    this._name = name;\n    const existingUnit = Unit_1.findByName(name);\n    if (existingUnit) {\n      this._baseName = existingUnit.baseName;\n      this._definitions = existingUnit._definitions;\n      this._prefixType = existingUnit._prefixType;\n      this._aliases = existingUnit._aliases;\n    }\n  }\n  /**\n   * Unit aliases\n   *\n   * @returns {string[]} Alias names as array\n   */\n  get aliases() {\n    return this._aliases;\n  }\n  get baseName() {\n    return this._baseName;\n  }\n  get prefixType() {\n    return this._prefixType;\n  }\n  get definitions() {\n    return Array.from(this._definitions.values());\n  }\n  get prefixes() {\n    switch (this._prefixType) {\n      case 'decimal':\n        return UnitPrefix.DECIMAL;\n      case 'none':\n        return [];\n    }\n  }\n  /**\n   * Get or create a definition from this unit to the base\n   *\n   * @returns {UnitFunctionDefinition} Definition to base\n   */\n  createBaseDefinition() {\n    let newDefinition;\n    // Get base unit\n    const baseUnitName = Unit_1.UNIT_BASES.get(this.baseName);\n    if (this._definitions.has(baseUnitName)) {\n      const definition = this._definitions.get(baseUnitName);\n      newDefinition = definition;\n    } else {\n      this._definitions.forEach(definition => {\n        const unit = Unit_1.findByName(definition.unit, this.baseName);\n        const baseDefinition = unit.createBaseDefinition();\n        if (baseDefinition) {\n          newDefinition = {\n            unit: baseDefinition.unit,\n            toUnit: value => baseDefinition.toUnit(definition.toUnit(value)),\n            fromUnit: value => definition.fromUnit(baseDefinition.fromUnit(value))\n          };\n          return;\n        }\n      });\n    }\n    return newDefinition;\n  }\n  createDefinition(targetUnit) {\n    let newDefinition;\n    // Get base unit\n    const baseUnitName = Unit_1.UNIT_BASES.get(this.baseName);\n    const baseUnit = Unit_1.findByName(baseUnitName);\n    if (this._definitions.has(targetUnit.name)) {\n      // Direct conversion\n      const definition = this._definitions.get(targetUnit.name);\n      newDefinition = definition;\n    } else if (targetUnit._definitions.has(this.name)) {\n      // Reverse conversion\n      const definition = targetUnit._definitions.get(this.name);\n      newDefinition = {\n        unit: targetUnit.name,\n        toUnit: definition.fromUnit,\n        fromUnit: definition.toUnit\n      };\n      this._definitions.set(targetUnit.name, newDefinition);\n    } else if (baseUnit.name !== this.name) {\n      // No direct conversion found, convert to base unit\n      const currentToBase = this._definitions.get(baseUnitName);\n      const baseToTarget = baseUnit.createDefinition(targetUnit);\n      // Convert unit if definitions are found\n      if (currentToBase && baseToTarget) {\n        newDefinition = {\n          unit: targetUnit.name,\n          toUnit: value => baseToTarget.toUnit(currentToBase.toUnit(value)),\n          fromUnit: value => currentToBase.fromUnit(baseToTarget.fromUnit(value))\n        };\n        this._definitions.set(targetUnit.name, newDefinition);\n      }\n    }\n    return newDefinition;\n  }\n  /**\n   * Get the unit specifier\n   *\n   * @param {UnitPrefix} prefix Unit prefix\n   * @returns {Unit} Unit with specifier\n   */\n  specifier(prefix) {\n    // Check if the unit already exists\n    const unitName = `${prefix.name}${this.name}`;\n    if (Unit_1.UNITS.has(unitName)) {\n      return Unit_1.UNITS.get(unitName);\n    }\n    // Confirm that the prefix is allowed\n    if (!this.prefixes.includes(prefix)) throw new Error(`Prefix '${prefix.name}' is not allowed for this unit!`);\n    // Get the unit constructor of the extended class. This allows\n    // serializing of units that are extended (e.g. LengthUnit)\n    const UnitConstructor = Object.getPrototypeOf(this).constructor;\n    const unit = new UnitConstructor();\n    unit._name = unitName;\n    unit._baseName = this.baseName;\n    const aliases = [];\n    this.aliases.forEach(alias => {\n      aliases.push(`${prefix.name}${alias}`);\n      aliases.push(`${prefix.abbrevation}${alias}`);\n    });\n    unit._aliases = aliases;\n    unit._definitions.set(this.name, {\n      unit: this.name,\n      toUnit: value => value * prefix.magnitude,\n      fromUnit: value => value / prefix.magnitude\n    });\n    return Unit_1.registerUnit(unit);\n  }\n  /**\n   * Find unit specifier by name or alias\n   *\n   * @param {string} name Unit name\n   * @returns {Unit | undefined} Unit if found\n   */\n  findByName(name) {\n    // Check all aliases in those units\n    for (const alias of this.aliases.concat(this.name)) {\n      if (name === alias) {\n        // Exact match with alias\n        return this;\n      } else if (name.endsWith(alias)) {\n        // Unit that we are looking for ends with the alias\n        // confirm that there is a prefix match\n        for (const prefix of this.prefixes) {\n          if (name.match(prefix.abbrevationPattern) || name.match(prefix.namePattern)) {\n            return this.specifier(prefix);\n          }\n        }\n      }\n    }\n    return undefined;\n  }\n  /**\n   * Find a unit by its name\n   *\n   * @param {string} name Unit name\n   * @param {string} baseName Optional base name to specific result\n   * @returns {Unit | undefined} Unit if found\n   */\n  static findByName(name, baseName) {\n    if (name === undefined) {\n      return undefined;\n    } else if (Unit_1.UNITS.has(name)) {\n      return Unit_1.UNITS.get(name);\n    } else {\n      // Check all units\n      for (const [, unit] of Unit_1.UNITS) {\n        if (baseName ? baseName !== unit.baseName : false) {\n          continue;\n        }\n        // Check all aliases in those units\n        const result = unit.findByName(name);\n        if (result) {\n          return result;\n        }\n      }\n      return undefined;\n    }\n  }\n  /**\n   * Convert a value in the current unit to a target unit\n   *\n   * @param {UnitValueType} value Value to convert\n   * @param {string | Unit} target Target unit\n   * @returns {number} Converted unit\n   */\n  convert(value, target) {\n    const targetUnit = target instanceof Unit_1 ? target : Unit_1.findByName(target, this.baseName);\n    // Do not convert if target unit is the same or undefined\n    if (!targetUnit || targetUnit.name === this.name) {\n      return value;\n    }\n    const definition = this.createDefinition(targetUnit);\n    if (!definition) {\n      throw new Error(`No conversion definition found from '${this.name}' to '${targetUnit.name}'!`);\n    } else {\n      return definition.toUnit(value);\n    }\n  }\n  /**\n   * Convert a value from a specific unit to a target unit\n   *\n   * @param {UnitValueType} value Value to convert\n   * @param {string | Unit} from Source unit\n   * @param {string | Unit} to Target unit\n   * @returns {UnitValueType} Converted unit\n   */\n  static convert(value, from, to) {\n    const fromUnit = typeof from === 'string' ? Unit_1.findByName(from) : from;\n    return fromUnit.convert(value, to);\n  }\n  /**\n   * Register a new unit\n   *\n   * @param {Unit} unit Unit to register\n   * @param {boolean} override Override an existing unit with the same name\n   * @returns {Unit} Registered unit\n   */\n  static registerUnit(unit, override = false) {\n    if (!unit.name) {\n      return unit;\n    }\n    // Register unit if it does not exist yet\n    if (!Unit_1.UNITS.has(unit.name) || override) {\n      Unit_1.UNITS.set(unit.name, unit);\n    }\n    // Check if the unit is a new base unit\n    const baseName = unit.baseName ? unit.baseName : unit.name;\n    const baseUnitName = Unit_1.UNIT_BASES.get(baseName);\n    if (!baseUnitName) {\n      Unit_1.UNIT_BASES.set(baseName, unit.name);\n    } else {\n      // Confirm that the unit can be converted to a base unit\n      const baseUnit = Unit_1.findByName(baseUnitName, baseName);\n      const fromBase = baseUnit.createDefinition(unit);\n      const toBase = unit.createBaseDefinition();\n      if (!fromBase) {\n        // No conversion definition\n        unit._definitions.set(baseUnitName, toBase);\n      }\n    }\n    return unit;\n  }\n};\n// Unit bases (e.g. length, time, velocity, ...)\nUnit.UNIT_BASES = new Map();\n// Units (e.g. second, meter, ...)\nUnit.UNITS = new Map();\nUnit.UNKNOWN = new Unit_1('unknown');\n__decorate([SerializableMember(), __metadata(\"design:type\", String), __metadata(\"design:paramtypes\", [String])], Unit.prototype, \"name\", null);\nUnit = Unit_1 = __decorate([SerializableObject({\n  initializer: Unit_1.fromJSON\n}), __metadata(\"design:paramtypes\", [String, Object])], Unit);\nexport { Unit };","/**\n * @category Unit\n */\nexport class UnitPrefix {\n  constructor(name, abbrevation, magnitude) {\n    this.name = name;\n    this.abbrevation = abbrevation;\n    this.magnitude = magnitude;\n  }\n  get namePattern() {\n    return new RegExp(`/^${this.name}/g`);\n  }\n  get abbrevationPattern() {\n    return new RegExp(`/^${this.abbrevation}/g`);\n  }\n}\nUnitPrefix.DECA = new UnitPrefix('deca', 'da', 1e1);\nUnitPrefix.HECTO = new UnitPrefix('hecto', 'h', 1e2);\nUnitPrefix.KILO = new UnitPrefix('kilo', 'k', 1e3);\nUnitPrefix.MEGA = new UnitPrefix('mega', 'M', 1e6);\nUnitPrefix.GIGA = new UnitPrefix('giga', 'G', 1e9);\nUnitPrefix.TERA = new UnitPrefix('tera', 'T', 1e12);\nUnitPrefix.PETA = new UnitPrefix('peta', 'P', 1e15);\nUnitPrefix.EXA = new UnitPrefix('exa', 'E', 1e18);\nUnitPrefix.ZETTA = new UnitPrefix('zetta', 'Z', 1e21);\nUnitPrefix.YOTTA = new UnitPrefix('yotta', 'Y', 1e24);\nUnitPrefix.DECI = new UnitPrefix('deci', 'd', 1e-1);\nUnitPrefix.CENTI = new UnitPrefix('centi', 'c', 1e-2);\nUnitPrefix.MILLI = new UnitPrefix('milli', 'm', 1e-3);\nUnitPrefix.MICRO = new UnitPrefix('micro', 'u', 1e-6);\nUnitPrefix.NANO = new UnitPrefix('nano', 'n', 1e-9);\nUnitPrefix.PICO = new UnitPrefix('pico', 'p', 1e-12);\nUnitPrefix.FEMTO = new UnitPrefix('femto', 'f', 1e-15);\nUnitPrefix.ATTO = new UnitPrefix('atto', 'a', 1e-18);\nUnitPrefix.ZEPTO = new UnitPrefix('zepto', 'z', 1e-21);\nUnitPrefix.YOCTO = new UnitPrefix('yocto', 'y', 1e-24);\nUnitPrefix.DECIMAL = [UnitPrefix.DECA, UnitPrefix.HECTO, UnitPrefix.KILO, UnitPrefix.MEGA, UnitPrefix.GIGA, UnitPrefix.TERA, UnitPrefix.PETA, UnitPrefix.EXA, UnitPrefix.ZETTA, UnitPrefix.YOTTA, UnitPrefix.DECI, UnitPrefix.CENTI, UnitPrefix.MILLI, UnitPrefix.MICRO, UnitPrefix.NANO, UnitPrefix.PICO, UnitPrefix.FEMTO, UnitPrefix.ATTO, UnitPrefix.ZEPTO, UnitPrefix.YOCTO];","import { __decorate, __metadata } from \"tslib\";\nimport { SerializableMember, SerializableObject } from '../../data/decorators';\n/**\n * Unit value\n *\n * ## Usage\n * ### Creation\n * ```typescript\n * const value = new UnitValue(5, LengthUnit.METER);\n * ```\n *\n * ### Conversion\n * ```typescript\n * const value = new UnitValue(5, LengthUnit.METER);\n * const converted = value.to(LengthUnit.CENTIMETER);\n * ```\n *\n * @category Unit\n */\nlet UnitValue = class UnitValue {\n  constructor(value, unit) {\n    this._value = value;\n    this._unit = unit;\n  }\n  /**\n   * Convert the value to another unit\n   *\n   * @param {Unit} unit Target unit\n   * @returns {UnitValue} Converted value\n   */\n  to(unit) {\n    if (!unit) {\n      throw new Error(`${this.constructor.name} does not have a unit to convert from!`);\n    }\n    const result = this.unit.convert(this.valueOf(), unit);\n    return new this.constructor(result, unit);\n  }\n  /**\n   * Unit this value is in\n   *\n   * @returns {Unit} Unit this value is in\n   */\n  get unit() {\n    return this._unit;\n  }\n  /**\n   * Returns a string representation of an object.\n   *\n   * @returns {string} Unit value as string\n   */\n  toString() {\n    return this.valueOf().toString();\n  }\n  /**\n   * Returns the primitive value\n   *\n   * @returns {number} Primitive value\n   */\n  valueOf() {\n    return this._value;\n  }\n  setValue(value) {\n    this._value = value;\n    return this;\n  }\n  clone() {\n    const result = new this.constructor();\n    result._value = this._value;\n    result._unit = this._unit;\n    return result;\n  }\n};\n__decorate([SerializableMember({\n  name: 'value'\n}), __metadata(\"design:type\", Object)], UnitValue.prototype, \"_value\", void 0);\n__decorate([SerializableMember({\n  name: 'unit'\n}), __metadata(\"design:type\", Object)], UnitValue.prototype, \"_unit\", void 0);\nUnitValue = __decorate([SerializableObject(), __metadata(\"design:paramtypes\", [Object, Object])], UnitValue);\nexport { UnitValue };","export * from './Unit';\nexport * from './UnitDefinition';\nexport * from './UnitPrefix';\nexport * from './UnitOptions';\nexport * from './DerivedUnit';\nexport * from './UnitValue';\nexport * from './AngleUnit';\nexport * from './AngularVelocityUnit';\nexport * from './TimeUnit';\nexport * from './LengthUnit';\nexport * from './LinearVelocityUnit';\nexport * from './AccelerationUnit';\nexport * from './MagnetismUnit';\nexport * from './GCS';\nexport * from './TemperatureUnit';\nexport * from './LuminanceIntensityUnit';\nexport * from './LuminanceUnit';\nexport * from './PressureUnit';","import { Pool, spawn, Worker } from 'threads';\nimport { DataSerializer } from '../data/DataSerializer';\nimport { DataService } from '../service/DataService';\nimport { WorkerServiceProxy } from '../service/WorkerServiceProxy';\nimport { AsyncEventEmitter } from '../_internal/AsyncEventEmitter';\nimport { DummyDataService } from '../service/DummyDataService';\nimport { DummyService } from '../service/DummyService';\nexport class WorkerHandler extends AsyncEventEmitter {\n  constructor(model, options, config) {\n    var _a;\n    super();\n    this._serviceOutputResponse = new Map();\n    this.model = model;\n    this.config = config;\n    this.options = options;\n    this.options.timeout = (_a = this.options.timeout) !== null && _a !== void 0 ? _a : 10000;\n  }\n  build() {\n    return new Promise(resolve => {\n      if (typeof process.env.NODE_ENV === 'undefined') {\n        // eslint-disable-next-line\n        const NativeWorker = typeof __non_webpack_require__ === \"function\" ? __non_webpack_require__(\"worker_threads\").Worker : eval(\"require\")(\"worker_threads\").Worker;\n        if (NativeWorker) {\n          NativeWorker.defaultMaxListeners = 0;\n        }\n      }\n      this._pool = Pool(() => this._spawnWorker(), {\n        size: this.options.poolSize || 4,\n        concurrency: this.options.poolConcurrency || 2\n      });\n      this._pool.events().subscribe(value => {\n        if (value.type === 'initialized') {\n          resolve();\n        }\n      });\n    });\n  }\n  destroy() {\n    return new Promise((resolve, reject) => {\n      if (this._pool === undefined) {\n        return resolve();\n      }\n      const timeout = setTimeout(() => {\n        this._pool.terminate(true).then(() => {\n          resolve();\n        }).catch(ex => {\n          reject(ex);\n        });\n      }, 2500);\n      this._pool.terminate().then(() => {\n        clearTimeout(timeout);\n        resolve();\n      }).catch(ex => {\n        clearTimeout(timeout);\n        reject(ex);\n      });\n    });\n  }\n  pull(options) {\n    return new Promise((resolve, reject) => {\n      // Pass the pull request to the worker\n      this._pool.queue(worker => {\n        const pullFn = worker.pull;\n        return pullFn(options);\n      }).then(resolve).catch(reject);\n    });\n  }\n  push(frame, options) {\n    return new Promise((resolve, reject) => {\n      this._pool.queue(worker => {\n        const pushFn = worker.push;\n        return pushFn(DataSerializer.serialize(frame), options);\n      }).then(() => {\n        resolve();\n      }).catch(reject);\n    });\n  }\n  /**\n   * Spawn a single worker\n   *  This method can be called multiple times in a pool\n   *\n   * @returns {Promise<Thread>} Thread spawn promise\n   */\n  _spawnWorker() {\n    return new Promise((resolve, reject) => {\n      // NOTE: We can not use a conditional expression as this breaks the webpack threads plugin\n      const worker = new Worker(this.options.worker);\n      spawn(worker, {\n        timeout: this.options.timeout\n      }).then(thread => {\n        const init = thread.init;\n        const pushOutput = thread.pushOutput;\n        const pullOutput = thread.pullOutput;\n        const serviceOutputCall = thread.serviceOutputCall;\n        const serviceInputCall = thread.serviceInputCall;\n        const eventOutput = thread.eventOutput;\n        const findAllServices = thread.findAllServices;\n        const threadId = worker.threadId;\n        this._serviceOutputResponse.set(threadId, thread.serviceOutputResponse);\n        // Subscribe to the workers pull, push and service functions\n        pullOutput().subscribe(this._onWorkerPull.bind(this));\n        pushOutput().subscribe(this._onWorkerPush.bind(this));\n        serviceOutputCall().subscribe(this._onWorkerService.bind(this, threadId));\n        eventOutput().subscribe(this._onWorkerEvent.bind(this));\n        // Initialize the worker\n        init(Object.assign({\n          directory: this.options.directory || __dirname,\n          services: this._getServices(),\n          imports: this.options.imports || [],\n          args: this.options.args || {}\n        }, this.config)).then(() => {\n          return findAllServices();\n        }).then(services => {\n          this._addServices(services, serviceInputCall);\n          resolve(thread);\n        }).catch(reject);\n      }).catch(reject);\n    });\n  }\n  /**\n   * Serialize the services of this model\n   *\n   * @returns {any[]} Services array\n   */\n  _getServices() {\n    // Serialize this model services to the worker\n    const services = this.options.services || this.model.findAllServices();\n    const servicesArray = services.map(service => {\n      // Services are wrapped in a proxy. Get prototype\n      const serviceBase = Object.getPrototypeOf(service);\n      return {\n        uid: service.uid,\n        type: serviceBase.constructor.name,\n        dataType: service instanceof DataService ? service.dataType ? service.dataType.name : undefined : undefined\n      };\n    });\n    return servicesArray;\n  }\n  _addServices(services, call) {\n    const model = this.model;\n    services.filter(service => {\n      const internalService = this.model.findService(service.name) || this.model.findDataService(service.name);\n      return internalService === undefined;\n    }).forEach(service => {\n      if (service.dataType) {\n        const DataType = DataSerializer.findTypeByName(service.dataType);\n        model.addService(new DummyDataService(service.uid, DataType), new WorkerServiceProxy({\n          uid: service.uid,\n          callFunction: call\n        }));\n      } else {\n        model.addService(new DummyService(service.uid), new WorkerServiceProxy({\n          uid: service.uid,\n          callFunction: call\n        }));\n      }\n    });\n  }\n  _onWorkerService(threadId, value) {\n    const service = this.model.findDataService(value.serviceUID) || this.model.findService(value.serviceUID);\n    if (service[value.method]) {\n      const serializedParams = value.parameters;\n      const params = [];\n      serializedParams.forEach(param => {\n        if (param['__type']) {\n          params.push(DataSerializer.deserialize(param));\n        } else {\n          params.push(param);\n        }\n      });\n      const promise = service[value.method](...params);\n      Promise.resolve(promise).then(_ => {\n        if (Array.isArray(_)) {\n          const result = [];\n          _.forEach(r => {\n            result.push(DataSerializer.serialize(r));\n          });\n          this._serviceOutputResponse.get(threadId)({\n            id: value.id,\n            success: true,\n            result\n          });\n        } else {\n          const result = DataSerializer.serialize(_);\n          this._serviceOutputResponse.get(threadId)({\n            id: value.id,\n            success: true,\n            result\n          });\n        }\n      }).catch(ex => {\n        this._serviceOutputResponse.get(threadId)({\n          id: value.id,\n          success: false,\n          result: ex\n        });\n      });\n    }\n  }\n  _onWorkerEvent(value) {\n    this.emit('event', value);\n  }\n  /**\n   * Triggered for each worker that requests a pull\n   *\n   * @param {PullOptions} options Pull options\n   */\n  _onWorkerPull(options) {\n    this.emit('pull', options);\n  }\n  /**\n   * Triggered for each worker that pushes data\n   *\n   * @param {any} value Serialized data\n   * @param {PushOptions} options Push options\n   */\n  _onWorkerPush(value, options) {\n    const deserializedFrame = DataSerializer.deserialize(value);\n    this.emit('push', deserializedFrame, options);\n  }\n}","export * from './WorkerOptions';\nexport * from './WorkerHandler';","/* eslint-env browser */\n\n/**\n * This is the web browser implementation of `debug()`.\n */\n\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\nexports.storage = localstorage();\nexports.destroy = (() => {\n\tlet warned = false;\n\n\treturn () => {\n\t\tif (!warned) {\n\t\t\twarned = true;\n\t\t\tconsole.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');\n\t\t}\n\t};\n})();\n\n/**\n * Colors.\n */\n\nexports.colors = [\n\t'#0000CC',\n\t'#0000FF',\n\t'#0033CC',\n\t'#0033FF',\n\t'#0066CC',\n\t'#0066FF',\n\t'#0099CC',\n\t'#0099FF',\n\t'#00CC00',\n\t'#00CC33',\n\t'#00CC66',\n\t'#00CC99',\n\t'#00CCCC',\n\t'#00CCFF',\n\t'#3300CC',\n\t'#3300FF',\n\t'#3333CC',\n\t'#3333FF',\n\t'#3366CC',\n\t'#3366FF',\n\t'#3399CC',\n\t'#3399FF',\n\t'#33CC00',\n\t'#33CC33',\n\t'#33CC66',\n\t'#33CC99',\n\t'#33CCCC',\n\t'#33CCFF',\n\t'#6600CC',\n\t'#6600FF',\n\t'#6633CC',\n\t'#6633FF',\n\t'#66CC00',\n\t'#66CC33',\n\t'#9900CC',\n\t'#9900FF',\n\t'#9933CC',\n\t'#9933FF',\n\t'#99CC00',\n\t'#99CC33',\n\t'#CC0000',\n\t'#CC0033',\n\t'#CC0066',\n\t'#CC0099',\n\t'#CC00CC',\n\t'#CC00FF',\n\t'#CC3300',\n\t'#CC3333',\n\t'#CC3366',\n\t'#CC3399',\n\t'#CC33CC',\n\t'#CC33FF',\n\t'#CC6600',\n\t'#CC6633',\n\t'#CC9900',\n\t'#CC9933',\n\t'#CCCC00',\n\t'#CCCC33',\n\t'#FF0000',\n\t'#FF0033',\n\t'#FF0066',\n\t'#FF0099',\n\t'#FF00CC',\n\t'#FF00FF',\n\t'#FF3300',\n\t'#FF3333',\n\t'#FF3366',\n\t'#FF3399',\n\t'#FF33CC',\n\t'#FF33FF',\n\t'#FF6600',\n\t'#FF6633',\n\t'#FF9900',\n\t'#FF9933',\n\t'#FFCC00',\n\t'#FFCC33'\n];\n\n/**\n * Currently only WebKit-based Web Inspectors, Firefox >= v31,\n * and the Firebug extension (any Firefox version) are known\n * to support \"%c\" CSS customizations.\n *\n * TODO: add a `localStorage` variable to explicitly enable/disable colors\n */\n\n// eslint-disable-next-line complexity\nfunction useColors() {\n\t// NB: In an Electron preload script, document will be defined but not fully\n\t// initialized. Since we know we're in Chrome, we'll just detect this case\n\t// explicitly\n\tif (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {\n\t\treturn true;\n\t}\n\n\t// Internet Explorer and Edge do not support colors.\n\tif (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\\/(\\d+)/)) {\n\t\treturn false;\n\t}\n\n\t// Is webkit? http://stackoverflow.com/a/16459606/376773\n\t// document is undefined in react-native: https://github.com/facebook/react-native/pull/1632\n\treturn (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||\n\t\t// Is firebug? http://stackoverflow.com/a/398120/376773\n\t\t(typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||\n\t\t// Is firefox >= v31?\n\t\t// https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages\n\t\t(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||\n\t\t// Double check webkit in userAgent just in case we are in a worker\n\t\t(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\\/(\\d+)/));\n}\n\n/**\n * Colorize log arguments if enabled.\n *\n * @api public\n */\n\nfunction formatArgs(args) {\n\targs[0] = (this.useColors ? '%c' : '') +\n\t\tthis.namespace +\n\t\t(this.useColors ? ' %c' : ' ') +\n\t\targs[0] +\n\t\t(this.useColors ? '%c ' : ' ') +\n\t\t'+' + module.exports.humanize(this.diff);\n\n\tif (!this.useColors) {\n\t\treturn;\n\t}\n\n\tconst c = 'color: ' + this.color;\n\targs.splice(1, 0, c, 'color: inherit');\n\n\t// The final \"%c\" is somewhat tricky, because there could be other\n\t// arguments passed either before or after the %c, so we need to\n\t// figure out the correct index to insert the CSS into\n\tlet index = 0;\n\tlet lastC = 0;\n\targs[0].replace(/%[a-zA-Z%]/g, match => {\n\t\tif (match === '%%') {\n\t\t\treturn;\n\t\t}\n\t\tindex++;\n\t\tif (match === '%c') {\n\t\t\t// We only are interested in the *last* %c\n\t\t\t// (the user may have provided their own)\n\t\t\tlastC = index;\n\t\t}\n\t});\n\n\targs.splice(lastC, 0, c);\n}\n\n/**\n * Invokes `console.debug()` when available.\n * No-op when `console.debug` is not a \"function\".\n * If `console.debug` is not available, falls back\n * to `console.log`.\n *\n * @api public\n */\nexports.log = console.debug || console.log || (() => {});\n\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */\nfunction save(namespaces) {\n\ttry {\n\t\tif (namespaces) {\n\t\t\texports.storage.setItem('debug', namespaces);\n\t\t} else {\n\t\t\texports.storage.removeItem('debug');\n\t\t}\n\t} catch (error) {\n\t\t// Swallow\n\t\t// XXX (@Qix-) should we be logging these?\n\t}\n}\n\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */\nfunction load() {\n\tlet r;\n\ttry {\n\t\tr = exports.storage.getItem('debug');\n\t} catch (error) {\n\t\t// Swallow\n\t\t// XXX (@Qix-) should we be logging these?\n\t}\n\n\t// If debug isn't set in LS, and we're in Electron, try to load $DEBUG\n\tif (!r && typeof process !== 'undefined' && 'env' in process) {\n\t\tr = process.env.DEBUG;\n\t}\n\n\treturn r;\n}\n\n/**\n * Localstorage attempts to return the localstorage.\n *\n * This is necessary because safari throws\n * when a user disables cookies/localstorage\n * and you attempt to access it.\n *\n * @return {LocalStorage}\n * @api private\n */\n\nfunction localstorage() {\n\ttry {\n\t\t// TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context\n\t\t// The Browser also has localStorage in the global context.\n\t\treturn localStorage;\n\t} catch (error) {\n\t\t// Swallow\n\t\t// XXX (@Qix-) should we be logging these?\n\t}\n}\n\nmodule.exports = require('./common')(exports);\n\nconst {formatters} = module.exports;\n\n/**\n * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.\n */\n\nformatters.j = function (v) {\n\ttry {\n\t\treturn JSON.stringify(v);\n\t} catch (error) {\n\t\treturn '[UnexpectedJSONParseError]: ' + error.message;\n\t}\n};\n","\n/**\n * This is the common logic for both the Node.js and web browser\n * implementations of `debug()`.\n */\n\nfunction setup(env) {\n\tcreateDebug.debug = createDebug;\n\tcreateDebug.default = createDebug;\n\tcreateDebug.coerce = coerce;\n\tcreateDebug.disable = disable;\n\tcreateDebug.enable = enable;\n\tcreateDebug.enabled = enabled;\n\tcreateDebug.humanize = require('ms');\n\tcreateDebug.destroy = destroy;\n\n\tObject.keys(env).forEach(key => {\n\t\tcreateDebug[key] = env[key];\n\t});\n\n\t/**\n\t* The currently active debug mode names, and names to skip.\n\t*/\n\n\tcreateDebug.names = [];\n\tcreateDebug.skips = [];\n\n\t/**\n\t* Map of special \"%n\" handling functions, for the debug \"format\" argument.\n\t*\n\t* Valid key names are a single, lower or upper-case letter, i.e. \"n\" and \"N\".\n\t*/\n\tcreateDebug.formatters = {};\n\n\t/**\n\t* Selects a color for a debug namespace\n\t* @param {String} namespace The namespace string for the debug instance to be colored\n\t* @return {Number|String} An ANSI color code for the given namespace\n\t* @api private\n\t*/\n\tfunction selectColor(namespace) {\n\t\tlet hash = 0;\n\n\t\tfor (let i = 0; i < namespace.length; i++) {\n\t\t\thash = ((hash << 5) - hash) + namespace.charCodeAt(i);\n\t\t\thash |= 0; // Convert to 32bit integer\n\t\t}\n\n\t\treturn createDebug.colors[Math.abs(hash) % createDebug.colors.length];\n\t}\n\tcreateDebug.selectColor = selectColor;\n\n\t/**\n\t* Create a debugger with the given `namespace`.\n\t*\n\t* @param {String} namespace\n\t* @return {Function}\n\t* @api public\n\t*/\n\tfunction createDebug(namespace) {\n\t\tlet prevTime;\n\t\tlet enableOverride = null;\n\t\tlet namespacesCache;\n\t\tlet enabledCache;\n\n\t\tfunction debug(...args) {\n\t\t\t// Disabled?\n\t\t\tif (!debug.enabled) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst self = debug;\n\n\t\t\t// Set `diff` timestamp\n\t\t\tconst curr = Number(new Date());\n\t\t\tconst ms = curr - (prevTime || curr);\n\t\t\tself.diff = ms;\n\t\t\tself.prev = prevTime;\n\t\t\tself.curr = curr;\n\t\t\tprevTime = curr;\n\n\t\t\targs[0] = createDebug.coerce(args[0]);\n\n\t\t\tif (typeof args[0] !== 'string') {\n\t\t\t\t// Anything else let's inspect with %O\n\t\t\t\targs.unshift('%O');\n\t\t\t}\n\n\t\t\t// Apply any `formatters` transformations\n\t\t\tlet index = 0;\n\t\t\targs[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {\n\t\t\t\t// If we encounter an escaped % then don't increase the array index\n\t\t\t\tif (match === '%%') {\n\t\t\t\t\treturn '%';\n\t\t\t\t}\n\t\t\t\tindex++;\n\t\t\t\tconst formatter = createDebug.formatters[format];\n\t\t\t\tif (typeof formatter === 'function') {\n\t\t\t\t\tconst val = args[index];\n\t\t\t\t\tmatch = formatter.call(self, val);\n\n\t\t\t\t\t// Now we need to remove `args[index]` since it's inlined in the `format`\n\t\t\t\t\targs.splice(index, 1);\n\t\t\t\t\tindex--;\n\t\t\t\t}\n\t\t\t\treturn match;\n\t\t\t});\n\n\t\t\t// Apply env-specific formatting (colors, etc.)\n\t\t\tcreateDebug.formatArgs.call(self, args);\n\n\t\t\tconst logFn = self.log || createDebug.log;\n\t\t\tlogFn.apply(self, args);\n\t\t}\n\n\t\tdebug.namespace = namespace;\n\t\tdebug.useColors = createDebug.useColors();\n\t\tdebug.color = createDebug.selectColor(namespace);\n\t\tdebug.extend = extend;\n\t\tdebug.destroy = createDebug.destroy; // XXX Temporary. Will be removed in the next major release.\n\n\t\tObject.defineProperty(debug, 'enabled', {\n\t\t\tenumerable: true,\n\t\t\tconfigurable: false,\n\t\t\tget: () => {\n\t\t\t\tif (enableOverride !== null) {\n\t\t\t\t\treturn enableOverride;\n\t\t\t\t}\n\t\t\t\tif (namespacesCache !== createDebug.namespaces) {\n\t\t\t\t\tnamespacesCache = createDebug.namespaces;\n\t\t\t\t\tenabledCache = createDebug.enabled(namespace);\n\t\t\t\t}\n\n\t\t\t\treturn enabledCache;\n\t\t\t},\n\t\t\tset: v => {\n\t\t\t\tenableOverride = v;\n\t\t\t}\n\t\t});\n\n\t\t// Env-specific initialization logic for debug instances\n\t\tif (typeof createDebug.init === 'function') {\n\t\t\tcreateDebug.init(debug);\n\t\t}\n\n\t\treturn debug;\n\t}\n\n\tfunction extend(namespace, delimiter) {\n\t\tconst newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);\n\t\tnewDebug.log = this.log;\n\t\treturn newDebug;\n\t}\n\n\t/**\n\t* Enables a debug mode by namespaces. This can include modes\n\t* separated by a colon and wildcards.\n\t*\n\t* @param {String} namespaces\n\t* @api public\n\t*/\n\tfunction enable(namespaces) {\n\t\tcreateDebug.save(namespaces);\n\t\tcreateDebug.namespaces = namespaces;\n\n\t\tcreateDebug.names = [];\n\t\tcreateDebug.skips = [];\n\n\t\tlet i;\n\t\tconst split = (typeof namespaces === 'string' ? namespaces : '').split(/[\\s,]+/);\n\t\tconst len = split.length;\n\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tif (!split[i]) {\n\t\t\t\t// ignore empty strings\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tnamespaces = split[i].replace(/\\*/g, '.*?');\n\n\t\t\tif (namespaces[0] === '-') {\n\t\t\t\tcreateDebug.skips.push(new RegExp('^' + namespaces.slice(1) + '$'));\n\t\t\t} else {\n\t\t\t\tcreateDebug.names.push(new RegExp('^' + namespaces + '$'));\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t* Disable debug output.\n\t*\n\t* @return {String} namespaces\n\t* @api public\n\t*/\n\tfunction disable() {\n\t\tconst namespaces = [\n\t\t\t...createDebug.names.map(toNamespace),\n\t\t\t...createDebug.skips.map(toNamespace).map(namespace => '-' + namespace)\n\t\t].join(',');\n\t\tcreateDebug.enable('');\n\t\treturn namespaces;\n\t}\n\n\t/**\n\t* Returns true if the given mode name is enabled, false otherwise.\n\t*\n\t* @param {String} name\n\t* @return {Boolean}\n\t* @api public\n\t*/\n\tfunction enabled(name) {\n\t\tif (name[name.length - 1] === '*') {\n\t\t\treturn true;\n\t\t}\n\n\t\tlet i;\n\t\tlet len;\n\n\t\tfor (i = 0, len = createDebug.skips.length; i < len; i++) {\n\t\t\tif (createDebug.skips[i].test(name)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\tfor (i = 0, len = createDebug.names.length; i < len; i++) {\n\t\t\tif (createDebug.names[i].test(name)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t* Convert regexp to namespace\n\t*\n\t* @param {RegExp} regxep\n\t* @return {String} namespace\n\t* @api private\n\t*/\n\tfunction toNamespace(regexp) {\n\t\treturn regexp.toString()\n\t\t\t.substring(2, regexp.toString().length - 2)\n\t\t\t.replace(/\\.\\*\\?$/, '*');\n\t}\n\n\t/**\n\t* Coerce `val`.\n\t*\n\t* @param {Mixed} val\n\t* @return {Mixed}\n\t* @api private\n\t*/\n\tfunction coerce(val) {\n\t\tif (val instanceof Error) {\n\t\t\treturn val.stack || val.message;\n\t\t}\n\t\treturn val;\n\t}\n\n\t/**\n\t* XXX DO NOT USE. This is a temporary stub function.\n\t* XXX It WILL be removed in the next major release.\n\t*/\n\tfunction destroy() {\n\t\tconsole.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');\n\t}\n\n\tcreateDebug.enable(createDebug.load());\n\n\treturn createDebug;\n}\n\nmodule.exports = setup;\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nvar R = typeof Reflect === 'object' ? Reflect : null\nvar ReflectApply = R && typeof R.apply === 'function'\n  ? R.apply\n  : function ReflectApply(target, receiver, args) {\n    return Function.prototype.apply.call(target, receiver, args);\n  }\n\nvar ReflectOwnKeys\nif (R && typeof R.ownKeys === 'function') {\n  ReflectOwnKeys = R.ownKeys\n} else if (Object.getOwnPropertySymbols) {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target)\n      .concat(Object.getOwnPropertySymbols(target));\n  };\n} else {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target);\n  };\n}\n\nfunction ProcessEmitWarning(warning) {\n  if (console && console.warn) console.warn(warning);\n}\n\nvar NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {\n  return value !== value;\n}\n\nfunction EventEmitter() {\n  EventEmitter.init.call(this);\n}\nmodule.exports = EventEmitter;\nmodule.exports.once = once;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._eventsCount = 0;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nvar defaultMaxListeners = 10;\n\nfunction checkListener(listener) {\n  if (typeof listener !== 'function') {\n    throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n  }\n}\n\nObject.defineProperty(EventEmitter, 'defaultMaxListeners', {\n  enumerable: true,\n  get: function() {\n    return defaultMaxListeners;\n  },\n  set: function(arg) {\n    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {\n      throw new RangeError('The value of \"defaultMaxListeners\" is out of range. It must be a non-negative number. Received ' + arg + '.');\n    }\n    defaultMaxListeners = arg;\n  }\n});\n\nEventEmitter.init = function() {\n\n  if (this._events === undefined ||\n      this._events === Object.getPrototypeOf(this)._events) {\n    this._events = Object.create(null);\n    this._eventsCount = 0;\n  }\n\n  this._maxListeners = this._maxListeners || undefined;\n};\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {\n  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {\n    throw new RangeError('The value of \"n\" is out of range. It must be a non-negative number. Received ' + n + '.');\n  }\n  this._maxListeners = n;\n  return this;\n};\n\nfunction _getMaxListeners(that) {\n  if (that._maxListeners === undefined)\n    return EventEmitter.defaultMaxListeners;\n  return that._maxListeners;\n}\n\nEventEmitter.prototype.getMaxListeners = function getMaxListeners() {\n  return _getMaxListeners(this);\n};\n\nEventEmitter.prototype.emit = function emit(type) {\n  var args = [];\n  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);\n  var doError = (type === 'error');\n\n  var events = this._events;\n  if (events !== undefined)\n    doError = (doError && events.error === undefined);\n  else if (!doError)\n    return false;\n\n  // If there is no 'error' event listener then throw.\n  if (doError) {\n    var er;\n    if (args.length > 0)\n      er = args[0];\n    if (er instanceof Error) {\n      // Note: The comments on the `throw` lines are intentional, they show\n      // up in Node's output if this results in an unhandled exception.\n      throw er; // Unhandled 'error' event\n    }\n    // At least give some kind of context to the user\n    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));\n    err.context = er;\n    throw err; // Unhandled 'error' event\n  }\n\n  var handler = events[type];\n\n  if (handler === undefined)\n    return false;\n\n  if (typeof handler === 'function') {\n    ReflectApply(handler, this, args);\n  } else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      ReflectApply(listeners[i], this, args);\n  }\n\n  return true;\n};\n\nfunction _addListener(target, type, listener, prepend) {\n  var m;\n  var events;\n  var existing;\n\n  checkListener(listener);\n\n  events = target._events;\n  if (events === undefined) {\n    events = target._events = Object.create(null);\n    target._eventsCount = 0;\n  } else {\n    // To avoid recursion in the case that type === \"newListener\"! Before\n    // adding it to the listeners, first emit \"newListener\".\n    if (events.newListener !== undefined) {\n      target.emit('newListener', type,\n                  listener.listener ? listener.listener : listener);\n\n      // Re-assign `events` because a newListener handler could have caused the\n      // this._events to be assigned to a new object\n      events = target._events;\n    }\n    existing = events[type];\n  }\n\n  if (existing === undefined) {\n    // Optimize the case of one listener. Don't need the extra array object.\n    existing = events[type] = listener;\n    ++target._eventsCount;\n  } else {\n    if (typeof existing === 'function') {\n      // Adding the second element, need to change to array.\n      existing = events[type] =\n        prepend ? [listener, existing] : [existing, listener];\n      // If we've already got an array, just append.\n    } else if (prepend) {\n      existing.unshift(listener);\n    } else {\n      existing.push(listener);\n    }\n\n    // Check for listener leak\n    m = _getMaxListeners(target);\n    if (m > 0 && existing.length > m && !existing.warned) {\n      existing.warned = true;\n      // No error code for this since it is a Warning\n      // eslint-disable-next-line no-restricted-syntax\n      var w = new Error('Possible EventEmitter memory leak detected. ' +\n                          existing.length + ' ' + String(type) + ' listeners ' +\n                          'added. Use emitter.setMaxListeners() to ' +\n                          'increase limit');\n      w.name = 'MaxListenersExceededWarning';\n      w.emitter = target;\n      w.type = type;\n      w.count = existing.length;\n      ProcessEmitWarning(w);\n    }\n  }\n\n  return target;\n}\n\nEventEmitter.prototype.addListener = function addListener(type, listener) {\n  return _addListener(this, type, listener, false);\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.prependListener =\n    function prependListener(type, listener) {\n      return _addListener(this, type, listener, true);\n    };\n\nfunction onceWrapper() {\n  if (!this.fired) {\n    this.target.removeListener(this.type, this.wrapFn);\n    this.fired = true;\n    if (arguments.length === 0)\n      return this.listener.call(this.target);\n    return this.listener.apply(this.target, arguments);\n  }\n}\n\nfunction _onceWrap(target, type, listener) {\n  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };\n  var wrapped = onceWrapper.bind(state);\n  wrapped.listener = listener;\n  state.wrapFn = wrapped;\n  return wrapped;\n}\n\nEventEmitter.prototype.once = function once(type, listener) {\n  checkListener(listener);\n  this.on(type, _onceWrap(this, type, listener));\n  return this;\n};\n\nEventEmitter.prototype.prependOnceListener =\n    function prependOnceListener(type, listener) {\n      checkListener(listener);\n      this.prependListener(type, _onceWrap(this, type, listener));\n      return this;\n    };\n\n// Emits a 'removeListener' event if and only if the listener was removed.\nEventEmitter.prototype.removeListener =\n    function removeListener(type, listener) {\n      var list, events, position, i, originalListener;\n\n      checkListener(listener);\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      list = events[type];\n      if (list === undefined)\n        return this;\n\n      if (list === listener || list.listener === listener) {\n        if (--this._eventsCount === 0)\n          this._events = Object.create(null);\n        else {\n          delete events[type];\n          if (events.removeListener)\n            this.emit('removeListener', type, list.listener || listener);\n        }\n      } else if (typeof list !== 'function') {\n        position = -1;\n\n        for (i = list.length - 1; i >= 0; i--) {\n          if (list[i] === listener || list[i].listener === listener) {\n            originalListener = list[i].listener;\n            position = i;\n            break;\n          }\n        }\n\n        if (position < 0)\n          return this;\n\n        if (position === 0)\n          list.shift();\n        else {\n          spliceOne(list, position);\n        }\n\n        if (list.length === 1)\n          events[type] = list[0];\n\n        if (events.removeListener !== undefined)\n          this.emit('removeListener', type, originalListener || listener);\n      }\n\n      return this;\n    };\n\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\n\nEventEmitter.prototype.removeAllListeners =\n    function removeAllListeners(type) {\n      var listeners, events, i;\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      // not listening for removeListener, no need to emit\n      if (events.removeListener === undefined) {\n        if (arguments.length === 0) {\n          this._events = Object.create(null);\n          this._eventsCount = 0;\n        } else if (events[type] !== undefined) {\n          if (--this._eventsCount === 0)\n            this._events = Object.create(null);\n          else\n            delete events[type];\n        }\n        return this;\n      }\n\n      // emit removeListener for all listeners on all events\n      if (arguments.length === 0) {\n        var keys = Object.keys(events);\n        var key;\n        for (i = 0; i < keys.length; ++i) {\n          key = keys[i];\n          if (key === 'removeListener') continue;\n          this.removeAllListeners(key);\n        }\n        this.removeAllListeners('removeListener');\n        this._events = Object.create(null);\n        this._eventsCount = 0;\n        return this;\n      }\n\n      listeners = events[type];\n\n      if (typeof listeners === 'function') {\n        this.removeListener(type, listeners);\n      } else if (listeners !== undefined) {\n        // LIFO order\n        for (i = listeners.length - 1; i >= 0; i--) {\n          this.removeListener(type, listeners[i]);\n        }\n      }\n\n      return this;\n    };\n\nfunction _listeners(target, type, unwrap) {\n  var events = target._events;\n\n  if (events === undefined)\n    return [];\n\n  var evlistener = events[type];\n  if (evlistener === undefined)\n    return [];\n\n  if (typeof evlistener === 'function')\n    return unwrap ? [evlistener.listener || evlistener] : [evlistener];\n\n  return unwrap ?\n    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);\n}\n\nEventEmitter.prototype.listeners = function listeners(type) {\n  return _listeners(this, type, true);\n};\n\nEventEmitter.prototype.rawListeners = function rawListeners(type) {\n  return _listeners(this, type, false);\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  if (typeof emitter.listenerCount === 'function') {\n    return emitter.listenerCount(type);\n  } else {\n    return listenerCount.call(emitter, type);\n  }\n};\n\nEventEmitter.prototype.listenerCount = listenerCount;\nfunction listenerCount(type) {\n  var events = this._events;\n\n  if (events !== undefined) {\n    var evlistener = events[type];\n\n    if (typeof evlistener === 'function') {\n      return 1;\n    } else if (evlistener !== undefined) {\n      return evlistener.length;\n    }\n  }\n\n  return 0;\n}\n\nEventEmitter.prototype.eventNames = function eventNames() {\n  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];\n};\n\nfunction arrayClone(arr, n) {\n  var copy = new Array(n);\n  for (var i = 0; i < n; ++i)\n    copy[i] = arr[i];\n  return copy;\n}\n\nfunction spliceOne(list, index) {\n  for (; index + 1 < list.length; index++)\n    list[index] = list[index + 1];\n  list.pop();\n}\n\nfunction unwrapListeners(arr) {\n  var ret = new Array(arr.length);\n  for (var i = 0; i < ret.length; ++i) {\n    ret[i] = arr[i].listener || arr[i];\n  }\n  return ret;\n}\n\nfunction once(emitter, name) {\n  return new Promise(function (resolve, reject) {\n    function errorListener(err) {\n      emitter.removeListener(name, resolver);\n      reject(err);\n    }\n\n    function resolver() {\n      if (typeof emitter.removeListener === 'function') {\n        emitter.removeListener('error', errorListener);\n      }\n      resolve([].slice.call(arguments));\n    };\n\n    eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });\n    if (name !== 'error') {\n      addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });\n    }\n  });\n}\n\nfunction addErrorHandlerIfEventEmitter(emitter, handler, flags) {\n  if (typeof emitter.on === 'function') {\n    eventTargetAgnosticAddListener(emitter, 'error', handler, flags);\n  }\n}\n\nfunction eventTargetAgnosticAddListener(emitter, name, listener, flags) {\n  if (typeof emitter.on === 'function') {\n    if (flags.once) {\n      emitter.once(name, listener);\n    } else {\n      emitter.on(name, listener);\n    }\n  } else if (typeof emitter.addEventListener === 'function') {\n    // EventTarget does not have `error` event semantics like Node\n    // EventEmitters, we do not listen for `error` events here.\n    emitter.addEventListener(name, function wrapListener(arg) {\n      // IE does not have builtin `{ once: true }` support so we\n      // have to do it manually.\n      if (flags.once) {\n        emitter.removeEventListener(name, wrapListener);\n      }\n      listener(arg);\n    });\n  } else {\n    throw new TypeError('The \"emitter\" argument must be of type EventEmitter. Received type ' + typeof emitter);\n  }\n}\n","'use strict';\n\nmodule.exports = value => {\n\tif (!value) {\n\t\treturn false;\n\t}\n\n\t// eslint-disable-next-line no-use-extend-native/no-use-extend-native\n\tif (typeof Symbol.observable === 'symbol' && typeof value[Symbol.observable] === 'function') {\n\t\t// eslint-disable-next-line no-use-extend-native/no-use-extend-native\n\t\treturn value === value[Symbol.observable]();\n\t}\n\n\tif (typeof value['@@observable'] === 'function') {\n\t\treturn value === value['@@observable']();\n\t}\n\n\treturn false;\n};\n","/**\n * lodash (Custom Build) <https://lodash.com/>\n * Build: `lodash modularize exports=\"npm\" -o ./`\n * Copyright jQuery Foundation and other contributors <https://jquery.org/>\n * Released under MIT license <https://lodash.com/license>\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n */\n\n/** Used as the size to enable large array optimizations. */\nvar LARGE_ARRAY_SIZE = 200;\n\n/** Used to stand-in for `undefined` hash values. */\nvar HASH_UNDEFINED = '__lodash_hash_undefined__';\n\n/** Used as references for various `Number` constants. */\nvar MAX_SAFE_INTEGER = 9007199254740991;\n\n/** `Object#toString` result references. */\nvar argsTag = '[object Arguments]',\n    arrayTag = '[object Array]',\n    boolTag = '[object Boolean]',\n    dateTag = '[object Date]',\n    errorTag = '[object Error]',\n    funcTag = '[object Function]',\n    genTag = '[object GeneratorFunction]',\n    mapTag = '[object Map]',\n    numberTag = '[object Number]',\n    objectTag = '[object Object]',\n    promiseTag = '[object Promise]',\n    regexpTag = '[object RegExp]',\n    setTag = '[object Set]',\n    stringTag = '[object String]',\n    symbolTag = '[object Symbol]',\n    weakMapTag = '[object WeakMap]';\n\nvar arrayBufferTag = '[object ArrayBuffer]',\n    dataViewTag = '[object DataView]',\n    float32Tag = '[object Float32Array]',\n    float64Tag = '[object Float64Array]',\n    int8Tag = '[object Int8Array]',\n    int16Tag = '[object Int16Array]',\n    int32Tag = '[object Int32Array]',\n    uint8Tag = '[object Uint8Array]',\n    uint8ClampedTag = '[object Uint8ClampedArray]',\n    uint16Tag = '[object Uint16Array]',\n    uint32Tag = '[object Uint32Array]';\n\n/**\n * Used to match `RegExp`\n * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).\n */\nvar reRegExpChar = /[\\\\^$.*+?()[\\]{}|]/g;\n\n/** Used to match `RegExp` flags from their coerced string values. */\nvar reFlags = /\\w*$/;\n\n/** Used to detect host constructors (Safari). */\nvar reIsHostCtor = /^\\[object .+?Constructor\\]$/;\n\n/** Used to detect unsigned integer values. */\nvar reIsUint = /^(?:0|[1-9]\\d*)$/;\n\n/** Used to identify `toStringTag` values supported by `_.clone`. */\nvar cloneableTags = {};\ncloneableTags[argsTag] = cloneableTags[arrayTag] =\ncloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] =\ncloneableTags[boolTag] = cloneableTags[dateTag] =\ncloneableTags[float32Tag] = cloneableTags[float64Tag] =\ncloneableTags[int8Tag] = cloneableTags[int16Tag] =\ncloneableTags[int32Tag] = cloneableTags[mapTag] =\ncloneableTags[numberTag] = cloneableTags[objectTag] =\ncloneableTags[regexpTag] = cloneableTags[setTag] =\ncloneableTags[stringTag] = cloneableTags[symbolTag] =\ncloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =\ncloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;\ncloneableTags[errorTag] = cloneableTags[funcTag] =\ncloneableTags[weakMapTag] = false;\n\n/** Detect free variable `global` from Node.js. */\nvar freeGlobal = typeof global == 'object' && global && global.Object === Object && global;\n\n/** Detect free variable `self`. */\nvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n/** Used as a reference to the global object. */\nvar root = freeGlobal || freeSelf || Function('return this')();\n\n/** Detect free variable `exports`. */\nvar freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;\n\n/** Detect free variable `module`. */\nvar freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;\n\n/** Detect the popular CommonJS extension `module.exports`. */\nvar moduleExports = freeModule && freeModule.exports === freeExports;\n\n/**\n * Adds the key-value `pair` to `map`.\n *\n * @private\n * @param {Object} map The map to modify.\n * @param {Array} pair The key-value pair to add.\n * @returns {Object} Returns `map`.\n */\nfunction addMapEntry(map, pair) {\n  // Don't return `map.set` because it's not chainable in IE 11.\n  map.set(pair[0], pair[1]);\n  return map;\n}\n\n/**\n * Adds `value` to `set`.\n *\n * @private\n * @param {Object} set The set to modify.\n * @param {*} value The value to add.\n * @returns {Object} Returns `set`.\n */\nfunction addSetEntry(set, value) {\n  // Don't return `set.add` because it's not chainable in IE 11.\n  set.add(value);\n  return set;\n}\n\n/**\n * A specialized version of `_.forEach` for arrays without support for\n * iteratee shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns `array`.\n */\nfunction arrayEach(array, iteratee) {\n  var index = -1,\n      length = array ? array.length : 0;\n\n  while (++index < length) {\n    if (iteratee(array[index], index, array) === false) {\n      break;\n    }\n  }\n  return array;\n}\n\n/**\n * Appends the elements of `values` to `array`.\n *\n * @private\n * @param {Array} array The array to modify.\n * @param {Array} values The values to append.\n * @returns {Array} Returns `array`.\n */\nfunction arrayPush(array, values) {\n  var index = -1,\n      length = values.length,\n      offset = array.length;\n\n  while (++index < length) {\n    array[offset + index] = values[index];\n  }\n  return array;\n}\n\n/**\n * A specialized version of `_.reduce` for arrays without support for\n * iteratee shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @param {*} [accumulator] The initial value.\n * @param {boolean} [initAccum] Specify using the first element of `array` as\n *  the initial value.\n * @returns {*} Returns the accumulated value.\n */\nfunction arrayReduce(array, iteratee, accumulator, initAccum) {\n  var index = -1,\n      length = array ? array.length : 0;\n\n  if (initAccum && length) {\n    accumulator = array[++index];\n  }\n  while (++index < length) {\n    accumulator = iteratee(accumulator, array[index], index, array);\n  }\n  return accumulator;\n}\n\n/**\n * The base implementation of `_.times` without support for iteratee shorthands\n * or max array length checks.\n *\n * @private\n * @param {number} n The number of times to invoke `iteratee`.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns the array of results.\n */\nfunction baseTimes(n, iteratee) {\n  var index = -1,\n      result = Array(n);\n\n  while (++index < n) {\n    result[index] = iteratee(index);\n  }\n  return result;\n}\n\n/**\n * Gets the value at `key` of `object`.\n *\n * @private\n * @param {Object} [object] The object to query.\n * @param {string} key The key of the property to get.\n * @returns {*} Returns the property value.\n */\nfunction getValue(object, key) {\n  return object == null ? undefined : object[key];\n}\n\n/**\n * Checks if `value` is a host object in IE < 9.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a host object, else `false`.\n */\nfunction isHostObject(value) {\n  // Many host objects are `Object` objects that can coerce to strings\n  // despite having improperly defined `toString` methods.\n  var result = false;\n  if (value != null && typeof value.toString != 'function') {\n    try {\n      result = !!(value + '');\n    } catch (e) {}\n  }\n  return result;\n}\n\n/**\n * Converts `map` to its key-value pairs.\n *\n * @private\n * @param {Object} map The map to convert.\n * @returns {Array} Returns the key-value pairs.\n */\nfunction mapToArray(map) {\n  var index = -1,\n      result = Array(map.size);\n\n  map.forEach(function(value, key) {\n    result[++index] = [key, value];\n  });\n  return result;\n}\n\n/**\n * Creates a unary function that invokes `func` with its argument transformed.\n *\n * @private\n * @param {Function} func The function to wrap.\n * @param {Function} transform The argument transform.\n * @returns {Function} Returns the new function.\n */\nfunction overArg(func, transform) {\n  return function(arg) {\n    return func(transform(arg));\n  };\n}\n\n/**\n * Converts `set` to an array of its values.\n *\n * @private\n * @param {Object} set The set to convert.\n * @returns {Array} Returns the values.\n */\nfunction setToArray(set) {\n  var index = -1,\n      result = Array(set.size);\n\n  set.forEach(function(value) {\n    result[++index] = value;\n  });\n  return result;\n}\n\n/** Used for built-in method references. */\nvar arrayProto = Array.prototype,\n    funcProto = Function.prototype,\n    objectProto = Object.prototype;\n\n/** Used to detect overreaching core-js shims. */\nvar coreJsData = root['__core-js_shared__'];\n\n/** Used to detect methods masquerading as native. */\nvar maskSrcKey = (function() {\n  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');\n  return uid ? ('Symbol(src)_1.' + uid) : '';\n}());\n\n/** Used to resolve the decompiled source of functions. */\nvar funcToString = funcProto.toString;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar objectToString = objectProto.toString;\n\n/** Used to detect if a method is native. */\nvar reIsNative = RegExp('^' +\n  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\\\$&')\n  .replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$'\n);\n\n/** Built-in value references. */\nvar Buffer = moduleExports ? root.Buffer : undefined,\n    Symbol = root.Symbol,\n    Uint8Array = root.Uint8Array,\n    getPrototype = overArg(Object.getPrototypeOf, Object),\n    objectCreate = Object.create,\n    propertyIsEnumerable = objectProto.propertyIsEnumerable,\n    splice = arrayProto.splice;\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeGetSymbols = Object.getOwnPropertySymbols,\n    nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined,\n    nativeKeys = overArg(Object.keys, Object);\n\n/* Built-in method references that are verified to be native. */\nvar DataView = getNative(root, 'DataView'),\n    Map = getNative(root, 'Map'),\n    Promise = getNative(root, 'Promise'),\n    Set = getNative(root, 'Set'),\n    WeakMap = getNative(root, 'WeakMap'),\n    nativeCreate = getNative(Object, 'create');\n\n/** Used to detect maps, sets, and weakmaps. */\nvar dataViewCtorString = toSource(DataView),\n    mapCtorString = toSource(Map),\n    promiseCtorString = toSource(Promise),\n    setCtorString = toSource(Set),\n    weakMapCtorString = toSource(WeakMap);\n\n/** Used to convert symbols to primitives and strings. */\nvar symbolProto = Symbol ? Symbol.prototype : undefined,\n    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;\n\n/**\n * Creates a hash object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction Hash(entries) {\n  var index = -1,\n      length = entries ? entries.length : 0;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the hash.\n *\n * @private\n * @name clear\n * @memberOf Hash\n */\nfunction hashClear() {\n  this.__data__ = nativeCreate ? nativeCreate(null) : {};\n}\n\n/**\n * Removes `key` and its value from the hash.\n *\n * @private\n * @name delete\n * @memberOf Hash\n * @param {Object} hash The hash to modify.\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction hashDelete(key) {\n  return this.has(key) && delete this.__data__[key];\n}\n\n/**\n * Gets the hash value for `key`.\n *\n * @private\n * @name get\n * @memberOf Hash\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction hashGet(key) {\n  var data = this.__data__;\n  if (nativeCreate) {\n    var result = data[key];\n    return result === HASH_UNDEFINED ? undefined : result;\n  }\n  return hasOwnProperty.call(data, key) ? data[key] : undefined;\n}\n\n/**\n * Checks if a hash value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf Hash\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction hashHas(key) {\n  var data = this.__data__;\n  return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);\n}\n\n/**\n * Sets the hash `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf Hash\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the hash instance.\n */\nfunction hashSet(key, value) {\n  var data = this.__data__;\n  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;\n  return this;\n}\n\n// Add methods to `Hash`.\nHash.prototype.clear = hashClear;\nHash.prototype['delete'] = hashDelete;\nHash.prototype.get = hashGet;\nHash.prototype.has = hashHas;\nHash.prototype.set = hashSet;\n\n/**\n * Creates an list cache object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction ListCache(entries) {\n  var index = -1,\n      length = entries ? entries.length : 0;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the list cache.\n *\n * @private\n * @name clear\n * @memberOf ListCache\n */\nfunction listCacheClear() {\n  this.__data__ = [];\n}\n\n/**\n * Removes `key` and its value from the list cache.\n *\n * @private\n * @name delete\n * @memberOf ListCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction listCacheDelete(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    return false;\n  }\n  var lastIndex = data.length - 1;\n  if (index == lastIndex) {\n    data.pop();\n  } else {\n    splice.call(data, index, 1);\n  }\n  return true;\n}\n\n/**\n * Gets the list cache value for `key`.\n *\n * @private\n * @name get\n * @memberOf ListCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction listCacheGet(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  return index < 0 ? undefined : data[index][1];\n}\n\n/**\n * Checks if a list cache value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf ListCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction listCacheHas(key) {\n  return assocIndexOf(this.__data__, key) > -1;\n}\n\n/**\n * Sets the list cache `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf ListCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the list cache instance.\n */\nfunction listCacheSet(key, value) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    data.push([key, value]);\n  } else {\n    data[index][1] = value;\n  }\n  return this;\n}\n\n// Add methods to `ListCache`.\nListCache.prototype.clear = listCacheClear;\nListCache.prototype['delete'] = listCacheDelete;\nListCache.prototype.get = listCacheGet;\nListCache.prototype.has = listCacheHas;\nListCache.prototype.set = listCacheSet;\n\n/**\n * Creates a map cache object to store key-value pairs.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction MapCache(entries) {\n  var index = -1,\n      length = entries ? entries.length : 0;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the map.\n *\n * @private\n * @name clear\n * @memberOf MapCache\n */\nfunction mapCacheClear() {\n  this.__data__ = {\n    'hash': new Hash,\n    'map': new (Map || ListCache),\n    'string': new Hash\n  };\n}\n\n/**\n * Removes `key` and its value from the map.\n *\n * @private\n * @name delete\n * @memberOf MapCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction mapCacheDelete(key) {\n  return getMapData(this, key)['delete'](key);\n}\n\n/**\n * Gets the map value for `key`.\n *\n * @private\n * @name get\n * @memberOf MapCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction mapCacheGet(key) {\n  return getMapData(this, key).get(key);\n}\n\n/**\n * Checks if a map value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf MapCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction mapCacheHas(key) {\n  return getMapData(this, key).has(key);\n}\n\n/**\n * Sets the map `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf MapCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the map cache instance.\n */\nfunction mapCacheSet(key, value) {\n  getMapData(this, key).set(key, value);\n  return this;\n}\n\n// Add methods to `MapCache`.\nMapCache.prototype.clear = mapCacheClear;\nMapCache.prototype['delete'] = mapCacheDelete;\nMapCache.prototype.get = mapCacheGet;\nMapCache.prototype.has = mapCacheHas;\nMapCache.prototype.set = mapCacheSet;\n\n/**\n * Creates a stack cache object to store key-value pairs.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction Stack(entries) {\n  this.__data__ = new ListCache(entries);\n}\n\n/**\n * Removes all key-value entries from the stack.\n *\n * @private\n * @name clear\n * @memberOf Stack\n */\nfunction stackClear() {\n  this.__data__ = new ListCache;\n}\n\n/**\n * Removes `key` and its value from the stack.\n *\n * @private\n * @name delete\n * @memberOf Stack\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction stackDelete(key) {\n  return this.__data__['delete'](key);\n}\n\n/**\n * Gets the stack value for `key`.\n *\n * @private\n * @name get\n * @memberOf Stack\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction stackGet(key) {\n  return this.__data__.get(key);\n}\n\n/**\n * Checks if a stack value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf Stack\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction stackHas(key) {\n  return this.__data__.has(key);\n}\n\n/**\n * Sets the stack `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf Stack\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the stack cache instance.\n */\nfunction stackSet(key, value) {\n  var cache = this.__data__;\n  if (cache instanceof ListCache) {\n    var pairs = cache.__data__;\n    if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {\n      pairs.push([key, value]);\n      return this;\n    }\n    cache = this.__data__ = new MapCache(pairs);\n  }\n  cache.set(key, value);\n  return this;\n}\n\n// Add methods to `Stack`.\nStack.prototype.clear = stackClear;\nStack.prototype['delete'] = stackDelete;\nStack.prototype.get = stackGet;\nStack.prototype.has = stackHas;\nStack.prototype.set = stackSet;\n\n/**\n * Creates an array of the enumerable property names of the array-like `value`.\n *\n * @private\n * @param {*} value The value to query.\n * @param {boolean} inherited Specify returning inherited property names.\n * @returns {Array} Returns the array of property names.\n */\nfunction arrayLikeKeys(value, inherited) {\n  // Safari 8.1 makes `arguments.callee` enumerable in strict mode.\n  // Safari 9 makes `arguments.length` enumerable in strict mode.\n  var result = (isArray(value) || isArguments(value))\n    ? baseTimes(value.length, String)\n    : [];\n\n  var length = result.length,\n      skipIndexes = !!length;\n\n  for (var key in value) {\n    if ((inherited || hasOwnProperty.call(value, key)) &&\n        !(skipIndexes && (key == 'length' || isIndex(key, length)))) {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\n/**\n * Assigns `value` to `key` of `object` if the existing value is not equivalent\n * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * for equality comparisons.\n *\n * @private\n * @param {Object} object The object to modify.\n * @param {string} key The key of the property to assign.\n * @param {*} value The value to assign.\n */\nfunction assignValue(object, key, value) {\n  var objValue = object[key];\n  if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||\n      (value === undefined && !(key in object))) {\n    object[key] = value;\n  }\n}\n\n/**\n * Gets the index at which the `key` is found in `array` of key-value pairs.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {*} key The key to search for.\n * @returns {number} Returns the index of the matched value, else `-1`.\n */\nfunction assocIndexOf(array, key) {\n  var length = array.length;\n  while (length--) {\n    if (eq(array[length][0], key)) {\n      return length;\n    }\n  }\n  return -1;\n}\n\n/**\n * The base implementation of `_.assign` without support for multiple sources\n * or `customizer` functions.\n *\n * @private\n * @param {Object} object The destination object.\n * @param {Object} source The source object.\n * @returns {Object} Returns `object`.\n */\nfunction baseAssign(object, source) {\n  return object && copyObject(source, keys(source), object);\n}\n\n/**\n * The base implementation of `_.clone` and `_.cloneDeep` which tracks\n * traversed objects.\n *\n * @private\n * @param {*} value The value to clone.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @param {boolean} [isFull] Specify a clone including symbols.\n * @param {Function} [customizer] The function to customize cloning.\n * @param {string} [key] The key of `value`.\n * @param {Object} [object] The parent object of `value`.\n * @param {Object} [stack] Tracks traversed objects and their clone counterparts.\n * @returns {*} Returns the cloned value.\n */\nfunction baseClone(value, isDeep, isFull, customizer, key, object, stack) {\n  var result;\n  if (customizer) {\n    result = object ? customizer(value, key, object, stack) : customizer(value);\n  }\n  if (result !== undefined) {\n    return result;\n  }\n  if (!isObject(value)) {\n    return value;\n  }\n  var isArr = isArray(value);\n  if (isArr) {\n    result = initCloneArray(value);\n    if (!isDeep) {\n      return copyArray(value, result);\n    }\n  } else {\n    var tag = getTag(value),\n        isFunc = tag == funcTag || tag == genTag;\n\n    if (isBuffer(value)) {\n      return cloneBuffer(value, isDeep);\n    }\n    if (tag == objectTag || tag == argsTag || (isFunc && !object)) {\n      if (isHostObject(value)) {\n        return object ? value : {};\n      }\n      result = initCloneObject(isFunc ? {} : value);\n      if (!isDeep) {\n        return copySymbols(value, baseAssign(result, value));\n      }\n    } else {\n      if (!cloneableTags[tag]) {\n        return object ? value : {};\n      }\n      result = initCloneByTag(value, tag, baseClone, isDeep);\n    }\n  }\n  // Check for circular references and return its corresponding clone.\n  stack || (stack = new Stack);\n  var stacked = stack.get(value);\n  if (stacked) {\n    return stacked;\n  }\n  stack.set(value, result);\n\n  if (!isArr) {\n    var props = isFull ? getAllKeys(value) : keys(value);\n  }\n  arrayEach(props || value, function(subValue, key) {\n    if (props) {\n      key = subValue;\n      subValue = value[key];\n    }\n    // Recursively populate clone (susceptible to call stack limits).\n    assignValue(result, key, baseClone(subValue, isDeep, isFull, customizer, key, value, stack));\n  });\n  return result;\n}\n\n/**\n * The base implementation of `_.create` without support for assigning\n * properties to the created object.\n *\n * @private\n * @param {Object} prototype The object to inherit from.\n * @returns {Object} Returns the new object.\n */\nfunction baseCreate(proto) {\n  return isObject(proto) ? objectCreate(proto) : {};\n}\n\n/**\n * The base implementation of `getAllKeys` and `getAllKeysIn` which uses\n * `keysFunc` and `symbolsFunc` to get the enumerable property names and\n * symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {Function} keysFunc The function to get the keys of `object`.\n * @param {Function} symbolsFunc The function to get the symbols of `object`.\n * @returns {Array} Returns the array of property names and symbols.\n */\nfunction baseGetAllKeys(object, keysFunc, symbolsFunc) {\n  var result = keysFunc(object);\n  return isArray(object) ? result : arrayPush(result, symbolsFunc(object));\n}\n\n/**\n * The base implementation of `getTag`.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nfunction baseGetTag(value) {\n  return objectToString.call(value);\n}\n\n/**\n * The base implementation of `_.isNative` without bad shim checks.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a native function,\n *  else `false`.\n */\nfunction baseIsNative(value) {\n  if (!isObject(value) || isMasked(value)) {\n    return false;\n  }\n  var pattern = (isFunction(value) || isHostObject(value)) ? reIsNative : reIsHostCtor;\n  return pattern.test(toSource(value));\n}\n\n/**\n * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n */\nfunction baseKeys(object) {\n  if (!isPrototype(object)) {\n    return nativeKeys(object);\n  }\n  var result = [];\n  for (var key in Object(object)) {\n    if (hasOwnProperty.call(object, key) && key != 'constructor') {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\n/**\n * Creates a clone of  `buffer`.\n *\n * @private\n * @param {Buffer} buffer The buffer to clone.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @returns {Buffer} Returns the cloned buffer.\n */\nfunction cloneBuffer(buffer, isDeep) {\n  if (isDeep) {\n    return buffer.slice();\n  }\n  var result = new buffer.constructor(buffer.length);\n  buffer.copy(result);\n  return result;\n}\n\n/**\n * Creates a clone of `arrayBuffer`.\n *\n * @private\n * @param {ArrayBuffer} arrayBuffer The array buffer to clone.\n * @returns {ArrayBuffer} Returns the cloned array buffer.\n */\nfunction cloneArrayBuffer(arrayBuffer) {\n  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);\n  new Uint8Array(result).set(new Uint8Array(arrayBuffer));\n  return result;\n}\n\n/**\n * Creates a clone of `dataView`.\n *\n * @private\n * @param {Object} dataView The data view to clone.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @returns {Object} Returns the cloned data view.\n */\nfunction cloneDataView(dataView, isDeep) {\n  var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;\n  return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);\n}\n\n/**\n * Creates a clone of `map`.\n *\n * @private\n * @param {Object} map The map to clone.\n * @param {Function} cloneFunc The function to clone values.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @returns {Object} Returns the cloned map.\n */\nfunction cloneMap(map, isDeep, cloneFunc) {\n  var array = isDeep ? cloneFunc(mapToArray(map), true) : mapToArray(map);\n  return arrayReduce(array, addMapEntry, new map.constructor);\n}\n\n/**\n * Creates a clone of `regexp`.\n *\n * @private\n * @param {Object} regexp The regexp to clone.\n * @returns {Object} Returns the cloned regexp.\n */\nfunction cloneRegExp(regexp) {\n  var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));\n  result.lastIndex = regexp.lastIndex;\n  return result;\n}\n\n/**\n * Creates a clone of `set`.\n *\n * @private\n * @param {Object} set The set to clone.\n * @param {Function} cloneFunc The function to clone values.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @returns {Object} Returns the cloned set.\n */\nfunction cloneSet(set, isDeep, cloneFunc) {\n  var array = isDeep ? cloneFunc(setToArray(set), true) : setToArray(set);\n  return arrayReduce(array, addSetEntry, new set.constructor);\n}\n\n/**\n * Creates a clone of the `symbol` object.\n *\n * @private\n * @param {Object} symbol The symbol object to clone.\n * @returns {Object} Returns the cloned symbol object.\n */\nfunction cloneSymbol(symbol) {\n  return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};\n}\n\n/**\n * Creates a clone of `typedArray`.\n *\n * @private\n * @param {Object} typedArray The typed array to clone.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @returns {Object} Returns the cloned typed array.\n */\nfunction cloneTypedArray(typedArray, isDeep) {\n  var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;\n  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);\n}\n\n/**\n * Copies the values of `source` to `array`.\n *\n * @private\n * @param {Array} source The array to copy values from.\n * @param {Array} [array=[]] The array to copy values to.\n * @returns {Array} Returns `array`.\n */\nfunction copyArray(source, array) {\n  var index = -1,\n      length = source.length;\n\n  array || (array = Array(length));\n  while (++index < length) {\n    array[index] = source[index];\n  }\n  return array;\n}\n\n/**\n * Copies properties of `source` to `object`.\n *\n * @private\n * @param {Object} source The object to copy properties from.\n * @param {Array} props The property identifiers to copy.\n * @param {Object} [object={}] The object to copy properties to.\n * @param {Function} [customizer] The function to customize copied values.\n * @returns {Object} Returns `object`.\n */\nfunction copyObject(source, props, object, customizer) {\n  object || (object = {});\n\n  var index = -1,\n      length = props.length;\n\n  while (++index < length) {\n    var key = props[index];\n\n    var newValue = customizer\n      ? customizer(object[key], source[key], key, object, source)\n      : undefined;\n\n    assignValue(object, key, newValue === undefined ? source[key] : newValue);\n  }\n  return object;\n}\n\n/**\n * Copies own symbol properties of `source` to `object`.\n *\n * @private\n * @param {Object} source The object to copy symbols from.\n * @param {Object} [object={}] The object to copy symbols to.\n * @returns {Object} Returns `object`.\n */\nfunction copySymbols(source, object) {\n  return copyObject(source, getSymbols(source), object);\n}\n\n/**\n * Creates an array of own enumerable property names and symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names and symbols.\n */\nfunction getAllKeys(object) {\n  return baseGetAllKeys(object, keys, getSymbols);\n}\n\n/**\n * Gets the data for `map`.\n *\n * @private\n * @param {Object} map The map to query.\n * @param {string} key The reference key.\n * @returns {*} Returns the map data.\n */\nfunction getMapData(map, key) {\n  var data = map.__data__;\n  return isKeyable(key)\n    ? data[typeof key == 'string' ? 'string' : 'hash']\n    : data.map;\n}\n\n/**\n * Gets the native function at `key` of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {string} key The key of the method to get.\n * @returns {*} Returns the function if it's native, else `undefined`.\n */\nfunction getNative(object, key) {\n  var value = getValue(object, key);\n  return baseIsNative(value) ? value : undefined;\n}\n\n/**\n * Creates an array of the own enumerable symbol properties of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of symbols.\n */\nvar getSymbols = nativeGetSymbols ? overArg(nativeGetSymbols, Object) : stubArray;\n\n/**\n * Gets the `toStringTag` of `value`.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nvar getTag = baseGetTag;\n\n// Fallback for data views, maps, sets, and weak maps in IE 11,\n// for data views in Edge < 14, and promises in Node.js.\nif ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||\n    (Map && getTag(new Map) != mapTag) ||\n    (Promise && getTag(Promise.resolve()) != promiseTag) ||\n    (Set && getTag(new Set) != setTag) ||\n    (WeakMap && getTag(new WeakMap) != weakMapTag)) {\n  getTag = function(value) {\n    var result = objectToString.call(value),\n        Ctor = result == objectTag ? value.constructor : undefined,\n        ctorString = Ctor ? toSource(Ctor) : undefined;\n\n    if (ctorString) {\n      switch (ctorString) {\n        case dataViewCtorString: return dataViewTag;\n        case mapCtorString: return mapTag;\n        case promiseCtorString: return promiseTag;\n        case setCtorString: return setTag;\n        case weakMapCtorString: return weakMapTag;\n      }\n    }\n    return result;\n  };\n}\n\n/**\n * Initializes an array clone.\n *\n * @private\n * @param {Array} array The array to clone.\n * @returns {Array} Returns the initialized clone.\n */\nfunction initCloneArray(array) {\n  var length = array.length,\n      result = array.constructor(length);\n\n  // Add properties assigned by `RegExp#exec`.\n  if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {\n    result.index = array.index;\n    result.input = array.input;\n  }\n  return result;\n}\n\n/**\n * Initializes an object clone.\n *\n * @private\n * @param {Object} object The object to clone.\n * @returns {Object} Returns the initialized clone.\n */\nfunction initCloneObject(object) {\n  return (typeof object.constructor == 'function' && !isPrototype(object))\n    ? baseCreate(getPrototype(object))\n    : {};\n}\n\n/**\n * Initializes an object clone based on its `toStringTag`.\n *\n * **Note:** This function only supports cloning values with tags of\n * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.\n *\n * @private\n * @param {Object} object The object to clone.\n * @param {string} tag The `toStringTag` of the object to clone.\n * @param {Function} cloneFunc The function to clone values.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @returns {Object} Returns the initialized clone.\n */\nfunction initCloneByTag(object, tag, cloneFunc, isDeep) {\n  var Ctor = object.constructor;\n  switch (tag) {\n    case arrayBufferTag:\n      return cloneArrayBuffer(object);\n\n    case boolTag:\n    case dateTag:\n      return new Ctor(+object);\n\n    case dataViewTag:\n      return cloneDataView(object, isDeep);\n\n    case float32Tag: case float64Tag:\n    case int8Tag: case int16Tag: case int32Tag:\n    case uint8Tag: case uint8ClampedTag: case uint16Tag: case uint32Tag:\n      return cloneTypedArray(object, isDeep);\n\n    case mapTag:\n      return cloneMap(object, isDeep, cloneFunc);\n\n    case numberTag:\n    case stringTag:\n      return new Ctor(object);\n\n    case regexpTag:\n      return cloneRegExp(object);\n\n    case setTag:\n      return cloneSet(object, isDeep, cloneFunc);\n\n    case symbolTag:\n      return cloneSymbol(object);\n  }\n}\n\n/**\n * Checks if `value` is a valid array-like index.\n *\n * @private\n * @param {*} value The value to check.\n * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.\n * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.\n */\nfunction isIndex(value, length) {\n  length = length == null ? MAX_SAFE_INTEGER : length;\n  return !!length &&\n    (typeof value == 'number' || reIsUint.test(value)) &&\n    (value > -1 && value % 1 == 0 && value < length);\n}\n\n/**\n * Checks if `value` is suitable for use as unique object key.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is suitable, else `false`.\n */\nfunction isKeyable(value) {\n  var type = typeof value;\n  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')\n    ? (value !== '__proto__')\n    : (value === null);\n}\n\n/**\n * Checks if `func` has its source masked.\n *\n * @private\n * @param {Function} func The function to check.\n * @returns {boolean} Returns `true` if `func` is masked, else `false`.\n */\nfunction isMasked(func) {\n  return !!maskSrcKey && (maskSrcKey in func);\n}\n\n/**\n * Checks if `value` is likely a prototype object.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.\n */\nfunction isPrototype(value) {\n  var Ctor = value && value.constructor,\n      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;\n\n  return value === proto;\n}\n\n/**\n * Converts `func` to its source code.\n *\n * @private\n * @param {Function} func The function to process.\n * @returns {string} Returns the source code.\n */\nfunction toSource(func) {\n  if (func != null) {\n    try {\n      return funcToString.call(func);\n    } catch (e) {}\n    try {\n      return (func + '');\n    } catch (e) {}\n  }\n  return '';\n}\n\n/**\n * This method is like `_.clone` except that it recursively clones `value`.\n *\n * @static\n * @memberOf _\n * @since 1.0.0\n * @category Lang\n * @param {*} value The value to recursively clone.\n * @returns {*} Returns the deep cloned value.\n * @see _.clone\n * @example\n *\n * var objects = [{ 'a': 1 }, { 'b': 2 }];\n *\n * var deep = _.cloneDeep(objects);\n * console.log(deep[0] === objects[0]);\n * // => false\n */\nfunction cloneDeep(value) {\n  return baseClone(value, true, true);\n}\n\n/**\n * Performs a\n * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * comparison between two values to determine if they are equivalent.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n * @example\n *\n * var object = { 'a': 1 };\n * var other = { 'a': 1 };\n *\n * _.eq(object, object);\n * // => true\n *\n * _.eq(object, other);\n * // => false\n *\n * _.eq('a', 'a');\n * // => true\n *\n * _.eq('a', Object('a'));\n * // => false\n *\n * _.eq(NaN, NaN);\n * // => true\n */\nfunction eq(value, other) {\n  return value === other || (value !== value && other !== other);\n}\n\n/**\n * Checks if `value` is likely an `arguments` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n *  else `false`.\n * @example\n *\n * _.isArguments(function() { return arguments; }());\n * // => true\n *\n * _.isArguments([1, 2, 3]);\n * // => false\n */\nfunction isArguments(value) {\n  // Safari 8.1 makes `arguments.callee` enumerable in strict mode.\n  return isArrayLikeObject(value) && hasOwnProperty.call(value, 'callee') &&\n    (!propertyIsEnumerable.call(value, 'callee') || objectToString.call(value) == argsTag);\n}\n\n/**\n * Checks if `value` is classified as an `Array` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an array, else `false`.\n * @example\n *\n * _.isArray([1, 2, 3]);\n * // => true\n *\n * _.isArray(document.body.children);\n * // => false\n *\n * _.isArray('abc');\n * // => false\n *\n * _.isArray(_.noop);\n * // => false\n */\nvar isArray = Array.isArray;\n\n/**\n * Checks if `value` is array-like. A value is considered array-like if it's\n * not a function and has a `value.length` that's an integer greater than or\n * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is array-like, else `false`.\n * @example\n *\n * _.isArrayLike([1, 2, 3]);\n * // => true\n *\n * _.isArrayLike(document.body.children);\n * // => true\n *\n * _.isArrayLike('abc');\n * // => true\n *\n * _.isArrayLike(_.noop);\n * // => false\n */\nfunction isArrayLike(value) {\n  return value != null && isLength(value.length) && !isFunction(value);\n}\n\n/**\n * This method is like `_.isArrayLike` except that it also checks if `value`\n * is an object.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an array-like object,\n *  else `false`.\n * @example\n *\n * _.isArrayLikeObject([1, 2, 3]);\n * // => true\n *\n * _.isArrayLikeObject(document.body.children);\n * // => true\n *\n * _.isArrayLikeObject('abc');\n * // => false\n *\n * _.isArrayLikeObject(_.noop);\n * // => false\n */\nfunction isArrayLikeObject(value) {\n  return isObjectLike(value) && isArrayLike(value);\n}\n\n/**\n * Checks if `value` is a buffer.\n *\n * @static\n * @memberOf _\n * @since 4.3.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.\n * @example\n *\n * _.isBuffer(new Buffer(2));\n * // => true\n *\n * _.isBuffer(new Uint8Array(2));\n * // => false\n */\nvar isBuffer = nativeIsBuffer || stubFalse;\n\n/**\n * Checks if `value` is classified as a `Function` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a function, else `false`.\n * @example\n *\n * _.isFunction(_);\n * // => true\n *\n * _.isFunction(/abc/);\n * // => false\n */\nfunction isFunction(value) {\n  // The use of `Object#toString` avoids issues with the `typeof` operator\n  // in Safari 8-9 which returns 'object' for typed array and other constructors.\n  var tag = isObject(value) ? objectToString.call(value) : '';\n  return tag == funcTag || tag == genTag;\n}\n\n/**\n * Checks if `value` is a valid array-like length.\n *\n * **Note:** This method is loosely based on\n * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.\n * @example\n *\n * _.isLength(3);\n * // => true\n *\n * _.isLength(Number.MIN_VALUE);\n * // => false\n *\n * _.isLength(Infinity);\n * // => false\n *\n * _.isLength('3');\n * // => false\n */\nfunction isLength(value) {\n  return typeof value == 'number' &&\n    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;\n}\n\n/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */\nfunction isObject(value) {\n  var type = typeof value;\n  return !!value && (type == 'object' || type == 'function');\n}\n\n/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return !!value && typeof value == 'object';\n}\n\n/**\n * Creates an array of the own enumerable property names of `object`.\n *\n * **Note:** Non-object values are coerced to objects. See the\n * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)\n * for more details.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Object\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n *   this.b = 2;\n * }\n *\n * Foo.prototype.c = 3;\n *\n * _.keys(new Foo);\n * // => ['a', 'b'] (iteration order is not guaranteed)\n *\n * _.keys('hi');\n * // => ['0', '1']\n */\nfunction keys(object) {\n  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);\n}\n\n/**\n * This method returns a new empty array.\n *\n * @static\n * @memberOf _\n * @since 4.13.0\n * @category Util\n * @returns {Array} Returns the new empty array.\n * @example\n *\n * var arrays = _.times(2, _.stubArray);\n *\n * console.log(arrays);\n * // => [[], []]\n *\n * console.log(arrays[0] === arrays[1]);\n * // => false\n */\nfunction stubArray() {\n  return [];\n}\n\n/**\n * This method returns `false`.\n *\n * @static\n * @memberOf _\n * @since 4.13.0\n * @category Util\n * @returns {boolean} Returns `false`.\n * @example\n *\n * _.times(2, _.stubFalse);\n * // => [false, false]\n */\nfunction stubFalse() {\n  return false;\n}\n\nmodule.exports = cloneDeep;\n","/**\n * Helpers.\n */\n\nvar s = 1000;\nvar m = s * 60;\nvar h = m * 60;\nvar d = h * 24;\nvar w = d * 7;\nvar y = d * 365.25;\n\n/**\n * Parse or format the given `val`.\n *\n * Options:\n *\n *  - `long` verbose formatting [false]\n *\n * @param {String|Number} val\n * @param {Object} [options]\n * @throws {Error} throw an error if val is not a non-empty string or a number\n * @return {String|Number}\n * @api public\n */\n\nmodule.exports = function(val, options) {\n  options = options || {};\n  var type = typeof val;\n  if (type === 'string' && val.length > 0) {\n    return parse(val);\n  } else if (type === 'number' && isFinite(val)) {\n    return options.long ? fmtLong(val) : fmtShort(val);\n  }\n  throw new Error(\n    'val is not a non-empty string or a valid number. val=' +\n      JSON.stringify(val)\n  );\n};\n\n/**\n * Parse the given `str` and return milliseconds.\n *\n * @param {String} str\n * @return {Number}\n * @api private\n */\n\nfunction parse(str) {\n  str = String(str);\n  if (str.length > 100) {\n    return;\n  }\n  var match = /^(-?(?:\\d+)?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(\n    str\n  );\n  if (!match) {\n    return;\n  }\n  var n = parseFloat(match[1]);\n  var type = (match[2] || 'ms').toLowerCase();\n  switch (type) {\n    case 'years':\n    case 'year':\n    case 'yrs':\n    case 'yr':\n    case 'y':\n      return n * y;\n    case 'weeks':\n    case 'week':\n    case 'w':\n      return n * w;\n    case 'days':\n    case 'day':\n    case 'd':\n      return n * d;\n    case 'hours':\n    case 'hour':\n    case 'hrs':\n    case 'hr':\n    case 'h':\n      return n * h;\n    case 'minutes':\n    case 'minute':\n    case 'mins':\n    case 'min':\n    case 'm':\n      return n * m;\n    case 'seconds':\n    case 'second':\n    case 'secs':\n    case 'sec':\n    case 's':\n      return n * s;\n    case 'milliseconds':\n    case 'millisecond':\n    case 'msecs':\n    case 'msec':\n    case 'ms':\n      return n;\n    default:\n      return undefined;\n  }\n}\n\n/**\n * Short format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtShort(ms) {\n  var msAbs = Math.abs(ms);\n  if (msAbs >= d) {\n    return Math.round(ms / d) + 'd';\n  }\n  if (msAbs >= h) {\n    return Math.round(ms / h) + 'h';\n  }\n  if (msAbs >= m) {\n    return Math.round(ms / m) + 'm';\n  }\n  if (msAbs >= s) {\n    return Math.round(ms / s) + 's';\n  }\n  return ms + 'ms';\n}\n\n/**\n * Long format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtLong(ms) {\n  var msAbs = Math.abs(ms);\n  if (msAbs >= d) {\n    return plural(ms, msAbs, d, 'day');\n  }\n  if (msAbs >= h) {\n    return plural(ms, msAbs, h, 'hour');\n  }\n  if (msAbs >= m) {\n    return plural(ms, msAbs, m, 'minute');\n  }\n  if (msAbs >= s) {\n    return plural(ms, msAbs, s, 'second');\n  }\n  return ms + ' ms';\n}\n\n/**\n * Pluralization helper.\n */\n\nfunction plural(ms, msAbs, n, name) {\n  var isPlural = msAbs >= n * 1.5;\n  return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nexport class AsyncSerialScheduler {\n    constructor(observer) {\n        this._baseObserver = observer;\n        this._pendingPromises = new Set();\n    }\n    complete() {\n        Promise.all(this._pendingPromises)\n            .then(() => this._baseObserver.complete())\n            .catch(error => this._baseObserver.error(error));\n    }\n    error(error) {\n        this._baseObserver.error(error);\n    }\n    schedule(task) {\n        const prevPromisesCompletion = Promise.all(this._pendingPromises);\n        const values = [];\n        const next = (value) => values.push(value);\n        const promise = Promise.resolve()\n            .then(() => __awaiter(this, void 0, void 0, function* () {\n            yield prevPromisesCompletion;\n            yield task(next);\n            this._pendingPromises.delete(promise);\n            for (const value of values) {\n                this._baseObserver.next(value);\n            }\n        }))\n            .catch(error => {\n            this._pendingPromises.delete(promise);\n            this._baseObserver.error(error);\n        });\n        this._pendingPromises.add(promise);\n    }\n}\n","export const hasSymbols = () => typeof Symbol === \"function\";\nexport const hasSymbol = (name) => hasSymbols() && Boolean(Symbol[name]);\nexport const getSymbol = (name) => hasSymbol(name) ? Symbol[name] : \"@@\" + name;\nexport function registerObservableSymbol() {\n    if (hasSymbols() && !hasSymbol(\"observable\")) {\n        Symbol.observable = Symbol(\"observable\");\n    }\n}\nif (!hasSymbol(\"asyncIterator\")) {\n    Symbol.asyncIterator = Symbol.asyncIterator || Symbol.for(\"Symbol.asyncIterator\");\n}\n","/// <reference lib=\"es2018\" />\nimport { hasSymbol } from \"./_symbols\";\nexport function isAsyncIterator(thing) {\n    return thing && hasSymbol(\"asyncIterator\") && thing[Symbol.asyncIterator];\n}\nexport function isIterator(thing) {\n    return thing && hasSymbol(\"iterator\") && thing[Symbol.iterator];\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { AsyncSerialScheduler } from \"./_scheduler\";\nimport Observable from \"./observable\";\nimport unsubscribe from \"./unsubscribe\";\n/**\n * Filters the values emitted by another observable.\n * To be applied to an input observable using `pipe()`.\n */\nfunction filter(test) {\n    return (observable) => {\n        return new Observable(observer => {\n            const scheduler = new AsyncSerialScheduler(observer);\n            const subscription = observable.subscribe({\n                complete() {\n                    scheduler.complete();\n                },\n                error(error) {\n                    scheduler.error(error);\n                },\n                next(input) {\n                    scheduler.schedule((next) => __awaiter(this, void 0, void 0, function* () {\n                        if (yield test(input)) {\n                            next(input);\n                        }\n                    }));\n                }\n            });\n            return () => unsubscribe(subscription);\n        });\n    };\n}\nexport default filter;\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __asyncValues = (this && this.__asyncValues) || function (o) {\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n    var m = o[Symbol.asyncIterator], i;\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\n};\nimport { AsyncSerialScheduler } from \"./_scheduler\";\nimport { isAsyncIterator, isIterator } from \"./_util\";\nimport Observable from \"./observable\";\nimport unsubscribe from \"./unsubscribe\";\n/**\n * Maps the values emitted by another observable. In contrast to `map()`\n * the `mapper` function returns an array of values that will be emitted\n * separately.\n * Use `flatMap()` to map input values to zero, one or multiple output\n * values. To be applied to an input observable using `pipe()`.\n */\nfunction flatMap(mapper) {\n    return (observable) => {\n        return new Observable(observer => {\n            const scheduler = new AsyncSerialScheduler(observer);\n            const subscription = observable.subscribe({\n                complete() {\n                    scheduler.complete();\n                },\n                error(error) {\n                    scheduler.error(error);\n                },\n                next(input) {\n                    scheduler.schedule((next) => __awaiter(this, void 0, void 0, function* () {\n                        var e_1, _a;\n                        const mapped = yield mapper(input);\n                        if (isIterator(mapped) || isAsyncIterator(mapped)) {\n                            try {\n                                for (var mapped_1 = __asyncValues(mapped), mapped_1_1; mapped_1_1 = yield mapped_1.next(), !mapped_1_1.done;) {\n                                    const element = mapped_1_1.value;\n                                    next(element);\n                                }\n                            }\n                            catch (e_1_1) { e_1 = { error: e_1_1 }; }\n                            finally {\n                                try {\n                                    if (mapped_1_1 && !mapped_1_1.done && (_a = mapped_1.return)) yield _a.call(mapped_1);\n                                }\n                                finally { if (e_1) throw e_1.error; }\n                            }\n                        }\n                        else {\n                            mapped.map(output => next(output));\n                        }\n                    }));\n                }\n            });\n            return () => unsubscribe(subscription);\n        });\n    };\n}\nexport default flatMap;\n","export { default as filter } from \"./filter\";\nexport { default as flatMap } from \"./flatMap\";\nexport { default as interval } from \"./interval\";\nexport { default as map } from \"./map\";\nexport { default as merge } from \"./merge\";\nexport { default as multicast } from \"./multicast\";\nexport { default as Observable } from \"./observable\";\nexport { default as scan } from \"./scan\";\nexport { default as Subject } from \"./subject\";\nexport { default as unsubscribe } from \"./unsubscribe\";\n","import { Observable } from \"./observable\";\n/**\n * Creates an observable that yields a new value every `period` milliseconds.\n * The first value emitted is 0, then 1, 2, etc. The first value is not emitted\n * immediately, but after the first interval.\n */\nexport default function interval(period) {\n    return new Observable(observer => {\n        let counter = 0;\n        const handle = setInterval(() => {\n            observer.next(counter++);\n        }, period);\n        return () => clearInterval(handle);\n    });\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { AsyncSerialScheduler } from \"./_scheduler\";\nimport Observable from \"./observable\";\nimport unsubscribe from \"./unsubscribe\";\n/**\n * Maps the values emitted by another observable to different values.\n * To be applied to an input observable using `pipe()`.\n */\nfunction map(mapper) {\n    return (observable) => {\n        return new Observable(observer => {\n            const scheduler = new AsyncSerialScheduler(observer);\n            const subscription = observable.subscribe({\n                complete() {\n                    scheduler.complete();\n                },\n                error(error) {\n                    scheduler.error(error);\n                },\n                next(input) {\n                    scheduler.schedule((next) => __awaiter(this, void 0, void 0, function* () {\n                        const mapped = yield mapper(input);\n                        next(mapped);\n                    }));\n                }\n            });\n            return () => unsubscribe(subscription);\n        });\n    };\n}\nexport default map;\n","import { Observable } from \"./observable\";\nimport unsubscribe from \"./unsubscribe\";\nfunction merge(...observables) {\n    if (observables.length === 0) {\n        return Observable.from([]);\n    }\n    return new Observable(observer => {\n        let completed = 0;\n        const subscriptions = observables.map(input => {\n            return input.subscribe({\n                error(error) {\n                    observer.error(error);\n                    unsubscribeAll();\n                },\n                next(value) {\n                    observer.next(value);\n                },\n                complete() {\n                    if (++completed === observables.length) {\n                        observer.complete();\n                        unsubscribeAll();\n                    }\n                }\n            });\n        });\n        const unsubscribeAll = () => {\n            subscriptions.forEach(subscription => unsubscribe(subscription));\n        };\n        return unsubscribeAll;\n    });\n}\nexport default merge;\n","import Observable from \"./observable\";\nimport Subject from \"./subject\";\nimport unsubscribe from \"./unsubscribe\";\n// TODO: Subject already creates additional observables \"under the hood\",\n//       now we introduce even more. A true native MulticastObservable\n//       would be preferable.\n/**\n * Takes a \"cold\" observable and returns a wrapping \"hot\" observable that\n * proxies the input observable's values and errors.\n *\n * An observable is called \"cold\" when its initialization function is run\n * for each new subscriber. This is how observable-fns's `Observable`\n * implementation works.\n *\n * A hot observable is an observable where new subscribers subscribe to\n * the upcoming values of an already-initialiazed observable.\n *\n * The multicast observable will lazily subscribe to the source observable\n * once it has its first own subscriber and will unsubscribe from the\n * source observable when its last own subscriber unsubscribed.\n */\nfunction multicast(coldObservable) {\n    const subject = new Subject();\n    let sourceSubscription;\n    let subscriberCount = 0;\n    return new Observable(observer => {\n        // Init source subscription lazily\n        if (!sourceSubscription) {\n            sourceSubscription = coldObservable.subscribe(subject);\n        }\n        // Pipe all events from `subject` into this observable\n        const subscription = subject.subscribe(observer);\n        subscriberCount++;\n        return () => {\n            subscriberCount--;\n            subscription.unsubscribe();\n            // Close source subscription once last subscriber has unsubscribed\n            if (subscriberCount === 0) {\n                unsubscribe(sourceSubscription);\n                sourceSubscription = undefined;\n            }\n        };\n    });\n}\nexport default multicast;\n","/**\n * Based on <https://raw.githubusercontent.com/zenparsing/zen-observable/master/src/Observable.js>\n * At commit: f63849a8c60af5d514efc8e9d6138d8273c49ad6\n */\nimport \"./symbols\";\nimport { getSymbol, hasSymbol, hasSymbols } from \"./_symbols\";\nconst SymbolIterator = getSymbol(\"iterator\");\nconst SymbolObservable = getSymbol(\"observable\");\nconst SymbolSpecies = getSymbol(\"species\");\n// === Abstract Operations ===\nfunction getMethod(obj, key) {\n    const value = obj[key];\n    if (value == null) {\n        return undefined;\n    }\n    if (typeof value !== \"function\") {\n        throw new TypeError(value + \" is not a function\");\n    }\n    return value;\n}\nfunction getSpecies(obj) {\n    let ctor = obj.constructor;\n    if (ctor !== undefined) {\n        ctor = ctor[SymbolSpecies];\n        if (ctor === null) {\n            ctor = undefined;\n        }\n    }\n    return ctor !== undefined ? ctor : Observable;\n}\nfunction isObservable(x) {\n    return x instanceof Observable; // SPEC: Brand check\n}\nfunction hostReportError(error) {\n    if (hostReportError.log) {\n        hostReportError.log(error);\n    }\n    else {\n        setTimeout(() => { throw error; }, 0);\n    }\n}\nfunction enqueue(fn) {\n    Promise.resolve().then(() => {\n        try {\n            fn();\n        }\n        catch (e) {\n            hostReportError(e);\n        }\n    });\n}\nfunction cleanupSubscription(subscription) {\n    const cleanup = subscription._cleanup;\n    if (cleanup === undefined) {\n        return;\n    }\n    subscription._cleanup = undefined;\n    if (!cleanup) {\n        return;\n    }\n    try {\n        if (typeof cleanup === \"function\") {\n            cleanup();\n        }\n        else {\n            const unsubscribe = getMethod(cleanup, \"unsubscribe\");\n            if (unsubscribe) {\n                unsubscribe.call(cleanup);\n            }\n        }\n    }\n    catch (e) {\n        hostReportError(e);\n    }\n}\nfunction closeSubscription(subscription) {\n    subscription._observer = undefined;\n    subscription._queue = undefined;\n    subscription._state = \"closed\";\n}\nfunction flushSubscription(subscription) {\n    const queue = subscription._queue;\n    if (!queue) {\n        return;\n    }\n    subscription._queue = undefined;\n    subscription._state = \"ready\";\n    for (const item of queue) {\n        notifySubscription(subscription, item.type, item.value);\n        if (subscription._state === \"closed\") {\n            break;\n        }\n    }\n}\nfunction notifySubscription(subscription, type, value) {\n    subscription._state = \"running\";\n    const observer = subscription._observer;\n    try {\n        const m = observer ? getMethod(observer, type) : undefined;\n        switch (type) {\n            case \"next\":\n                if (m)\n                    m.call(observer, value);\n                break;\n            case \"error\":\n                closeSubscription(subscription);\n                if (m)\n                    m.call(observer, value);\n                else\n                    throw value;\n                break;\n            case \"complete\":\n                closeSubscription(subscription);\n                if (m)\n                    m.call(observer);\n                break;\n        }\n    }\n    catch (e) {\n        hostReportError(e);\n    }\n    if (subscription._state === \"closed\") {\n        cleanupSubscription(subscription);\n    }\n    else if (subscription._state === \"running\") {\n        subscription._state = \"ready\";\n    }\n}\nfunction onNotify(subscription, type, value) {\n    if (subscription._state === \"closed\") {\n        return;\n    }\n    if (subscription._state === \"buffering\") {\n        subscription._queue = subscription._queue || [];\n        subscription._queue.push({ type, value });\n        return;\n    }\n    if (subscription._state !== \"ready\") {\n        subscription._state = \"buffering\";\n        subscription._queue = [{ type, value }];\n        enqueue(() => flushSubscription(subscription));\n        return;\n    }\n    notifySubscription(subscription, type, value);\n}\nexport class Subscription {\n    constructor(observer, subscriber) {\n        // ASSERT: observer is an object\n        // ASSERT: subscriber is callable\n        this._cleanup = undefined;\n        this._observer = observer;\n        this._queue = undefined;\n        this._state = \"initializing\";\n        const subscriptionObserver = new SubscriptionObserver(this);\n        try {\n            this._cleanup = subscriber.call(undefined, subscriptionObserver);\n        }\n        catch (e) {\n            subscriptionObserver.error(e);\n        }\n        if (this._state === \"initializing\") {\n            this._state = \"ready\";\n        }\n    }\n    get closed() {\n        return this._state === \"closed\";\n    }\n    unsubscribe() {\n        if (this._state !== \"closed\") {\n            closeSubscription(this);\n            cleanupSubscription(this);\n        }\n    }\n}\nexport class SubscriptionObserver {\n    constructor(subscription) { this._subscription = subscription; }\n    get closed() { return this._subscription._state === \"closed\"; }\n    next(value) { onNotify(this._subscription, \"next\", value); }\n    error(value) { onNotify(this._subscription, \"error\", value); }\n    complete() { onNotify(this._subscription, \"complete\"); }\n}\n/**\n * The basic Observable class. This primitive is used to wrap asynchronous\n * data streams in a common standardized data type that is interoperable\n * between libraries and can be composed to represent more complex processes.\n */\nexport class Observable {\n    constructor(subscriber) {\n        if (!(this instanceof Observable)) {\n            throw new TypeError(\"Observable cannot be called as a function\");\n        }\n        if (typeof subscriber !== \"function\") {\n            throw new TypeError(\"Observable initializer must be a function\");\n        }\n        this._subscriber = subscriber;\n    }\n    subscribe(nextOrObserver, onError, onComplete) {\n        if (typeof nextOrObserver !== \"object\" || nextOrObserver === null) {\n            nextOrObserver = {\n                next: nextOrObserver,\n                error: onError,\n                complete: onComplete\n            };\n        }\n        return new Subscription(nextOrObserver, this._subscriber);\n    }\n    pipe(first, ...mappers) {\n        // tslint:disable-next-line no-this-assignment\n        let intermediate = this;\n        for (const mapper of [first, ...mappers]) {\n            intermediate = mapper(intermediate);\n        }\n        return intermediate;\n    }\n    tap(nextOrObserver, onError, onComplete) {\n        const tapObserver = typeof nextOrObserver !== \"object\" || nextOrObserver === null\n            ? {\n                next: nextOrObserver,\n                error: onError,\n                complete: onComplete\n            }\n            : nextOrObserver;\n        return new Observable(observer => {\n            return this.subscribe({\n                next(value) {\n                    tapObserver.next && tapObserver.next(value);\n                    observer.next(value);\n                },\n                error(error) {\n                    tapObserver.error && tapObserver.error(error);\n                    observer.error(error);\n                },\n                complete() {\n                    tapObserver.complete && tapObserver.complete();\n                    observer.complete();\n                },\n                start(subscription) {\n                    tapObserver.start && tapObserver.start(subscription);\n                }\n            });\n        });\n    }\n    forEach(fn) {\n        return new Promise((resolve, reject) => {\n            if (typeof fn !== \"function\") {\n                reject(new TypeError(fn + \" is not a function\"));\n                return;\n            }\n            function done() {\n                subscription.unsubscribe();\n                resolve(undefined);\n            }\n            const subscription = this.subscribe({\n                next(value) {\n                    try {\n                        fn(value, done);\n                    }\n                    catch (e) {\n                        reject(e);\n                        subscription.unsubscribe();\n                    }\n                },\n                error(error) {\n                    reject(error);\n                },\n                complete() {\n                    resolve(undefined);\n                }\n            });\n        });\n    }\n    map(fn) {\n        if (typeof fn !== \"function\") {\n            throw new TypeError(fn + \" is not a function\");\n        }\n        const C = getSpecies(this);\n        return new C(observer => this.subscribe({\n            next(value) {\n                let propagatedValue = value;\n                try {\n                    propagatedValue = fn(value);\n                }\n                catch (e) {\n                    return observer.error(e);\n                }\n                observer.next(propagatedValue);\n            },\n            error(e) { observer.error(e); },\n            complete() { observer.complete(); },\n        }));\n    }\n    filter(fn) {\n        if (typeof fn !== \"function\") {\n            throw new TypeError(fn + \" is not a function\");\n        }\n        const C = getSpecies(this);\n        return new C(observer => this.subscribe({\n            next(value) {\n                try {\n                    if (!fn(value))\n                        return;\n                }\n                catch (e) {\n                    return observer.error(e);\n                }\n                observer.next(value);\n            },\n            error(e) { observer.error(e); },\n            complete() { observer.complete(); },\n        }));\n    }\n    reduce(fn, seed) {\n        if (typeof fn !== \"function\") {\n            throw new TypeError(fn + \" is not a function\");\n        }\n        const C = getSpecies(this);\n        const hasSeed = arguments.length > 1;\n        let hasValue = false;\n        let acc = seed;\n        return new C(observer => this.subscribe({\n            next(value) {\n                const first = !hasValue;\n                hasValue = true;\n                if (!first || hasSeed) {\n                    try {\n                        acc = fn(acc, value);\n                    }\n                    catch (e) {\n                        return observer.error(e);\n                    }\n                }\n                else {\n                    acc = value;\n                }\n            },\n            error(e) { observer.error(e); },\n            complete() {\n                if (!hasValue && !hasSeed) {\n                    return observer.error(new TypeError(\"Cannot reduce an empty sequence\"));\n                }\n                observer.next(acc);\n                observer.complete();\n            },\n        }));\n    }\n    concat(...sources) {\n        const C = getSpecies(this);\n        return new C(observer => {\n            let subscription;\n            let index = 0;\n            function startNext(next) {\n                subscription = next.subscribe({\n                    next(v) { observer.next(v); },\n                    error(e) { observer.error(e); },\n                    complete() {\n                        if (index === sources.length) {\n                            subscription = undefined;\n                            observer.complete();\n                        }\n                        else {\n                            startNext(C.from(sources[index++]));\n                        }\n                    },\n                });\n            }\n            startNext(this);\n            return () => {\n                if (subscription) {\n                    subscription.unsubscribe();\n                    subscription = undefined;\n                }\n            };\n        });\n    }\n    flatMap(fn) {\n        if (typeof fn !== \"function\") {\n            throw new TypeError(fn + \" is not a function\");\n        }\n        const C = getSpecies(this);\n        return new C(observer => {\n            const subscriptions = [];\n            const outer = this.subscribe({\n                next(value) {\n                    let normalizedValue;\n                    if (fn) {\n                        try {\n                            normalizedValue = fn(value);\n                        }\n                        catch (e) {\n                            return observer.error(e);\n                        }\n                    }\n                    else {\n                        normalizedValue = value;\n                    }\n                    const inner = C.from(normalizedValue).subscribe({\n                        next(innerValue) { observer.next(innerValue); },\n                        error(e) { observer.error(e); },\n                        complete() {\n                            const i = subscriptions.indexOf(inner);\n                            if (i >= 0)\n                                subscriptions.splice(i, 1);\n                            completeIfDone();\n                        },\n                    });\n                    subscriptions.push(inner);\n                },\n                error(e) { observer.error(e); },\n                complete() { completeIfDone(); },\n            });\n            function completeIfDone() {\n                if (outer.closed && subscriptions.length === 0) {\n                    observer.complete();\n                }\n            }\n            return () => {\n                subscriptions.forEach(s => s.unsubscribe());\n                outer.unsubscribe();\n            };\n        });\n    }\n    [(Symbol.observable, SymbolObservable)]() { return this; }\n    static from(x) {\n        const C = (typeof this === \"function\" ? this : Observable);\n        if (x == null) {\n            throw new TypeError(x + \" is not an object\");\n        }\n        const observableMethod = getMethod(x, SymbolObservable);\n        if (observableMethod) {\n            const observable = observableMethod.call(x);\n            if (Object(observable) !== observable) {\n                throw new TypeError(observable + \" is not an object\");\n            }\n            if (isObservable(observable) && observable.constructor === C) {\n                return observable;\n            }\n            return new C(observer => observable.subscribe(observer));\n        }\n        if (hasSymbol(\"iterator\")) {\n            const iteratorMethod = getMethod(x, SymbolIterator);\n            if (iteratorMethod) {\n                return new C(observer => {\n                    enqueue(() => {\n                        if (observer.closed)\n                            return;\n                        for (const item of iteratorMethod.call(x)) {\n                            observer.next(item);\n                            if (observer.closed)\n                                return;\n                        }\n                        observer.complete();\n                    });\n                });\n            }\n        }\n        if (Array.isArray(x)) {\n            return new C(observer => {\n                enqueue(() => {\n                    if (observer.closed)\n                        return;\n                    for (const item of x) {\n                        observer.next(item);\n                        if (observer.closed)\n                            return;\n                    }\n                    observer.complete();\n                });\n            });\n        }\n        throw new TypeError(x + \" is not observable\");\n    }\n    static of(...items) {\n        const C = (typeof this === \"function\" ? this : Observable);\n        return new C(observer => {\n            enqueue(() => {\n                if (observer.closed)\n                    return;\n                for (const item of items) {\n                    observer.next(item);\n                    if (observer.closed)\n                        return;\n                }\n                observer.complete();\n            });\n        });\n    }\n    static get [SymbolSpecies]() { return this; }\n}\nif (hasSymbols()) {\n    Object.defineProperty(Observable, Symbol(\"extensions\"), {\n        value: {\n            symbol: SymbolObservable,\n            hostReportError,\n        },\n        configurable: true,\n    });\n}\nexport default Observable;\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { AsyncSerialScheduler } from \"./_scheduler\";\nimport Observable from \"./observable\";\nimport unsubscribe from \"./unsubscribe\";\nfunction scan(accumulator, seed) {\n    return (observable) => {\n        return new Observable(observer => {\n            let accumulated;\n            let index = 0;\n            const scheduler = new AsyncSerialScheduler(observer);\n            const subscription = observable.subscribe({\n                complete() {\n                    scheduler.complete();\n                },\n                error(error) {\n                    scheduler.error(error);\n                },\n                next(value) {\n                    scheduler.schedule((next) => __awaiter(this, void 0, void 0, function* () {\n                        const prevAcc = index === 0\n                            ? (typeof seed === \"undefined\" ? value : seed)\n                            : accumulated;\n                        accumulated = yield accumulator(prevAcc, value, index++);\n                        next(accumulated);\n                    }));\n                }\n            });\n            return () => unsubscribe(subscription);\n        });\n    };\n}\nexport default scan;\n","import Observable from \"./observable\";\n// TODO: This observer iteration approach looks inelegant and expensive\n// Idea: Come up with super class for Subscription that contains the\n//       notify*, ... methods and use it here\n/**\n * A subject is a \"hot\" observable (see `multicast`) that has its observer\n * methods (`.next(value)`, `.error(error)`, `.complete()`) exposed.\n *\n * Be careful, though! With great power comes great responsibility. Only use\n * the `Subject` when you really need to trigger updates \"from the outside\" and\n * try to keep the code that can access it to a minimum. Return\n * `Observable.from(mySubject)` to not allow other code to mutate.\n */\nclass MulticastSubject extends Observable {\n    constructor() {\n        super(observer => {\n            this._observers.add(observer);\n            return () => this._observers.delete(observer);\n        });\n        this._observers = new Set();\n    }\n    next(value) {\n        for (const observer of this._observers) {\n            observer.next(value);\n        }\n    }\n    error(error) {\n        for (const observer of this._observers) {\n            observer.error(error);\n        }\n    }\n    complete() {\n        for (const observer of this._observers) {\n            observer.complete();\n        }\n    }\n}\nexport default MulticastSubject;\n","/**\n * Unsubscribe from a subscription returned by something that looks like an observable,\n * but is not necessarily our observable implementation.\n */\nfunction unsubscribe(subscription) {\n    if (typeof subscription === \"function\") {\n        subscription();\n    }\n    else if (subscription && typeof subscription.unsubscribe === \"function\") {\n        subscription.unsubscribe();\n    }\n}\nexport default unsubscribe;\n","/*! *****************************************************************************\nCopyright (C) Microsoft. All rights reserved.\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\nthis file except in compliance with the License. You may obtain a copy of the\nLicense at http://www.apache.org/licenses/LICENSE-2.0\n\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\nMERCHANTABLITY OR NON-INFRINGEMENT.\n\nSee the Apache Version 2.0 License for specific language governing permissions\nand limitations under the License.\n***************************************************************************** */\nvar Reflect;\n(function (Reflect) {\n    // Metadata Proposal\n    // https://rbuckton.github.io/reflect-metadata/\n    (function (factory) {\n        var root = typeof global === \"object\" ? global :\n            typeof self === \"object\" ? self :\n                typeof this === \"object\" ? this :\n                    Function(\"return this;\")();\n        var exporter = makeExporter(Reflect);\n        if (typeof root.Reflect === \"undefined\") {\n            root.Reflect = Reflect;\n        }\n        else {\n            exporter = makeExporter(root.Reflect, exporter);\n        }\n        factory(exporter);\n        function makeExporter(target, previous) {\n            return function (key, value) {\n                if (typeof target[key] !== \"function\") {\n                    Object.defineProperty(target, key, { configurable: true, writable: true, value: value });\n                }\n                if (previous)\n                    previous(key, value);\n            };\n        }\n    })(function (exporter) {\n        var hasOwn = Object.prototype.hasOwnProperty;\n        // feature test for Symbol support\n        var supportsSymbol = typeof Symbol === \"function\";\n        var toPrimitiveSymbol = supportsSymbol && typeof Symbol.toPrimitive !== \"undefined\" ? Symbol.toPrimitive : \"@@toPrimitive\";\n        var iteratorSymbol = supportsSymbol && typeof Symbol.iterator !== \"undefined\" ? Symbol.iterator : \"@@iterator\";\n        var supportsCreate = typeof Object.create === \"function\"; // feature test for Object.create support\n        var supportsProto = { __proto__: [] } instanceof Array; // feature test for __proto__ support\n        var downLevel = !supportsCreate && !supportsProto;\n        var HashMap = {\n            // create an object in dictionary mode (a.k.a. \"slow\" mode in v8)\n            create: supportsCreate\n                ? function () { return MakeDictionary(Object.create(null)); }\n                : supportsProto\n                    ? function () { return MakeDictionary({ __proto__: null }); }\n                    : function () { return MakeDictionary({}); },\n            has: downLevel\n                ? function (map, key) { return hasOwn.call(map, key); }\n                : function (map, key) { return key in map; },\n            get: downLevel\n                ? function (map, key) { return hasOwn.call(map, key) ? map[key] : undefined; }\n                : function (map, key) { return map[key]; },\n        };\n        // Load global or shim versions of Map, Set, and WeakMap\n        var functionPrototype = Object.getPrototypeOf(Function);\n        var usePolyfill = typeof process === \"object\" && process.env && process.env[\"REFLECT_METADATA_USE_MAP_POLYFILL\"] === \"true\";\n        var _Map = !usePolyfill && typeof Map === \"function\" && typeof Map.prototype.entries === \"function\" ? Map : CreateMapPolyfill();\n        var _Set = !usePolyfill && typeof Set === \"function\" && typeof Set.prototype.entries === \"function\" ? Set : CreateSetPolyfill();\n        var _WeakMap = !usePolyfill && typeof WeakMap === \"function\" ? WeakMap : CreateWeakMapPolyfill();\n        // [[Metadata]] internal slot\n        // https://rbuckton.github.io/reflect-metadata/#ordinary-object-internal-methods-and-internal-slots\n        var Metadata = new _WeakMap();\n        /**\n         * Applies a set of decorators to a property of a target object.\n         * @param decorators An array of decorators.\n         * @param target The target object.\n         * @param propertyKey (Optional) The property key to decorate.\n         * @param attributes (Optional) The property descriptor for the target key.\n         * @remarks Decorators are applied in reverse order.\n         * @example\n         *\n         *     class Example {\n         *         // property declarations are not part of ES6, though they are valid in TypeScript:\n         *         // static staticProperty;\n         *         // property;\n         *\n         *         constructor(p) { }\n         *         static staticMethod(p) { }\n         *         method(p) { }\n         *     }\n         *\n         *     // constructor\n         *     Example = Reflect.decorate(decoratorsArray, Example);\n         *\n         *     // property (on constructor)\n         *     Reflect.decorate(decoratorsArray, Example, \"staticProperty\");\n         *\n         *     // property (on prototype)\n         *     Reflect.decorate(decoratorsArray, Example.prototype, \"property\");\n         *\n         *     // method (on constructor)\n         *     Object.defineProperty(Example, \"staticMethod\",\n         *         Reflect.decorate(decoratorsArray, Example, \"staticMethod\",\n         *             Object.getOwnPropertyDescriptor(Example, \"staticMethod\")));\n         *\n         *     // method (on prototype)\n         *     Object.defineProperty(Example.prototype, \"method\",\n         *         Reflect.decorate(decoratorsArray, Example.prototype, \"method\",\n         *             Object.getOwnPropertyDescriptor(Example.prototype, \"method\")));\n         *\n         */\n        function decorate(decorators, target, propertyKey, attributes) {\n            if (!IsUndefined(propertyKey)) {\n                if (!IsArray(decorators))\n                    throw new TypeError();\n                if (!IsObject(target))\n                    throw new TypeError();\n                if (!IsObject(attributes) && !IsUndefined(attributes) && !IsNull(attributes))\n                    throw new TypeError();\n                if (IsNull(attributes))\n                    attributes = undefined;\n                propertyKey = ToPropertyKey(propertyKey);\n                return DecorateProperty(decorators, target, propertyKey, attributes);\n            }\n            else {\n                if (!IsArray(decorators))\n                    throw new TypeError();\n                if (!IsConstructor(target))\n                    throw new TypeError();\n                return DecorateConstructor(decorators, target);\n            }\n        }\n        exporter(\"decorate\", decorate);\n        // 4.1.2 Reflect.metadata(metadataKey, metadataValue)\n        // https://rbuckton.github.io/reflect-metadata/#reflect.metadata\n        /**\n         * A default metadata decorator factory that can be used on a class, class member, or parameter.\n         * @param metadataKey The key for the metadata entry.\n         * @param metadataValue The value for the metadata entry.\n         * @returns A decorator function.\n         * @remarks\n         * If `metadataKey` is already defined for the target and target key, the\n         * metadataValue for that key will be overwritten.\n         * @example\n         *\n         *     // constructor\n         *     @Reflect.metadata(key, value)\n         *     class Example {\n         *     }\n         *\n         *     // property (on constructor, TypeScript only)\n         *     class Example {\n         *         @Reflect.metadata(key, value)\n         *         static staticProperty;\n         *     }\n         *\n         *     // property (on prototype, TypeScript only)\n         *     class Example {\n         *         @Reflect.metadata(key, value)\n         *         property;\n         *     }\n         *\n         *     // method (on constructor)\n         *     class Example {\n         *         @Reflect.metadata(key, value)\n         *         static staticMethod() { }\n         *     }\n         *\n         *     // method (on prototype)\n         *     class Example {\n         *         @Reflect.metadata(key, value)\n         *         method() { }\n         *     }\n         *\n         */\n        function metadata(metadataKey, metadataValue) {\n            function decorator(target, propertyKey) {\n                if (!IsObject(target))\n                    throw new TypeError();\n                if (!IsUndefined(propertyKey) && !IsPropertyKey(propertyKey))\n                    throw new TypeError();\n                OrdinaryDefineOwnMetadata(metadataKey, metadataValue, target, propertyKey);\n            }\n            return decorator;\n        }\n        exporter(\"metadata\", metadata);\n        /**\n         * Define a unique metadata entry on the target.\n         * @param metadataKey A key used to store and retrieve metadata.\n         * @param metadataValue A value that contains attached metadata.\n         * @param target The target object on which to define metadata.\n         * @param propertyKey (Optional) The property key for the target.\n         * @example\n         *\n         *     class Example {\n         *         // property declarations are not part of ES6, though they are valid in TypeScript:\n         *         // static staticProperty;\n         *         // property;\n         *\n         *         constructor(p) { }\n         *         static staticMethod(p) { }\n         *         method(p) { }\n         *     }\n         *\n         *     // constructor\n         *     Reflect.defineMetadata(\"custom:annotation\", options, Example);\n         *\n         *     // property (on constructor)\n         *     Reflect.defineMetadata(\"custom:annotation\", options, Example, \"staticProperty\");\n         *\n         *     // property (on prototype)\n         *     Reflect.defineMetadata(\"custom:annotation\", options, Example.prototype, \"property\");\n         *\n         *     // method (on constructor)\n         *     Reflect.defineMetadata(\"custom:annotation\", options, Example, \"staticMethod\");\n         *\n         *     // method (on prototype)\n         *     Reflect.defineMetadata(\"custom:annotation\", options, Example.prototype, \"method\");\n         *\n         *     // decorator factory as metadata-producing annotation.\n         *     function MyAnnotation(options): Decorator {\n         *         return (target, key?) => Reflect.defineMetadata(\"custom:annotation\", options, target, key);\n         *     }\n         *\n         */\n        function defineMetadata(metadataKey, metadataValue, target, propertyKey) {\n            if (!IsObject(target))\n                throw new TypeError();\n            if (!IsUndefined(propertyKey))\n                propertyKey = ToPropertyKey(propertyKey);\n            return OrdinaryDefineOwnMetadata(metadataKey, metadataValue, target, propertyKey);\n        }\n        exporter(\"defineMetadata\", defineMetadata);\n        /**\n         * Gets a value indicating whether the target object or its prototype chain has the provided metadata key defined.\n         * @param metadataKey A key used to store and retrieve metadata.\n         * @param target The target object on which the metadata is defined.\n         * @param propertyKey (Optional) The property key for the target.\n         * @returns `true` if the metadata key was defined on the target object or its prototype chain; otherwise, `false`.\n         * @example\n         *\n         *     class Example {\n         *         // property declarations are not part of ES6, though they are valid in TypeScript:\n         *         // static staticProperty;\n         *         // property;\n         *\n         *         constructor(p) { }\n         *         static staticMethod(p) { }\n         *         method(p) { }\n         *     }\n         *\n         *     // constructor\n         *     result = Reflect.hasMetadata(\"custom:annotation\", Example);\n         *\n         *     // property (on constructor)\n         *     result = Reflect.hasMetadata(\"custom:annotation\", Example, \"staticProperty\");\n         *\n         *     // property (on prototype)\n         *     result = Reflect.hasMetadata(\"custom:annotation\", Example.prototype, \"property\");\n         *\n         *     // method (on constructor)\n         *     result = Reflect.hasMetadata(\"custom:annotation\", Example, \"staticMethod\");\n         *\n         *     // method (on prototype)\n         *     result = Reflect.hasMetadata(\"custom:annotation\", Example.prototype, \"method\");\n         *\n         */\n        function hasMetadata(metadataKey, target, propertyKey) {\n            if (!IsObject(target))\n                throw new TypeError();\n            if (!IsUndefined(propertyKey))\n                propertyKey = ToPropertyKey(propertyKey);\n            return OrdinaryHasMetadata(metadataKey, target, propertyKey);\n        }\n        exporter(\"hasMetadata\", hasMetadata);\n        /**\n         * Gets a value indicating whether the target object has the provided metadata key defined.\n         * @param metadataKey A key used to store and retrieve metadata.\n         * @param target The target object on which the metadata is defined.\n         * @param propertyKey (Optional) The property key for the target.\n         * @returns `true` if the metadata key was defined on the target object; otherwise, `false`.\n         * @example\n         *\n         *     class Example {\n         *         // property declarations are not part of ES6, though they are valid in TypeScript:\n         *         // static staticProperty;\n         *         // property;\n         *\n         *         constructor(p) { }\n         *         static staticMethod(p) { }\n         *         method(p) { }\n         *     }\n         *\n         *     // constructor\n         *     result = Reflect.hasOwnMetadata(\"custom:annotation\", Example);\n         *\n         *     // property (on constructor)\n         *     result = Reflect.hasOwnMetadata(\"custom:annotation\", Example, \"staticProperty\");\n         *\n         *     // property (on prototype)\n         *     result = Reflect.hasOwnMetadata(\"custom:annotation\", Example.prototype, \"property\");\n         *\n         *     // method (on constructor)\n         *     result = Reflect.hasOwnMetadata(\"custom:annotation\", Example, \"staticMethod\");\n         *\n         *     // method (on prototype)\n         *     result = Reflect.hasOwnMetadata(\"custom:annotation\", Example.prototype, \"method\");\n         *\n         */\n        function hasOwnMetadata(metadataKey, target, propertyKey) {\n            if (!IsObject(target))\n                throw new TypeError();\n            if (!IsUndefined(propertyKey))\n                propertyKey = ToPropertyKey(propertyKey);\n            return OrdinaryHasOwnMetadata(metadataKey, target, propertyKey);\n        }\n        exporter(\"hasOwnMetadata\", hasOwnMetadata);\n        /**\n         * Gets the metadata value for the provided metadata key on the target object or its prototype chain.\n         * @param metadataKey A key used to store and retrieve metadata.\n         * @param target The target object on which the metadata is defined.\n         * @param propertyKey (Optional) The property key for the target.\n         * @returns The metadata value for the metadata key if found; otherwise, `undefined`.\n         * @example\n         *\n         *     class Example {\n         *         // property declarations are not part of ES6, though they are valid in TypeScript:\n         *         // static staticProperty;\n         *         // property;\n         *\n         *         constructor(p) { }\n         *         static staticMethod(p) { }\n         *         method(p) { }\n         *     }\n         *\n         *     // constructor\n         *     result = Reflect.getMetadata(\"custom:annotation\", Example);\n         *\n         *     // property (on constructor)\n         *     result = Reflect.getMetadata(\"custom:annotation\", Example, \"staticProperty\");\n         *\n         *     // property (on prototype)\n         *     result = Reflect.getMetadata(\"custom:annotation\", Example.prototype, \"property\");\n         *\n         *     // method (on constructor)\n         *     result = Reflect.getMetadata(\"custom:annotation\", Example, \"staticMethod\");\n         *\n         *     // method (on prototype)\n         *     result = Reflect.getMetadata(\"custom:annotation\", Example.prototype, \"method\");\n         *\n         */\n        function getMetadata(metadataKey, target, propertyKey) {\n            if (!IsObject(target))\n                throw new TypeError();\n            if (!IsUndefined(propertyKey))\n                propertyKey = ToPropertyKey(propertyKey);\n            return OrdinaryGetMetadata(metadataKey, target, propertyKey);\n        }\n        exporter(\"getMetadata\", getMetadata);\n        /**\n         * Gets the metadata value for the provided metadata key on the target object.\n         * @param metadataKey A key used to store and retrieve metadata.\n         * @param target The target object on which the metadata is defined.\n         * @param propertyKey (Optional) The property key for the target.\n         * @returns The metadata value for the metadata key if found; otherwise, `undefined`.\n         * @example\n         *\n         *     class Example {\n         *         // property declarations are not part of ES6, though they are valid in TypeScript:\n         *         // static staticProperty;\n         *         // property;\n         *\n         *         constructor(p) { }\n         *         static staticMethod(p) { }\n         *         method(p) { }\n         *     }\n         *\n         *     // constructor\n         *     result = Reflect.getOwnMetadata(\"custom:annotation\", Example);\n         *\n         *     // property (on constructor)\n         *     result = Reflect.getOwnMetadata(\"custom:annotation\", Example, \"staticProperty\");\n         *\n         *     // property (on prototype)\n         *     result = Reflect.getOwnMetadata(\"custom:annotation\", Example.prototype, \"property\");\n         *\n         *     // method (on constructor)\n         *     result = Reflect.getOwnMetadata(\"custom:annotation\", Example, \"staticMethod\");\n         *\n         *     // method (on prototype)\n         *     result = Reflect.getOwnMetadata(\"custom:annotation\", Example.prototype, \"method\");\n         *\n         */\n        function getOwnMetadata(metadataKey, target, propertyKey) {\n            if (!IsObject(target))\n                throw new TypeError();\n            if (!IsUndefined(propertyKey))\n                propertyKey = ToPropertyKey(propertyKey);\n            return OrdinaryGetOwnMetadata(metadataKey, target, propertyKey);\n        }\n        exporter(\"getOwnMetadata\", getOwnMetadata);\n        /**\n         * Gets the metadata keys defined on the target object or its prototype chain.\n         * @param target The target object on which the metadata is defined.\n         * @param propertyKey (Optional) The property key for the target.\n         * @returns An array of unique metadata keys.\n         * @example\n         *\n         *     class Example {\n         *         // property declarations are not part of ES6, though they are valid in TypeScript:\n         *         // static staticProperty;\n         *         // property;\n         *\n         *         constructor(p) { }\n         *         static staticMethod(p) { }\n         *         method(p) { }\n         *     }\n         *\n         *     // constructor\n         *     result = Reflect.getMetadataKeys(Example);\n         *\n         *     // property (on constructor)\n         *     result = Reflect.getMetadataKeys(Example, \"staticProperty\");\n         *\n         *     // property (on prototype)\n         *     result = Reflect.getMetadataKeys(Example.prototype, \"property\");\n         *\n         *     // method (on constructor)\n         *     result = Reflect.getMetadataKeys(Example, \"staticMethod\");\n         *\n         *     // method (on prototype)\n         *     result = Reflect.getMetadataKeys(Example.prototype, \"method\");\n         *\n         */\n        function getMetadataKeys(target, propertyKey) {\n            if (!IsObject(target))\n                throw new TypeError();\n            if (!IsUndefined(propertyKey))\n                propertyKey = ToPropertyKey(propertyKey);\n            return OrdinaryMetadataKeys(target, propertyKey);\n        }\n        exporter(\"getMetadataKeys\", getMetadataKeys);\n        /**\n         * Gets the unique metadata keys defined on the target object.\n         * @param target The target object on which the metadata is defined.\n         * @param propertyKey (Optional) The property key for the target.\n         * @returns An array of unique metadata keys.\n         * @example\n         *\n         *     class Example {\n         *         // property declarations are not part of ES6, though they are valid in TypeScript:\n         *         // static staticProperty;\n         *         // property;\n         *\n         *         constructor(p) { }\n         *         static staticMethod(p) { }\n         *         method(p) { }\n         *     }\n         *\n         *     // constructor\n         *     result = Reflect.getOwnMetadataKeys(Example);\n         *\n         *     // property (on constructor)\n         *     result = Reflect.getOwnMetadataKeys(Example, \"staticProperty\");\n         *\n         *     // property (on prototype)\n         *     result = Reflect.getOwnMetadataKeys(Example.prototype, \"property\");\n         *\n         *     // method (on constructor)\n         *     result = Reflect.getOwnMetadataKeys(Example, \"staticMethod\");\n         *\n         *     // method (on prototype)\n         *     result = Reflect.getOwnMetadataKeys(Example.prototype, \"method\");\n         *\n         */\n        function getOwnMetadataKeys(target, propertyKey) {\n            if (!IsObject(target))\n                throw new TypeError();\n            if (!IsUndefined(propertyKey))\n                propertyKey = ToPropertyKey(propertyKey);\n            return OrdinaryOwnMetadataKeys(target, propertyKey);\n        }\n        exporter(\"getOwnMetadataKeys\", getOwnMetadataKeys);\n        /**\n         * Deletes the metadata entry from the target object with the provided key.\n         * @param metadataKey A key used to store and retrieve metadata.\n         * @param target The target object on which the metadata is defined.\n         * @param propertyKey (Optional) The property key for the target.\n         * @returns `true` if the metadata entry was found and deleted; otherwise, false.\n         * @example\n         *\n         *     class Example {\n         *         // property declarations are not part of ES6, though they are valid in TypeScript:\n         *         // static staticProperty;\n         *         // property;\n         *\n         *         constructor(p) { }\n         *         static staticMethod(p) { }\n         *         method(p) { }\n         *     }\n         *\n         *     // constructor\n         *     result = Reflect.deleteMetadata(\"custom:annotation\", Example);\n         *\n         *     // property (on constructor)\n         *     result = Reflect.deleteMetadata(\"custom:annotation\", Example, \"staticProperty\");\n         *\n         *     // property (on prototype)\n         *     result = Reflect.deleteMetadata(\"custom:annotation\", Example.prototype, \"property\");\n         *\n         *     // method (on constructor)\n         *     result = Reflect.deleteMetadata(\"custom:annotation\", Example, \"staticMethod\");\n         *\n         *     // method (on prototype)\n         *     result = Reflect.deleteMetadata(\"custom:annotation\", Example.prototype, \"method\");\n         *\n         */\n        function deleteMetadata(metadataKey, target, propertyKey) {\n            if (!IsObject(target))\n                throw new TypeError();\n            if (!IsUndefined(propertyKey))\n                propertyKey = ToPropertyKey(propertyKey);\n            var metadataMap = GetOrCreateMetadataMap(target, propertyKey, /*Create*/ false);\n            if (IsUndefined(metadataMap))\n                return false;\n            if (!metadataMap.delete(metadataKey))\n                return false;\n            if (metadataMap.size > 0)\n                return true;\n            var targetMetadata = Metadata.get(target);\n            targetMetadata.delete(propertyKey);\n            if (targetMetadata.size > 0)\n                return true;\n            Metadata.delete(target);\n            return true;\n        }\n        exporter(\"deleteMetadata\", deleteMetadata);\n        function DecorateConstructor(decorators, target) {\n            for (var i = decorators.length - 1; i >= 0; --i) {\n                var decorator = decorators[i];\n                var decorated = decorator(target);\n                if (!IsUndefined(decorated) && !IsNull(decorated)) {\n                    if (!IsConstructor(decorated))\n                        throw new TypeError();\n                    target = decorated;\n                }\n            }\n            return target;\n        }\n        function DecorateProperty(decorators, target, propertyKey, descriptor) {\n            for (var i = decorators.length - 1; i >= 0; --i) {\n                var decorator = decorators[i];\n                var decorated = decorator(target, propertyKey, descriptor);\n                if (!IsUndefined(decorated) && !IsNull(decorated)) {\n                    if (!IsObject(decorated))\n                        throw new TypeError();\n                    descriptor = decorated;\n                }\n            }\n            return descriptor;\n        }\n        function GetOrCreateMetadataMap(O, P, Create) {\n            var targetMetadata = Metadata.get(O);\n            if (IsUndefined(targetMetadata)) {\n                if (!Create)\n                    return undefined;\n                targetMetadata = new _Map();\n                Metadata.set(O, targetMetadata);\n            }\n            var metadataMap = targetMetadata.get(P);\n            if (IsUndefined(metadataMap)) {\n                if (!Create)\n                    return undefined;\n                metadataMap = new _Map();\n                targetMetadata.set(P, metadataMap);\n            }\n            return metadataMap;\n        }\n        // 3.1.1.1 OrdinaryHasMetadata(MetadataKey, O, P)\n        // https://rbuckton.github.io/reflect-metadata/#ordinaryhasmetadata\n        function OrdinaryHasMetadata(MetadataKey, O, P) {\n            var hasOwn = OrdinaryHasOwnMetadata(MetadataKey, O, P);\n            if (hasOwn)\n                return true;\n            var parent = OrdinaryGetPrototypeOf(O);\n            if (!IsNull(parent))\n                return OrdinaryHasMetadata(MetadataKey, parent, P);\n            return false;\n        }\n        // 3.1.2.1 OrdinaryHasOwnMetadata(MetadataKey, O, P)\n        // https://rbuckton.github.io/reflect-metadata/#ordinaryhasownmetadata\n        function OrdinaryHasOwnMetadata(MetadataKey, O, P) {\n            var metadataMap = GetOrCreateMetadataMap(O, P, /*Create*/ false);\n            if (IsUndefined(metadataMap))\n                return false;\n            return ToBoolean(metadataMap.has(MetadataKey));\n        }\n        // 3.1.3.1 OrdinaryGetMetadata(MetadataKey, O, P)\n        // https://rbuckton.github.io/reflect-metadata/#ordinarygetmetadata\n        function OrdinaryGetMetadata(MetadataKey, O, P) {\n            var hasOwn = OrdinaryHasOwnMetadata(MetadataKey, O, P);\n            if (hasOwn)\n                return OrdinaryGetOwnMetadata(MetadataKey, O, P);\n            var parent = OrdinaryGetPrototypeOf(O);\n            if (!IsNull(parent))\n                return OrdinaryGetMetadata(MetadataKey, parent, P);\n            return undefined;\n        }\n        // 3.1.4.1 OrdinaryGetOwnMetadata(MetadataKey, O, P)\n        // https://rbuckton.github.io/reflect-metadata/#ordinarygetownmetadata\n        function OrdinaryGetOwnMetadata(MetadataKey, O, P) {\n            var metadataMap = GetOrCreateMetadataMap(O, P, /*Create*/ false);\n            if (IsUndefined(metadataMap))\n                return undefined;\n            return metadataMap.get(MetadataKey);\n        }\n        // 3.1.5.1 OrdinaryDefineOwnMetadata(MetadataKey, MetadataValue, O, P)\n        // https://rbuckton.github.io/reflect-metadata/#ordinarydefineownmetadata\n        function OrdinaryDefineOwnMetadata(MetadataKey, MetadataValue, O, P) {\n            var metadataMap = GetOrCreateMetadataMap(O, P, /*Create*/ true);\n            metadataMap.set(MetadataKey, MetadataValue);\n        }\n        // 3.1.6.1 OrdinaryMetadataKeys(O, P)\n        // https://rbuckton.github.io/reflect-metadata/#ordinarymetadatakeys\n        function OrdinaryMetadataKeys(O, P) {\n            var ownKeys = OrdinaryOwnMetadataKeys(O, P);\n            var parent = OrdinaryGetPrototypeOf(O);\n            if (parent === null)\n                return ownKeys;\n            var parentKeys = OrdinaryMetadataKeys(parent, P);\n            if (parentKeys.length <= 0)\n                return ownKeys;\n            if (ownKeys.length <= 0)\n                return parentKeys;\n            var set = new _Set();\n            var keys = [];\n            for (var _i = 0, ownKeys_1 = ownKeys; _i < ownKeys_1.length; _i++) {\n                var key = ownKeys_1[_i];\n                var hasKey = set.has(key);\n                if (!hasKey) {\n                    set.add(key);\n                    keys.push(key);\n                }\n            }\n            for (var _a = 0, parentKeys_1 = parentKeys; _a < parentKeys_1.length; _a++) {\n                var key = parentKeys_1[_a];\n                var hasKey = set.has(key);\n                if (!hasKey) {\n                    set.add(key);\n                    keys.push(key);\n                }\n            }\n            return keys;\n        }\n        // 3.1.7.1 OrdinaryOwnMetadataKeys(O, P)\n        // https://rbuckton.github.io/reflect-metadata/#ordinaryownmetadatakeys\n        function OrdinaryOwnMetadataKeys(O, P) {\n            var keys = [];\n            var metadataMap = GetOrCreateMetadataMap(O, P, /*Create*/ false);\n            if (IsUndefined(metadataMap))\n                return keys;\n            var keysObj = metadataMap.keys();\n            var iterator = GetIterator(keysObj);\n            var k = 0;\n            while (true) {\n                var next = IteratorStep(iterator);\n                if (!next) {\n                    keys.length = k;\n                    return keys;\n                }\n                var nextValue = IteratorValue(next);\n                try {\n                    keys[k] = nextValue;\n                }\n                catch (e) {\n                    try {\n                        IteratorClose(iterator);\n                    }\n                    finally {\n                        throw e;\n                    }\n                }\n                k++;\n            }\n        }\n        // 6 ECMAScript Data Typ0es and Values\n        // https://tc39.github.io/ecma262/#sec-ecmascript-data-types-and-values\n        function Type(x) {\n            if (x === null)\n                return 1 /* Null */;\n            switch (typeof x) {\n                case \"undefined\": return 0 /* Undefined */;\n                case \"boolean\": return 2 /* Boolean */;\n                case \"string\": return 3 /* String */;\n                case \"symbol\": return 4 /* Symbol */;\n                case \"number\": return 5 /* Number */;\n                case \"object\": return x === null ? 1 /* Null */ : 6 /* Object */;\n                default: return 6 /* Object */;\n            }\n        }\n        // 6.1.1 The Undefined Type\n        // https://tc39.github.io/ecma262/#sec-ecmascript-language-types-undefined-type\n        function IsUndefined(x) {\n            return x === undefined;\n        }\n        // 6.1.2 The Null Type\n        // https://tc39.github.io/ecma262/#sec-ecmascript-language-types-null-type\n        function IsNull(x) {\n            return x === null;\n        }\n        // 6.1.5 The Symbol Type\n        // https://tc39.github.io/ecma262/#sec-ecmascript-language-types-symbol-type\n        function IsSymbol(x) {\n            return typeof x === \"symbol\";\n        }\n        // 6.1.7 The Object Type\n        // https://tc39.github.io/ecma262/#sec-object-type\n        function IsObject(x) {\n            return typeof x === \"object\" ? x !== null : typeof x === \"function\";\n        }\n        // 7.1 Type Conversion\n        // https://tc39.github.io/ecma262/#sec-type-conversion\n        // 7.1.1 ToPrimitive(input [, PreferredType])\n        // https://tc39.github.io/ecma262/#sec-toprimitive\n        function ToPrimitive(input, PreferredType) {\n            switch (Type(input)) {\n                case 0 /* Undefined */: return input;\n                case 1 /* Null */: return input;\n                case 2 /* Boolean */: return input;\n                case 3 /* String */: return input;\n                case 4 /* Symbol */: return input;\n                case 5 /* Number */: return input;\n            }\n            var hint = PreferredType === 3 /* String */ ? \"string\" : PreferredType === 5 /* Number */ ? \"number\" : \"default\";\n            var exoticToPrim = GetMethod(input, toPrimitiveSymbol);\n            if (exoticToPrim !== undefined) {\n                var result = exoticToPrim.call(input, hint);\n                if (IsObject(result))\n                    throw new TypeError();\n                return result;\n            }\n            return OrdinaryToPrimitive(input, hint === \"default\" ? \"number\" : hint);\n        }\n        // 7.1.1.1 OrdinaryToPrimitive(O, hint)\n        // https://tc39.github.io/ecma262/#sec-ordinarytoprimitive\n        function OrdinaryToPrimitive(O, hint) {\n            if (hint === \"string\") {\n                var toString_1 = O.toString;\n                if (IsCallable(toString_1)) {\n                    var result = toString_1.call(O);\n                    if (!IsObject(result))\n                        return result;\n                }\n                var valueOf = O.valueOf;\n                if (IsCallable(valueOf)) {\n                    var result = valueOf.call(O);\n                    if (!IsObject(result))\n                        return result;\n                }\n            }\n            else {\n                var valueOf = O.valueOf;\n                if (IsCallable(valueOf)) {\n                    var result = valueOf.call(O);\n                    if (!IsObject(result))\n                        return result;\n                }\n                var toString_2 = O.toString;\n                if (IsCallable(toString_2)) {\n                    var result = toString_2.call(O);\n                    if (!IsObject(result))\n                        return result;\n                }\n            }\n            throw new TypeError();\n        }\n        // 7.1.2 ToBoolean(argument)\n        // https://tc39.github.io/ecma262/2016/#sec-toboolean\n        function ToBoolean(argument) {\n            return !!argument;\n        }\n        // 7.1.12 ToString(argument)\n        // https://tc39.github.io/ecma262/#sec-tostring\n        function ToString(argument) {\n            return \"\" + argument;\n        }\n        // 7.1.14 ToPropertyKey(argument)\n        // https://tc39.github.io/ecma262/#sec-topropertykey\n        function ToPropertyKey(argument) {\n            var key = ToPrimitive(argument, 3 /* String */);\n            if (IsSymbol(key))\n                return key;\n            return ToString(key);\n        }\n        // 7.2 Testing and Comparison Operations\n        // https://tc39.github.io/ecma262/#sec-testing-and-comparison-operations\n        // 7.2.2 IsArray(argument)\n        // https://tc39.github.io/ecma262/#sec-isarray\n        function IsArray(argument) {\n            return Array.isArray\n                ? Array.isArray(argument)\n                : argument instanceof Object\n                    ? argument instanceof Array\n                    : Object.prototype.toString.call(argument) === \"[object Array]\";\n        }\n        // 7.2.3 IsCallable(argument)\n        // https://tc39.github.io/ecma262/#sec-iscallable\n        function IsCallable(argument) {\n            // NOTE: This is an approximation as we cannot check for [[Call]] internal method.\n            return typeof argument === \"function\";\n        }\n        // 7.2.4 IsConstructor(argument)\n        // https://tc39.github.io/ecma262/#sec-isconstructor\n        function IsConstructor(argument) {\n            // NOTE: This is an approximation as we cannot check for [[Construct]] internal method.\n            return typeof argument === \"function\";\n        }\n        // 7.2.7 IsPropertyKey(argument)\n        // https://tc39.github.io/ecma262/#sec-ispropertykey\n        function IsPropertyKey(argument) {\n            switch (Type(argument)) {\n                case 3 /* String */: return true;\n                case 4 /* Symbol */: return true;\n                default: return false;\n            }\n        }\n        // 7.3 Operations on Objects\n        // https://tc39.github.io/ecma262/#sec-operations-on-objects\n        // 7.3.9 GetMethod(V, P)\n        // https://tc39.github.io/ecma262/#sec-getmethod\n        function GetMethod(V, P) {\n            var func = V[P];\n            if (func === undefined || func === null)\n                return undefined;\n            if (!IsCallable(func))\n                throw new TypeError();\n            return func;\n        }\n        // 7.4 Operations on Iterator Objects\n        // https://tc39.github.io/ecma262/#sec-operations-on-iterator-objects\n        function GetIterator(obj) {\n            var method = GetMethod(obj, iteratorSymbol);\n            if (!IsCallable(method))\n                throw new TypeError(); // from Call\n            var iterator = method.call(obj);\n            if (!IsObject(iterator))\n                throw new TypeError();\n            return iterator;\n        }\n        // 7.4.4 IteratorValue(iterResult)\n        // https://tc39.github.io/ecma262/2016/#sec-iteratorvalue\n        function IteratorValue(iterResult) {\n            return iterResult.value;\n        }\n        // 7.4.5 IteratorStep(iterator)\n        // https://tc39.github.io/ecma262/#sec-iteratorstep\n        function IteratorStep(iterator) {\n            var result = iterator.next();\n            return result.done ? false : result;\n        }\n        // 7.4.6 IteratorClose(iterator, completion)\n        // https://tc39.github.io/ecma262/#sec-iteratorclose\n        function IteratorClose(iterator) {\n            var f = iterator[\"return\"];\n            if (f)\n                f.call(iterator);\n        }\n        // 9.1 Ordinary Object Internal Methods and Internal Slots\n        // https://tc39.github.io/ecma262/#sec-ordinary-object-internal-methods-and-internal-slots\n        // 9.1.1.1 OrdinaryGetPrototypeOf(O)\n        // https://tc39.github.io/ecma262/#sec-ordinarygetprototypeof\n        function OrdinaryGetPrototypeOf(O) {\n            var proto = Object.getPrototypeOf(O);\n            if (typeof O !== \"function\" || O === functionPrototype)\n                return proto;\n            // TypeScript doesn't set __proto__ in ES5, as it's non-standard.\n            // Try to determine the superclass constructor. Compatible implementations\n            // must either set __proto__ on a subclass constructor to the superclass constructor,\n            // or ensure each class has a valid `constructor` property on its prototype that\n            // points back to the constructor.\n            // If this is not the same as Function.[[Prototype]], then this is definately inherited.\n            // This is the case when in ES6 or when using __proto__ in a compatible browser.\n            if (proto !== functionPrototype)\n                return proto;\n            // If the super prototype is Object.prototype, null, or undefined, then we cannot determine the heritage.\n            var prototype = O.prototype;\n            var prototypeProto = prototype && Object.getPrototypeOf(prototype);\n            if (prototypeProto == null || prototypeProto === Object.prototype)\n                return proto;\n            // If the constructor was not a function, then we cannot determine the heritage.\n            var constructor = prototypeProto.constructor;\n            if (typeof constructor !== \"function\")\n                return proto;\n            // If we have some kind of self-reference, then we cannot determine the heritage.\n            if (constructor === O)\n                return proto;\n            // we have a pretty good guess at the heritage.\n            return constructor;\n        }\n        // naive Map shim\n        function CreateMapPolyfill() {\n            var cacheSentinel = {};\n            var arraySentinel = [];\n            var MapIterator = /** @class */ (function () {\n                function MapIterator(keys, values, selector) {\n                    this._index = 0;\n                    this._keys = keys;\n                    this._values = values;\n                    this._selector = selector;\n                }\n                MapIterator.prototype[\"@@iterator\"] = function () { return this; };\n                MapIterator.prototype[iteratorSymbol] = function () { return this; };\n                MapIterator.prototype.next = function () {\n                    var index = this._index;\n                    if (index >= 0 && index < this._keys.length) {\n                        var result = this._selector(this._keys[index], this._values[index]);\n                        if (index + 1 >= this._keys.length) {\n                            this._index = -1;\n                            this._keys = arraySentinel;\n                            this._values = arraySentinel;\n                        }\n                        else {\n                            this._index++;\n                        }\n                        return { value: result, done: false };\n                    }\n                    return { value: undefined, done: true };\n                };\n                MapIterator.prototype.throw = function (error) {\n                    if (this._index >= 0) {\n                        this._index = -1;\n                        this._keys = arraySentinel;\n                        this._values = arraySentinel;\n                    }\n                    throw error;\n                };\n                MapIterator.prototype.return = function (value) {\n                    if (this._index >= 0) {\n                        this._index = -1;\n                        this._keys = arraySentinel;\n                        this._values = arraySentinel;\n                    }\n                    return { value: value, done: true };\n                };\n                return MapIterator;\n            }());\n            return /** @class */ (function () {\n                function Map() {\n                    this._keys = [];\n                    this._values = [];\n                    this._cacheKey = cacheSentinel;\n                    this._cacheIndex = -2;\n                }\n                Object.defineProperty(Map.prototype, \"size\", {\n                    get: function () { return this._keys.length; },\n                    enumerable: true,\n                    configurable: true\n                });\n                Map.prototype.has = function (key) { return this._find(key, /*insert*/ false) >= 0; };\n                Map.prototype.get = function (key) {\n                    var index = this._find(key, /*insert*/ false);\n                    return index >= 0 ? this._values[index] : undefined;\n                };\n                Map.prototype.set = function (key, value) {\n                    var index = this._find(key, /*insert*/ true);\n                    this._values[index] = value;\n                    return this;\n                };\n                Map.prototype.delete = function (key) {\n                    var index = this._find(key, /*insert*/ false);\n                    if (index >= 0) {\n                        var size = this._keys.length;\n                        for (var i = index + 1; i < size; i++) {\n                            this._keys[i - 1] = this._keys[i];\n                            this._values[i - 1] = this._values[i];\n                        }\n                        this._keys.length--;\n                        this._values.length--;\n                        if (key === this._cacheKey) {\n                            this._cacheKey = cacheSentinel;\n                            this._cacheIndex = -2;\n                        }\n                        return true;\n                    }\n                    return false;\n                };\n                Map.prototype.clear = function () {\n                    this._keys.length = 0;\n                    this._values.length = 0;\n                    this._cacheKey = cacheSentinel;\n                    this._cacheIndex = -2;\n                };\n                Map.prototype.keys = function () { return new MapIterator(this._keys, this._values, getKey); };\n                Map.prototype.values = function () { return new MapIterator(this._keys, this._values, getValue); };\n                Map.prototype.entries = function () { return new MapIterator(this._keys, this._values, getEntry); };\n                Map.prototype[\"@@iterator\"] = function () { return this.entries(); };\n                Map.prototype[iteratorSymbol] = function () { return this.entries(); };\n                Map.prototype._find = function (key, insert) {\n                    if (this._cacheKey !== key) {\n                        this._cacheIndex = this._keys.indexOf(this._cacheKey = key);\n                    }\n                    if (this._cacheIndex < 0 && insert) {\n                        this._cacheIndex = this._keys.length;\n                        this._keys.push(key);\n                        this._values.push(undefined);\n                    }\n                    return this._cacheIndex;\n                };\n                return Map;\n            }());\n            function getKey(key, _) {\n                return key;\n            }\n            function getValue(_, value) {\n                return value;\n            }\n            function getEntry(key, value) {\n                return [key, value];\n            }\n        }\n        // naive Set shim\n        function CreateSetPolyfill() {\n            return /** @class */ (function () {\n                function Set() {\n                    this._map = new _Map();\n                }\n                Object.defineProperty(Set.prototype, \"size\", {\n                    get: function () { return this._map.size; },\n                    enumerable: true,\n                    configurable: true\n                });\n                Set.prototype.has = function (value) { return this._map.has(value); };\n                Set.prototype.add = function (value) { return this._map.set(value, value), this; };\n                Set.prototype.delete = function (value) { return this._map.delete(value); };\n                Set.prototype.clear = function () { this._map.clear(); };\n                Set.prototype.keys = function () { return this._map.keys(); };\n                Set.prototype.values = function () { return this._map.values(); };\n                Set.prototype.entries = function () { return this._map.entries(); };\n                Set.prototype[\"@@iterator\"] = function () { return this.keys(); };\n                Set.prototype[iteratorSymbol] = function () { return this.keys(); };\n                return Set;\n            }());\n        }\n        // naive WeakMap shim\n        function CreateWeakMapPolyfill() {\n            var UUID_SIZE = 16;\n            var keys = HashMap.create();\n            var rootKey = CreateUniqueKey();\n            return /** @class */ (function () {\n                function WeakMap() {\n                    this._key = CreateUniqueKey();\n                }\n                WeakMap.prototype.has = function (target) {\n                    var table = GetOrCreateWeakMapTable(target, /*create*/ false);\n                    return table !== undefined ? HashMap.has(table, this._key) : false;\n                };\n                WeakMap.prototype.get = function (target) {\n                    var table = GetOrCreateWeakMapTable(target, /*create*/ false);\n                    return table !== undefined ? HashMap.get(table, this._key) : undefined;\n                };\n                WeakMap.prototype.set = function (target, value) {\n                    var table = GetOrCreateWeakMapTable(target, /*create*/ true);\n                    table[this._key] = value;\n                    return this;\n                };\n                WeakMap.prototype.delete = function (target) {\n                    var table = GetOrCreateWeakMapTable(target, /*create*/ false);\n                    return table !== undefined ? delete table[this._key] : false;\n                };\n                WeakMap.prototype.clear = function () {\n                    // NOTE: not a real clear, just makes the previous data unreachable\n                    this._key = CreateUniqueKey();\n                };\n                return WeakMap;\n            }());\n            function CreateUniqueKey() {\n                var key;\n                do\n                    key = \"@@WeakMap@@\" + CreateUUID();\n                while (HashMap.has(keys, key));\n                keys[key] = true;\n                return key;\n            }\n            function GetOrCreateWeakMapTable(target, create) {\n                if (!hasOwn.call(target, rootKey)) {\n                    if (!create)\n                        return undefined;\n                    Object.defineProperty(target, rootKey, { value: HashMap.create() });\n                }\n                return target[rootKey];\n            }\n            function FillRandomBytes(buffer, size) {\n                for (var i = 0; i < size; ++i)\n                    buffer[i] = Math.random() * 0xff | 0;\n                return buffer;\n            }\n            function GenRandomBytes(size) {\n                if (typeof Uint8Array === \"function\") {\n                    if (typeof crypto !== \"undefined\")\n                        return crypto.getRandomValues(new Uint8Array(size));\n                    if (typeof msCrypto !== \"undefined\")\n                        return msCrypto.getRandomValues(new Uint8Array(size));\n                    return FillRandomBytes(new Uint8Array(size), size);\n                }\n                return FillRandomBytes(new Array(size), size);\n            }\n            function CreateUUID() {\n                var data = GenRandomBytes(UUID_SIZE);\n                // mark as random - RFC 4122 § 4.4\n                data[6] = data[6] & 0x4f | 0x40;\n                data[8] = data[8] & 0xbf | 0x80;\n                var result = \"\";\n                for (var offset = 0; offset < UUID_SIZE; ++offset) {\n                    var byte = data[offset];\n                    if (offset === 4 || offset === 6 || offset === 8)\n                        result += \"-\";\n                    if (byte < 16)\n                        result += \"0\";\n                    result += byte.toString(16).toLowerCase();\n                }\n                return result;\n            }\n        }\n        // uses a heuristic used by v8 and chakra to force an object into dictionary mode.\n        function MakeDictionary(obj) {\n            obj.__ = undefined;\n            delete obj.__;\n            return obj;\n        }\n    });\n})(Reflect || (Reflect = {}));\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.serialize = exports.deserialize = exports.registerSerializer = void 0;\nconst serializers_1 = require(\"./serializers\");\nlet registeredSerializer = serializers_1.DefaultSerializer;\nfunction registerSerializer(serializer) {\n    registeredSerializer = serializers_1.extendSerializer(registeredSerializer, serializer);\n}\nexports.registerSerializer = registerSerializer;\nfunction deserialize(message) {\n    return registeredSerializer.deserialize(message);\n}\nexports.deserialize = deserialize;\nfunction serialize(input) {\n    return registeredSerializer.serialize(input);\n}\nexports.serialize = serialize;\n","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Transfer = exports.DefaultSerializer = exports.expose = exports.registerSerializer = void 0;\nvar common_1 = require(\"./common\");\nObject.defineProperty(exports, \"registerSerializer\", { enumerable: true, get: function () { return common_1.registerSerializer; } });\n__exportStar(require(\"./master/index\"), exports);\nvar index_1 = require(\"./worker/index\");\nObject.defineProperty(exports, \"expose\", { enumerable: true, get: function () { return index_1.expose; } });\nvar serializers_1 = require(\"./serializers\");\nObject.defineProperty(exports, \"DefaultSerializer\", { enumerable: true, get: function () { return serializers_1.DefaultSerializer; } });\nvar transferable_1 = require(\"./transferable\");\nObject.defineProperty(exports, \"Transfer\", { enumerable: true, get: function () { return transferable_1.Transfer; } });\n","\"use strict\";\n// Source: <https://github.com/parcel-bundler/parcel/blob/master/packages/core/parcel-bundler/src/builtins/bundle-url.js>\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getBundleURL = exports.getBaseURL = void 0;\nlet bundleURL;\nfunction getBundleURLCached() {\n    if (!bundleURL) {\n        bundleURL = getBundleURL();\n    }\n    return bundleURL;\n}\nexports.getBundleURL = getBundleURLCached;\nfunction getBundleURL() {\n    // Attempt to find the URL of the current script and use that as the base URL\n    try {\n        throw new Error;\n    }\n    catch (err) {\n        const matches = (\"\" + err.stack).match(/(https?|file|ftp|chrome-extension|moz-extension):\\/\\/[^)\\n]+/g);\n        if (matches) {\n            return getBaseURL(matches[0]);\n        }\n    }\n    return \"/\";\n}\nfunction getBaseURL(url) {\n    return (\"\" + url).replace(/^((?:https?|file|ftp|chrome-extension|moz-extension):\\/\\/.+)?\\/[^/]+(?:\\?.*)?$/, '$1') + '/';\n}\nexports.getBaseURL = getBaseURL;\n","\"use strict\";\n// tslint:disable max-classes-per-file\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.isWorkerRuntime = exports.getWorkerImplementation = exports.defaultPoolSize = void 0;\nconst get_bundle_url_browser_1 = require(\"./get-bundle-url.browser\");\nexports.defaultPoolSize = typeof navigator !== \"undefined\" && navigator.hardwareConcurrency\n    ? navigator.hardwareConcurrency\n    : 4;\nconst isAbsoluteURL = (value) => /^[a-zA-Z][a-zA-Z\\d+\\-.]*:/.test(value);\nfunction createSourceBlobURL(code) {\n    const blob = new Blob([code], { type: \"application/javascript\" });\n    return URL.createObjectURL(blob);\n}\nfunction selectWorkerImplementation() {\n    if (typeof Worker === \"undefined\") {\n        // Might happen on Safari, for instance\n        // The idea is to only fail if the constructor is actually used\n        return class NoWebWorker {\n            constructor() {\n                throw Error(\"No web worker implementation available. You might have tried to spawn a worker within a worker in a browser that doesn't support workers in workers.\");\n            }\n        };\n    }\n    class WebWorker extends Worker {\n        constructor(url, options) {\n            var _a, _b;\n            if (typeof url === \"string\" && options && options._baseURL) {\n                url = new URL(url, options._baseURL);\n            }\n            else if (typeof url === \"string\" && !isAbsoluteURL(url) && get_bundle_url_browser_1.getBundleURL().match(/^file:\\/\\//i)) {\n                url = new URL(url, get_bundle_url_browser_1.getBundleURL().replace(/\\/[^\\/]+$/, \"/\"));\n                if ((_a = options === null || options === void 0 ? void 0 : options.CORSWorkaround) !== null && _a !== void 0 ? _a : true) {\n                    url = createSourceBlobURL(`importScripts(${JSON.stringify(url)});`);\n                }\n            }\n            if (typeof url === \"string\" && isAbsoluteURL(url)) {\n                // Create source code blob loading JS file via `importScripts()`\n                // to circumvent worker CORS restrictions\n                if ((_b = options === null || options === void 0 ? void 0 : options.CORSWorkaround) !== null && _b !== void 0 ? _b : true) {\n                    url = createSourceBlobURL(`importScripts(${JSON.stringify(url)});`);\n                }\n            }\n            super(url, options);\n        }\n    }\n    class BlobWorker extends WebWorker {\n        constructor(blob, options) {\n            const url = window.URL.createObjectURL(blob);\n            super(url, options);\n        }\n        static fromText(source, options) {\n            const blob = new window.Blob([source], { type: \"text/javascript\" });\n            return new BlobWorker(blob, options);\n        }\n    }\n    return {\n        blob: BlobWorker,\n        default: WebWorker\n    };\n}\nlet implementation;\nfunction getWorkerImplementation() {\n    if (!implementation) {\n        implementation = selectWorkerImplementation();\n    }\n    return implementation;\n}\nexports.getWorkerImplementation = getWorkerImplementation;\nfunction isWorkerRuntime() {\n    const isWindowContext = typeof self !== \"undefined\" && typeof Window !== \"undefined\" && self instanceof Window;\n    return typeof self !== \"undefined\" && self.postMessage && !isWindowContext ? true : false;\n}\nexports.isWorkerRuntime = isWorkerRuntime;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Worker = exports.BlobWorker = exports.isWorkerRuntime = exports.Thread = exports.spawn = exports.Pool = void 0;\nconst implementation_1 = require(\"./implementation\");\nObject.defineProperty(exports, \"isWorkerRuntime\", { enumerable: true, get: function () { return implementation_1.isWorkerRuntime; } });\nvar pool_1 = require(\"./pool\");\nObject.defineProperty(exports, \"Pool\", { enumerable: true, get: function () { return pool_1.Pool; } });\nvar spawn_1 = require(\"./spawn\");\nObject.defineProperty(exports, \"spawn\", { enumerable: true, get: function () { return spawn_1.spawn; } });\nvar thread_1 = require(\"./thread\");\nObject.defineProperty(exports, \"Thread\", { enumerable: true, get: function () { return thread_1.Thread; } });\n/** Separate class to spawn workers from source code blobs or strings. */\nexports.BlobWorker = implementation_1.getWorkerImplementation().blob;\n/** Worker implementation. Either web worker or a node.js Worker class. */\nexports.Worker = implementation_1.getWorkerImplementation().default;\n","\"use strict\";\n/*\n * This source file contains the code for proxying calls in the master thread to calls in the workers\n * by `.postMessage()`-ing.\n *\n * Keep in mind that this code can make or break the program's performance! Need to optimize more…\n */\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.createProxyModule = exports.createProxyFunction = void 0;\nconst debug_1 = __importDefault(require(\"debug\"));\nconst observable_fns_1 = require(\"observable-fns\");\nconst common_1 = require(\"../common\");\nconst observable_promise_1 = require(\"../observable-promise\");\nconst transferable_1 = require(\"../transferable\");\nconst messages_1 = require(\"../types/messages\");\nconst debugMessages = debug_1.default(\"threads:master:messages\");\nlet nextJobUID = 1;\nconst dedupe = (array) => Array.from(new Set(array));\nconst isJobErrorMessage = (data) => data && data.type === messages_1.WorkerMessageType.error;\nconst isJobResultMessage = (data) => data && data.type === messages_1.WorkerMessageType.result;\nconst isJobStartMessage = (data) => data && data.type === messages_1.WorkerMessageType.running;\nfunction createObservableForJob(worker, jobUID) {\n    return new observable_fns_1.Observable(observer => {\n        let asyncType;\n        const messageHandler = ((event) => {\n            debugMessages(\"Message from worker:\", event.data);\n            if (!event.data || event.data.uid !== jobUID)\n                return;\n            if (isJobStartMessage(event.data)) {\n                asyncType = event.data.resultType;\n            }\n            else if (isJobResultMessage(event.data)) {\n                if (asyncType === \"promise\") {\n                    if (typeof event.data.payload !== \"undefined\") {\n                        observer.next(common_1.deserialize(event.data.payload));\n                    }\n                    observer.complete();\n                    worker.removeEventListener(\"message\", messageHandler);\n                }\n                else {\n                    if (event.data.payload) {\n                        observer.next(common_1.deserialize(event.data.payload));\n                    }\n                    if (event.data.complete) {\n                        observer.complete();\n                        worker.removeEventListener(\"message\", messageHandler);\n                    }\n                }\n            }\n            else if (isJobErrorMessage(event.data)) {\n                const error = common_1.deserialize(event.data.error);\n                if (asyncType === \"promise\" || !asyncType) {\n                    observer.error(error);\n                }\n                else {\n                    observer.error(error);\n                }\n                worker.removeEventListener(\"message\", messageHandler);\n            }\n        });\n        worker.addEventListener(\"message\", messageHandler);\n        return () => {\n            if (asyncType === \"observable\" || !asyncType) {\n                const cancelMessage = {\n                    type: messages_1.MasterMessageType.cancel,\n                    uid: jobUID\n                };\n                worker.postMessage(cancelMessage);\n            }\n            worker.removeEventListener(\"message\", messageHandler);\n        };\n    });\n}\nfunction prepareArguments(rawArgs) {\n    if (rawArgs.length === 0) {\n        // Exit early if possible\n        return {\n            args: [],\n            transferables: []\n        };\n    }\n    const args = [];\n    const transferables = [];\n    for (const arg of rawArgs) {\n        if (transferable_1.isTransferDescriptor(arg)) {\n            args.push(common_1.serialize(arg.send));\n            transferables.push(...arg.transferables);\n        }\n        else {\n            args.push(common_1.serialize(arg));\n        }\n    }\n    return {\n        args,\n        transferables: transferables.length === 0 ? transferables : dedupe(transferables)\n    };\n}\nfunction createProxyFunction(worker, method) {\n    return ((...rawArgs) => {\n        const uid = nextJobUID++;\n        const { args, transferables } = prepareArguments(rawArgs);\n        const runMessage = {\n            type: messages_1.MasterMessageType.run,\n            uid,\n            method,\n            args\n        };\n        debugMessages(\"Sending command to run function to worker:\", runMessage);\n        try {\n            worker.postMessage(runMessage, transferables);\n        }\n        catch (error) {\n            return observable_promise_1.ObservablePromise.from(Promise.reject(error));\n        }\n        return observable_promise_1.ObservablePromise.from(observable_fns_1.multicast(createObservableForJob(worker, uid)));\n    });\n}\nexports.createProxyFunction = createProxyFunction;\nfunction createProxyModule(worker, methodNames) {\n    const proxy = {};\n    for (const methodName of methodNames) {\n        proxy[methodName] = createProxyFunction(worker, methodName);\n    }\n    return proxy;\n}\nexports.createProxyModule = createProxyModule;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.PoolEventType = void 0;\n/** Pool event type. Specifies the type of each `PoolEvent`. */\nvar PoolEventType;\n(function (PoolEventType) {\n    PoolEventType[\"initialized\"] = \"initialized\";\n    PoolEventType[\"taskCanceled\"] = \"taskCanceled\";\n    PoolEventType[\"taskCompleted\"] = \"taskCompleted\";\n    PoolEventType[\"taskFailed\"] = \"taskFailed\";\n    PoolEventType[\"taskQueued\"] = \"taskQueued\";\n    PoolEventType[\"taskQueueDrained\"] = \"taskQueueDrained\";\n    PoolEventType[\"taskStart\"] = \"taskStart\";\n    PoolEventType[\"terminated\"] = \"terminated\";\n})(PoolEventType = exports.PoolEventType || (exports.PoolEventType = {}));\n","\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Pool = exports.Thread = exports.PoolEventType = void 0;\nconst debug_1 = __importDefault(require(\"debug\"));\nconst observable_fns_1 = require(\"observable-fns\");\nconst ponyfills_1 = require(\"../ponyfills\");\nconst implementation_1 = require(\"./implementation\");\nconst pool_types_1 = require(\"./pool-types\");\nObject.defineProperty(exports, \"PoolEventType\", { enumerable: true, get: function () { return pool_types_1.PoolEventType; } });\nconst thread_1 = require(\"./thread\");\nObject.defineProperty(exports, \"Thread\", { enumerable: true, get: function () { return thread_1.Thread; } });\nlet nextPoolID = 1;\nfunction createArray(size) {\n    const array = [];\n    for (let index = 0; index < size; index++) {\n        array.push(index);\n    }\n    return array;\n}\nfunction delay(ms) {\n    return new Promise(resolve => setTimeout(resolve, ms));\n}\nfunction flatMap(array, mapper) {\n    return array.reduce((flattened, element) => [...flattened, ...mapper(element)], []);\n}\nfunction slugify(text) {\n    return text.replace(/\\W/g, \" \").trim().replace(/\\s+/g, \"-\");\n}\nfunction spawnWorkers(spawnWorker, count) {\n    return createArray(count).map(() => ({\n        init: spawnWorker(),\n        runningTasks: []\n    }));\n}\nclass WorkerPool {\n    constructor(spawnWorker, optionsOrSize) {\n        this.eventSubject = new observable_fns_1.Subject();\n        this.initErrors = [];\n        this.isClosing = false;\n        this.nextTaskID = 1;\n        this.taskQueue = [];\n        const options = typeof optionsOrSize === \"number\"\n            ? { size: optionsOrSize }\n            : optionsOrSize || {};\n        const { size = implementation_1.defaultPoolSize } = options;\n        this.debug = debug_1.default(`threads:pool:${slugify(options.name || String(nextPoolID++))}`);\n        this.options = options;\n        this.workers = spawnWorkers(spawnWorker, size);\n        this.eventObservable = observable_fns_1.multicast(observable_fns_1.Observable.from(this.eventSubject));\n        Promise.all(this.workers.map(worker => worker.init)).then(() => this.eventSubject.next({\n            type: pool_types_1.PoolEventType.initialized,\n            size: this.workers.length\n        }), error => {\n            this.debug(\"Error while initializing pool worker:\", error);\n            this.eventSubject.error(error);\n            this.initErrors.push(error);\n        });\n    }\n    findIdlingWorker() {\n        const { concurrency = 1 } = this.options;\n        return this.workers.find(worker => worker.runningTasks.length < concurrency);\n    }\n    runPoolTask(worker, task) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const workerID = this.workers.indexOf(worker) + 1;\n            this.debug(`Running task #${task.id} on worker #${workerID}...`);\n            this.eventSubject.next({\n                type: pool_types_1.PoolEventType.taskStart,\n                taskID: task.id,\n                workerID\n            });\n            try {\n                const returnValue = yield task.run(yield worker.init);\n                this.debug(`Task #${task.id} completed successfully`);\n                this.eventSubject.next({\n                    type: pool_types_1.PoolEventType.taskCompleted,\n                    returnValue,\n                    taskID: task.id,\n                    workerID\n                });\n            }\n            catch (error) {\n                this.debug(`Task #${task.id} failed`);\n                this.eventSubject.next({\n                    type: pool_types_1.PoolEventType.taskFailed,\n                    taskID: task.id,\n                    error,\n                    workerID\n                });\n            }\n        });\n    }\n    run(worker, task) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const runPromise = (() => __awaiter(this, void 0, void 0, function* () {\n                const removeTaskFromWorkersRunningTasks = () => {\n                    worker.runningTasks = worker.runningTasks.filter(someRunPromise => someRunPromise !== runPromise);\n                };\n                // Defer task execution by one tick to give handlers time to subscribe\n                yield delay(0);\n                try {\n                    yield this.runPoolTask(worker, task);\n                }\n                finally {\n                    removeTaskFromWorkersRunningTasks();\n                    if (!this.isClosing) {\n                        this.scheduleWork();\n                    }\n                }\n            }))();\n            worker.runningTasks.push(runPromise);\n        });\n    }\n    scheduleWork() {\n        this.debug(`Attempt de-queueing a task in order to run it...`);\n        const availableWorker = this.findIdlingWorker();\n        if (!availableWorker)\n            return;\n        const nextTask = this.taskQueue.shift();\n        if (!nextTask) {\n            this.debug(`Task queue is empty`);\n            this.eventSubject.next({ type: pool_types_1.PoolEventType.taskQueueDrained });\n            return;\n        }\n        this.run(availableWorker, nextTask);\n    }\n    taskCompletion(taskID) {\n        return new Promise((resolve, reject) => {\n            const eventSubscription = this.events().subscribe(event => {\n                if (event.type === pool_types_1.PoolEventType.taskCompleted && event.taskID === taskID) {\n                    eventSubscription.unsubscribe();\n                    resolve(event.returnValue);\n                }\n                else if (event.type === pool_types_1.PoolEventType.taskFailed && event.taskID === taskID) {\n                    eventSubscription.unsubscribe();\n                    reject(event.error);\n                }\n                else if (event.type === pool_types_1.PoolEventType.terminated) {\n                    eventSubscription.unsubscribe();\n                    reject(Error(\"Pool has been terminated before task was run.\"));\n                }\n            });\n        });\n    }\n    settled(allowResolvingImmediately = false) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const getCurrentlyRunningTasks = () => flatMap(this.workers, worker => worker.runningTasks);\n            const taskFailures = [];\n            const failureSubscription = this.eventObservable.subscribe(event => {\n                if (event.type === pool_types_1.PoolEventType.taskFailed) {\n                    taskFailures.push(event.error);\n                }\n            });\n            if (this.initErrors.length > 0) {\n                return Promise.reject(this.initErrors[0]);\n            }\n            if (allowResolvingImmediately && this.taskQueue.length === 0) {\n                yield ponyfills_1.allSettled(getCurrentlyRunningTasks());\n                return taskFailures;\n            }\n            yield new Promise((resolve, reject) => {\n                const subscription = this.eventObservable.subscribe({\n                    next(event) {\n                        if (event.type === pool_types_1.PoolEventType.taskQueueDrained) {\n                            subscription.unsubscribe();\n                            resolve(void 0);\n                        }\n                    },\n                    error: reject // make a pool-wide error reject the completed() result promise\n                });\n            });\n            yield ponyfills_1.allSettled(getCurrentlyRunningTasks());\n            failureSubscription.unsubscribe();\n            return taskFailures;\n        });\n    }\n    completed(allowResolvingImmediately = false) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const settlementPromise = this.settled(allowResolvingImmediately);\n            const earlyExitPromise = new Promise((resolve, reject) => {\n                const subscription = this.eventObservable.subscribe({\n                    next(event) {\n                        if (event.type === pool_types_1.PoolEventType.taskQueueDrained) {\n                            subscription.unsubscribe();\n                            resolve(settlementPromise);\n                        }\n                        else if (event.type === pool_types_1.PoolEventType.taskFailed) {\n                            subscription.unsubscribe();\n                            reject(event.error);\n                        }\n                    },\n                    error: reject // make a pool-wide error reject the completed() result promise\n                });\n            });\n            const errors = yield Promise.race([\n                settlementPromise,\n                earlyExitPromise\n            ]);\n            if (errors.length > 0) {\n                throw errors[0];\n            }\n        });\n    }\n    events() {\n        return this.eventObservable;\n    }\n    queue(taskFunction) {\n        const { maxQueuedJobs = Infinity } = this.options;\n        if (this.isClosing) {\n            throw Error(`Cannot schedule pool tasks after terminate() has been called.`);\n        }\n        if (this.initErrors.length > 0) {\n            throw this.initErrors[0];\n        }\n        const taskID = this.nextTaskID++;\n        const taskCompletion = this.taskCompletion(taskID);\n        taskCompletion.catch((error) => {\n            // Prevent unhandled rejections here as we assume the user will use\n            // `pool.completed()`, `pool.settled()` or `task.catch()` to handle errors\n            this.debug(`Task #${taskID} errored:`, error);\n        });\n        const task = {\n            id: taskID,\n            run: taskFunction,\n            cancel: () => {\n                if (this.taskQueue.indexOf(task) === -1)\n                    return;\n                this.taskQueue = this.taskQueue.filter(someTask => someTask !== task);\n                this.eventSubject.next({\n                    type: pool_types_1.PoolEventType.taskCanceled,\n                    taskID: task.id\n                });\n            },\n            then: taskCompletion.then.bind(taskCompletion)\n        };\n        if (this.taskQueue.length >= maxQueuedJobs) {\n            throw Error(\"Maximum number of pool tasks queued. Refusing to queue another one.\\n\" +\n                \"This usually happens for one of two reasons: We are either at peak \" +\n                \"workload right now or some tasks just won't finish, thus blocking the pool.\");\n        }\n        this.debug(`Queueing task #${task.id}...`);\n        this.taskQueue.push(task);\n        this.eventSubject.next({\n            type: pool_types_1.PoolEventType.taskQueued,\n            taskID: task.id\n        });\n        this.scheduleWork();\n        return task;\n    }\n    terminate(force) {\n        return __awaiter(this, void 0, void 0, function* () {\n            this.isClosing = true;\n            if (!force) {\n                yield this.completed(true);\n            }\n            this.eventSubject.next({\n                type: pool_types_1.PoolEventType.terminated,\n                remainingQueue: [...this.taskQueue]\n            });\n            this.eventSubject.complete();\n            yield Promise.all(this.workers.map((worker) => __awaiter(this, void 0, void 0, function* () { return thread_1.Thread.terminate(yield worker.init); })));\n        });\n    }\n}\nWorkerPool.EventType = pool_types_1.PoolEventType;\n/**\n * Thread pool constructor. Creates a new pool and spawns its worker threads.\n */\nfunction PoolConstructor(spawnWorker, optionsOrSize) {\n    // The function exists only so we don't need to use `new` to create a pool (we still can, though).\n    // If the Pool is a class or not is an implementation detail that should not concern the user.\n    return new WorkerPool(spawnWorker, optionsOrSize);\n}\nPoolConstructor.EventType = pool_types_1.PoolEventType;\n/**\n * Thread pool constructor. Creates a new pool and spawns its worker threads.\n */\nexports.Pool = PoolConstructor;\n","\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.spawn = void 0;\nconst debug_1 = __importDefault(require(\"debug\"));\nconst observable_fns_1 = require(\"observable-fns\");\nconst common_1 = require(\"../common\");\nconst promise_1 = require(\"../promise\");\nconst symbols_1 = require(\"../symbols\");\nconst master_1 = require(\"../types/master\");\nconst invocation_proxy_1 = require(\"./invocation-proxy\");\nconst debugMessages = debug_1.default(\"threads:master:messages\");\nconst debugSpawn = debug_1.default(\"threads:master:spawn\");\nconst debugThreadUtils = debug_1.default(\"threads:master:thread-utils\");\nconst isInitMessage = (data) => data && data.type === \"init\";\nconst isUncaughtErrorMessage = (data) => data && data.type === \"uncaughtError\";\nconst initMessageTimeout = typeof process !== \"undefined\" && process.env.THREADS_WORKER_INIT_TIMEOUT\n    ? Number.parseInt(process.env.THREADS_WORKER_INIT_TIMEOUT, 10)\n    : 10000;\nfunction withTimeout(promise, timeoutInMs, errorMessage) {\n    return __awaiter(this, void 0, void 0, function* () {\n        let timeoutHandle;\n        const timeout = new Promise((resolve, reject) => {\n            timeoutHandle = setTimeout(() => reject(Error(errorMessage)), timeoutInMs);\n        });\n        const result = yield Promise.race([\n            promise,\n            timeout\n        ]);\n        clearTimeout(timeoutHandle);\n        return result;\n    });\n}\nfunction receiveInitMessage(worker) {\n    return new Promise((resolve, reject) => {\n        const messageHandler = ((event) => {\n            debugMessages(\"Message from worker before finishing initialization:\", event.data);\n            if (isInitMessage(event.data)) {\n                worker.removeEventListener(\"message\", messageHandler);\n                resolve(event.data);\n            }\n            else if (isUncaughtErrorMessage(event.data)) {\n                worker.removeEventListener(\"message\", messageHandler);\n                reject(common_1.deserialize(event.data.error));\n            }\n        });\n        worker.addEventListener(\"message\", messageHandler);\n    });\n}\nfunction createEventObservable(worker, workerTermination) {\n    return new observable_fns_1.Observable(observer => {\n        const messageHandler = ((messageEvent) => {\n            const workerEvent = {\n                type: master_1.WorkerEventType.message,\n                data: messageEvent.data\n            };\n            observer.next(workerEvent);\n        });\n        const rejectionHandler = ((errorEvent) => {\n            debugThreadUtils(\"Unhandled promise rejection event in thread:\", errorEvent);\n            const workerEvent = {\n                type: master_1.WorkerEventType.internalError,\n                error: Error(errorEvent.reason)\n            };\n            observer.next(workerEvent);\n        });\n        worker.addEventListener(\"message\", messageHandler);\n        worker.addEventListener(\"unhandledrejection\", rejectionHandler);\n        workerTermination.then(() => {\n            const terminationEvent = {\n                type: master_1.WorkerEventType.termination\n            };\n            worker.removeEventListener(\"message\", messageHandler);\n            worker.removeEventListener(\"unhandledrejection\", rejectionHandler);\n            observer.next(terminationEvent);\n            observer.complete();\n        });\n    });\n}\nfunction createTerminator(worker) {\n    const [termination, resolver] = promise_1.createPromiseWithResolver();\n    const terminate = () => __awaiter(this, void 0, void 0, function* () {\n        debugThreadUtils(\"Terminating worker\");\n        // Newer versions of worker_threads workers return a promise\n        yield worker.terminate();\n        resolver();\n    });\n    return { terminate, termination };\n}\nfunction setPrivateThreadProps(raw, worker, workerEvents, terminate) {\n    const workerErrors = workerEvents\n        .filter(event => event.type === master_1.WorkerEventType.internalError)\n        .map(errorEvent => errorEvent.error);\n    // tslint:disable-next-line prefer-object-spread\n    return Object.assign(raw, {\n        [symbols_1.$errors]: workerErrors,\n        [symbols_1.$events]: workerEvents,\n        [symbols_1.$terminate]: terminate,\n        [symbols_1.$worker]: worker\n    });\n}\n/**\n * Spawn a new thread. Takes a fresh worker instance, wraps it in a thin\n * abstraction layer to provide the transparent API and verifies that\n * the worker has initialized successfully.\n *\n * @param worker Instance of `Worker`. Either a web worker, `worker_threads` worker or `tiny-worker` worker.\n * @param [options]\n * @param [options.timeout] Init message timeout. Default: 10000 or set by environment variable.\n */\nfunction spawn(worker, options) {\n    return __awaiter(this, void 0, void 0, function* () {\n        debugSpawn(\"Initializing new thread\");\n        const timeout = options && options.timeout ? options.timeout : initMessageTimeout;\n        const initMessage = yield withTimeout(receiveInitMessage(worker), timeout, `Timeout: Did not receive an init message from worker after ${timeout}ms. Make sure the worker calls expose().`);\n        const exposed = initMessage.exposed;\n        const { termination, terminate } = createTerminator(worker);\n        const events = createEventObservable(worker, termination);\n        if (exposed.type === \"function\") {\n            const proxy = invocation_proxy_1.createProxyFunction(worker);\n            return setPrivateThreadProps(proxy, worker, events, terminate);\n        }\n        else if (exposed.type === \"module\") {\n            const proxy = invocation_proxy_1.createProxyModule(worker, exposed.methods);\n            return setPrivateThreadProps(proxy, worker, events, terminate);\n        }\n        else {\n            const type = exposed.type;\n            throw Error(`Worker init message states unexpected type of expose(): ${type}`);\n        }\n    });\n}\nexports.spawn = spawn;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Thread = void 0;\nconst symbols_1 = require(\"../symbols\");\nfunction fail(message) {\n    throw Error(message);\n}\n/** Thread utility functions. Use them to manage or inspect a `spawn()`-ed thread. */\nexports.Thread = {\n    /** Return an observable that can be used to subscribe to all errors happening in the thread. */\n    errors(thread) {\n        return thread[symbols_1.$errors] || fail(\"Error observable not found. Make sure to pass a thread instance as returned by the spawn() promise.\");\n    },\n    /** Return an observable that can be used to subscribe to internal events happening in the thread. Useful for debugging. */\n    events(thread) {\n        return thread[symbols_1.$events] || fail(\"Events observable not found. Make sure to pass a thread instance as returned by the spawn() promise.\");\n    },\n    /** Terminate a thread. Remember to terminate every thread when you are done using it. */\n    terminate(thread) {\n        return thread[symbols_1.$terminate]();\n    }\n};\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ObservablePromise = void 0;\nconst observable_fns_1 = require(\"observable-fns\");\nconst doNothing = () => undefined;\nconst returnInput = (input) => input;\nconst runDeferred = (fn) => Promise.resolve().then(fn);\nfunction fail(error) {\n    throw error;\n}\nfunction isThenable(thing) {\n    return thing && typeof thing.then === \"function\";\n}\n/**\n * Creates a hybrid, combining the APIs of an Observable and a Promise.\n *\n * It is used to proxy async process states when we are initially not sure\n * if that async process will yield values once (-> Promise) or multiple\n * times (-> Observable).\n *\n * Note that the observable promise inherits some of the observable's characteristics:\n * The `init` function will be called *once for every time anyone subscribes to it*.\n *\n * If this is undesired, derive a hot observable from it using `makeHot()` and\n * subscribe to that.\n */\nclass ObservablePromise extends observable_fns_1.Observable {\n    constructor(init) {\n        super((originalObserver) => {\n            // tslint:disable-next-line no-this-assignment\n            const self = this;\n            const observer = Object.assign(Object.assign({}, originalObserver), { complete() {\n                    originalObserver.complete();\n                    self.onCompletion();\n                }, error(error) {\n                    originalObserver.error(error);\n                    self.onError(error);\n                },\n                next(value) {\n                    originalObserver.next(value);\n                    self.onNext(value);\n                } });\n            try {\n                this.initHasRun = true;\n                return init(observer);\n            }\n            catch (error) {\n                observer.error(error);\n            }\n        });\n        this.initHasRun = false;\n        this.fulfillmentCallbacks = [];\n        this.rejectionCallbacks = [];\n        this.firstValueSet = false;\n        this.state = \"pending\";\n    }\n    onNext(value) {\n        if (!this.firstValueSet) {\n            this.firstValue = value;\n            this.firstValueSet = true;\n        }\n    }\n    onError(error) {\n        this.state = \"rejected\";\n        this.rejection = error;\n        for (const onRejected of this.rejectionCallbacks) {\n            // Promisifying the call to turn errors into unhandled promise rejections\n            // instead of them failing sync and cancelling the iteration\n            runDeferred(() => onRejected(error));\n        }\n    }\n    onCompletion() {\n        this.state = \"fulfilled\";\n        for (const onFulfilled of this.fulfillmentCallbacks) {\n            // Promisifying the call to turn errors into unhandled promise rejections\n            // instead of them failing sync and cancelling the iteration\n            runDeferred(() => onFulfilled(this.firstValue));\n        }\n    }\n    then(onFulfilledRaw, onRejectedRaw) {\n        const onFulfilled = onFulfilledRaw || returnInput;\n        const onRejected = onRejectedRaw || fail;\n        let onRejectedCalled = false;\n        return new Promise((resolve, reject) => {\n            const rejectionCallback = (error) => {\n                if (onRejectedCalled)\n                    return;\n                onRejectedCalled = true;\n                try {\n                    resolve(onRejected(error));\n                }\n                catch (anotherError) {\n                    reject(anotherError);\n                }\n            };\n            const fulfillmentCallback = (value) => {\n                try {\n                    resolve(onFulfilled(value));\n                }\n                catch (error) {\n                    rejectionCallback(error);\n                }\n            };\n            if (!this.initHasRun) {\n                this.subscribe({ error: rejectionCallback });\n            }\n            if (this.state === \"fulfilled\") {\n                return resolve(onFulfilled(this.firstValue));\n            }\n            if (this.state === \"rejected\") {\n                onRejectedCalled = true;\n                return resolve(onRejected(this.rejection));\n            }\n            this.fulfillmentCallbacks.push(fulfillmentCallback);\n            this.rejectionCallbacks.push(rejectionCallback);\n        });\n    }\n    catch(onRejected) {\n        return this.then(undefined, onRejected);\n    }\n    finally(onCompleted) {\n        const handler = onCompleted || doNothing;\n        return this.then((value) => {\n            handler();\n            return value;\n        }, () => handler());\n    }\n    static from(thing) {\n        if (isThenable(thing)) {\n            return new ObservablePromise(observer => {\n                const onFulfilled = (value) => {\n                    observer.next(value);\n                    observer.complete();\n                };\n                const onRejected = (error) => {\n                    observer.error(error);\n                };\n                thing.then(onFulfilled, onRejected);\n            });\n        }\n        else {\n            return super.from(thing);\n        }\n    }\n}\nexports.ObservablePromise = ObservablePromise;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.allSettled = void 0;\n// Based on <https://github.com/es-shims/Promise.allSettled/blob/master/implementation.js>\nfunction allSettled(values) {\n    return Promise.all(values.map(item => {\n        const onFulfill = (value) => {\n            return { status: 'fulfilled', value };\n        };\n        const onReject = (reason) => {\n            return { status: 'rejected', reason };\n        };\n        const itemPromise = Promise.resolve(item);\n        try {\n            return itemPromise.then(onFulfill, onReject);\n        }\n        catch (error) {\n            return Promise.reject(error);\n        }\n    }));\n}\nexports.allSettled = allSettled;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.createPromiseWithResolver = void 0;\nconst doNothing = () => undefined;\n/**\n * Creates a new promise and exposes its resolver function.\n * Use with care!\n */\nfunction createPromiseWithResolver() {\n    let alreadyResolved = false;\n    let resolvedTo;\n    let resolver = doNothing;\n    const promise = new Promise(resolve => {\n        if (alreadyResolved) {\n            resolve(resolvedTo);\n        }\n        else {\n            resolver = resolve;\n        }\n    });\n    const exposedResolver = (value) => {\n        alreadyResolved = true;\n        resolvedTo = value;\n        resolver(resolvedTo);\n    };\n    return [promise, exposedResolver];\n}\nexports.createPromiseWithResolver = createPromiseWithResolver;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.DefaultSerializer = exports.extendSerializer = void 0;\nfunction extendSerializer(extend, implementation) {\n    const fallbackDeserializer = extend.deserialize.bind(extend);\n    const fallbackSerializer = extend.serialize.bind(extend);\n    return {\n        deserialize(message) {\n            return implementation.deserialize(message, fallbackDeserializer);\n        },\n        serialize(input) {\n            return implementation.serialize(input, fallbackSerializer);\n        }\n    };\n}\nexports.extendSerializer = extendSerializer;\nconst DefaultErrorSerializer = {\n    deserialize(message) {\n        return Object.assign(Error(message.message), {\n            name: message.name,\n            stack: message.stack\n        });\n    },\n    serialize(error) {\n        return {\n            __error_marker: \"$$error\",\n            message: error.message,\n            name: error.name,\n            stack: error.stack\n        };\n    }\n};\nconst isSerializedError = (thing) => thing && typeof thing === \"object\" && \"__error_marker\" in thing && thing.__error_marker === \"$$error\";\nexports.DefaultSerializer = {\n    deserialize(message) {\n        if (isSerializedError(message)) {\n            return DefaultErrorSerializer.deserialize(message);\n        }\n        else {\n            return message;\n        }\n    },\n    serialize(input) {\n        if (input instanceof Error) {\n            return DefaultErrorSerializer.serialize(input);\n        }\n        else {\n            return input;\n        }\n    }\n};\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.$worker = exports.$transferable = exports.$terminate = exports.$events = exports.$errors = void 0;\nexports.$errors = Symbol(\"thread.errors\");\nexports.$events = Symbol(\"thread.events\");\nexports.$terminate = Symbol(\"thread.terminate\");\nexports.$transferable = Symbol(\"thread.transferable\");\nexports.$worker = Symbol(\"thread.worker\");\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Transfer = exports.isTransferDescriptor = void 0;\nconst symbols_1 = require(\"./symbols\");\nfunction isTransferable(thing) {\n    if (!thing || typeof thing !== \"object\")\n        return false;\n    // Don't check too thoroughly, since the list of transferable things in JS might grow over time\n    return true;\n}\nfunction isTransferDescriptor(thing) {\n    return thing && typeof thing === \"object\" && thing[symbols_1.$transferable];\n}\nexports.isTransferDescriptor = isTransferDescriptor;\nfunction Transfer(payload, transferables) {\n    if (!transferables) {\n        if (!isTransferable(payload))\n            throw Error();\n        transferables = [payload];\n    }\n    return {\n        [symbols_1.$transferable]: true,\n        send: payload,\n        transferables\n    };\n}\nexports.Transfer = Transfer;\n","\"use strict\";\n/// <reference lib=\"dom\" />\n// tslint:disable max-classes-per-file\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.WorkerEventType = void 0;\nconst symbols_1 = require(\"../symbols\");\n/** Event as emitted by worker thread. Subscribe to using `Thread.events(thread)`. */\nvar WorkerEventType;\n(function (WorkerEventType) {\n    WorkerEventType[\"internalError\"] = \"internalError\";\n    WorkerEventType[\"message\"] = \"message\";\n    WorkerEventType[\"termination\"] = \"termination\";\n})(WorkerEventType = exports.WorkerEventType || (exports.WorkerEventType = {}));\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.WorkerMessageType = exports.MasterMessageType = void 0;\n/////////////////////////////\n// Messages sent by master:\nvar MasterMessageType;\n(function (MasterMessageType) {\n    MasterMessageType[\"cancel\"] = \"cancel\";\n    MasterMessageType[\"run\"] = \"run\";\n})(MasterMessageType = exports.MasterMessageType || (exports.MasterMessageType = {}));\n////////////////////////////\n// Messages sent by worker:\nvar WorkerMessageType;\n(function (WorkerMessageType) {\n    WorkerMessageType[\"error\"] = \"error\";\n    WorkerMessageType[\"init\"] = \"init\";\n    WorkerMessageType[\"result\"] = \"result\";\n    WorkerMessageType[\"running\"] = \"running\";\n    WorkerMessageType[\"uncaughtError\"] = \"uncaughtError\";\n})(WorkerMessageType = exports.WorkerMessageType || (exports.WorkerMessageType = {}));\n","\"use strict\";\n/// <reference lib=\"dom\" />\n// tslint:disable no-shadowed-variable\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst isWorkerRuntime = function isWorkerRuntime() {\n    const isWindowContext = typeof self !== \"undefined\" && typeof Window !== \"undefined\" && self instanceof Window;\n    return typeof self !== \"undefined\" && self.postMessage && !isWindowContext ? true : false;\n};\nconst postMessageToMaster = function postMessageToMaster(data, transferList) {\n    self.postMessage(data, transferList);\n};\nconst subscribeToMasterMessages = function subscribeToMasterMessages(onMessage) {\n    const messageHandler = (messageEvent) => {\n        onMessage(messageEvent.data);\n    };\n    const unsubscribe = () => {\n        self.removeEventListener(\"message\", messageHandler);\n    };\n    self.addEventListener(\"message\", messageHandler);\n    return unsubscribe;\n};\nexports.default = {\n    isWorkerRuntime,\n    postMessageToMaster,\n    subscribeToMasterMessages\n};\n","\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.expose = exports.isWorkerRuntime = exports.Transfer = exports.registerSerializer = void 0;\nconst is_observable_1 = __importDefault(require(\"is-observable\"));\nconst common_1 = require(\"../common\");\nconst transferable_1 = require(\"../transferable\");\nconst messages_1 = require(\"../types/messages\");\nconst implementation_1 = __importDefault(require(\"./implementation\"));\nvar common_2 = require(\"../common\");\nObject.defineProperty(exports, \"registerSerializer\", { enumerable: true, get: function () { return common_2.registerSerializer; } });\nvar transferable_2 = require(\"../transferable\");\nObject.defineProperty(exports, \"Transfer\", { enumerable: true, get: function () { return transferable_2.Transfer; } });\n/** Returns `true` if this code is currently running in a worker. */\nexports.isWorkerRuntime = implementation_1.default.isWorkerRuntime;\nlet exposeCalled = false;\nconst activeSubscriptions = new Map();\nconst isMasterJobCancelMessage = (thing) => thing && thing.type === messages_1.MasterMessageType.cancel;\nconst isMasterJobRunMessage = (thing) => thing && thing.type === messages_1.MasterMessageType.run;\n/**\n * There are issues with `is-observable` not recognizing zen-observable's instances.\n * We are using `observable-fns`, but it's based on zen-observable, too.\n */\nconst isObservable = (thing) => is_observable_1.default(thing) || isZenObservable(thing);\nfunction isZenObservable(thing) {\n    return thing && typeof thing === \"object\" && typeof thing.subscribe === \"function\";\n}\nfunction deconstructTransfer(thing) {\n    return transferable_1.isTransferDescriptor(thing)\n        ? { payload: thing.send, transferables: thing.transferables }\n        : { payload: thing, transferables: undefined };\n}\nfunction postFunctionInitMessage() {\n    const initMessage = {\n        type: messages_1.WorkerMessageType.init,\n        exposed: {\n            type: \"function\"\n        }\n    };\n    implementation_1.default.postMessageToMaster(initMessage);\n}\nfunction postModuleInitMessage(methodNames) {\n    const initMessage = {\n        type: messages_1.WorkerMessageType.init,\n        exposed: {\n            type: \"module\",\n            methods: methodNames\n        }\n    };\n    implementation_1.default.postMessageToMaster(initMessage);\n}\nfunction postJobErrorMessage(uid, rawError) {\n    const { payload: error, transferables } = deconstructTransfer(rawError);\n    const errorMessage = {\n        type: messages_1.WorkerMessageType.error,\n        uid,\n        error: common_1.serialize(error)\n    };\n    implementation_1.default.postMessageToMaster(errorMessage, transferables);\n}\nfunction postJobResultMessage(uid, completed, resultValue) {\n    const { payload, transferables } = deconstructTransfer(resultValue);\n    const resultMessage = {\n        type: messages_1.WorkerMessageType.result,\n        uid,\n        complete: completed ? true : undefined,\n        payload\n    };\n    implementation_1.default.postMessageToMaster(resultMessage, transferables);\n}\nfunction postJobStartMessage(uid, resultType) {\n    const startMessage = {\n        type: messages_1.WorkerMessageType.running,\n        uid,\n        resultType\n    };\n    implementation_1.default.postMessageToMaster(startMessage);\n}\nfunction postUncaughtErrorMessage(error) {\n    try {\n        const errorMessage = {\n            type: messages_1.WorkerMessageType.uncaughtError,\n            error: common_1.serialize(error)\n        };\n        implementation_1.default.postMessageToMaster(errorMessage);\n    }\n    catch (subError) {\n        // tslint:disable-next-line no-console\n        console.error(\"Not reporting uncaught error back to master thread as it \" +\n            \"occured while reporting an uncaught error already.\" +\n            \"\\nLatest error:\", subError, \"\\nOriginal error:\", error);\n    }\n}\nfunction runFunction(jobUID, fn, args) {\n    return __awaiter(this, void 0, void 0, function* () {\n        let syncResult;\n        try {\n            syncResult = fn(...args);\n        }\n        catch (error) {\n            return postJobErrorMessage(jobUID, error);\n        }\n        const resultType = isObservable(syncResult) ? \"observable\" : \"promise\";\n        postJobStartMessage(jobUID, resultType);\n        if (isObservable(syncResult)) {\n            const subscription = syncResult.subscribe(value => postJobResultMessage(jobUID, false, common_1.serialize(value)), error => {\n                postJobErrorMessage(jobUID, common_1.serialize(error));\n                activeSubscriptions.delete(jobUID);\n            }, () => {\n                postJobResultMessage(jobUID, true);\n                activeSubscriptions.delete(jobUID);\n            });\n            activeSubscriptions.set(jobUID, subscription);\n        }\n        else {\n            try {\n                const result = yield syncResult;\n                postJobResultMessage(jobUID, true, common_1.serialize(result));\n            }\n            catch (error) {\n                postJobErrorMessage(jobUID, common_1.serialize(error));\n            }\n        }\n    });\n}\n/**\n * Expose a function or a module (an object whose values are functions)\n * to the main thread. Must be called exactly once in every worker thread\n * to signal its API to the main thread.\n *\n * @param exposed Function or object whose values are functions\n */\nfunction expose(exposed) {\n    if (!implementation_1.default.isWorkerRuntime()) {\n        throw Error(\"expose() called in the master thread.\");\n    }\n    if (exposeCalled) {\n        throw Error(\"expose() called more than once. This is not possible. Pass an object to expose() if you want to expose multiple functions.\");\n    }\n    exposeCalled = true;\n    if (typeof exposed === \"function\") {\n        implementation_1.default.subscribeToMasterMessages(messageData => {\n            if (isMasterJobRunMessage(messageData) && !messageData.method) {\n                runFunction(messageData.uid, exposed, messageData.args.map(common_1.deserialize));\n            }\n        });\n        postFunctionInitMessage();\n    }\n    else if (typeof exposed === \"object\" && exposed) {\n        implementation_1.default.subscribeToMasterMessages(messageData => {\n            if (isMasterJobRunMessage(messageData) && messageData.method) {\n                runFunction(messageData.uid, exposed[messageData.method], messageData.args.map(common_1.deserialize));\n            }\n        });\n        const methodNames = Object.keys(exposed).filter(key => typeof exposed[key] === \"function\");\n        postModuleInitMessage(methodNames);\n    }\n    else {\n        throw Error(`Invalid argument passed to expose(). Expected a function or an object, got: ${exposed}`);\n    }\n    implementation_1.default.subscribeToMasterMessages(messageData => {\n        if (isMasterJobCancelMessage(messageData)) {\n            const jobUID = messageData.uid;\n            const subscription = activeSubscriptions.get(jobUID);\n            if (subscription) {\n                subscription.unsubscribe();\n                activeSubscriptions.delete(jobUID);\n            }\n        }\n    });\n}\nexports.expose = expose;\nif (typeof self !== \"undefined\" && typeof self.addEventListener === \"function\" && implementation_1.default.isWorkerRuntime()) {\n    self.addEventListener(\"error\", event => {\n        // Post with some delay, so the master had some time to subscribe to messages\n        setTimeout(() => postUncaughtErrorMessage(event.error || event), 250);\n    });\n    self.addEventListener(\"unhandledrejection\", event => {\n        const error = event.reason;\n        if (error && typeof error.message === \"string\") {\n            // Post with some delay, so the master had some time to subscribe to messages\n            setTimeout(() => postUncaughtErrorMessage(error), 250);\n        }\n    });\n}\nif (typeof process !== \"undefined\" && typeof process.on === \"function\" && implementation_1.default.isWorkerRuntime()) {\n    process.on(\"uncaughtException\", (error) => {\n        // Post with some delay, so the master had some time to subscribe to messages\n        setTimeout(() => postUncaughtErrorMessage(error), 250);\n    });\n    process.on(\"unhandledRejection\", (error) => {\n        if (error && typeof error.message === \"string\") {\n            // Post with some delay, so the master had some time to subscribe to messages\n            setTimeout(() => postUncaughtErrorMessage(error), 250);\n        }\n    });\n}\n","/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    if (typeof b !== \"function\" && b !== null)\r\n        throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport var __createBinding = Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n});\r\n\r\nexport function __exportStar(m, o) {\r\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);\r\n}\r\n\r\nexport function __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n}\r\n\r\nexport function __spreadArray(to, from, pack) {\r\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\r\n        if (ar || !(i in from)) {\r\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\r\n            ar[i] = from[i];\r\n        }\r\n    }\r\n    return to.concat(ar || Array.prototype.slice.call(from));\r\n}\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nvar __setModuleDefault = Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nexport function __classPrivateFieldGet(receiver, state, kind, f) {\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\r\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\r\n}\r\n\r\nexport function __classPrivateFieldSet(receiver, state, value, kind, f) {\r\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\r\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\r\n}\r\n","import { identity, isSubtypeOf, isValueDefined, logError, nameof } from './helpers';\nimport { JsonObjectMetadata } from './metadata';\nimport { getOptionValue, mergeOptions } from './options-base';\nimport { AnyT, ArrayTypeDescriptor, ConcreteTypeDescriptor, ensureTypeDescriptor, MapTypeDescriptor, SetTypeDescriptor, } from './type-descriptor';\nexport function defaultTypeResolver(sourceObject, knownTypes) {\n    if (sourceObject.__type != null) {\n        return knownTypes.get(sourceObject.__type);\n    }\n}\nvar Deserializer = (function () {\n    function Deserializer() {\n        this.typeResolver = defaultTypeResolver;\n        this.errorHandler = logError;\n        this.deserializationStrategy = new Map([\n            [AnyT.ctor, identity],\n            [Number, deserializeDirectly],\n            [String, deserializeDirectly],\n            [Boolean, deserializeDirectly],\n            [Date, deserializeDate],\n            [ArrayBuffer, stringToArrayBuffer],\n            [DataView, stringToDataView],\n            [Array, convertAsArray],\n            [Set, convertAsSet],\n            [Map, convertAsMap],\n            [Float32Array, convertAsFloatArray],\n            [Float64Array, convertAsFloatArray],\n            [Uint8Array, convertAsUintArray],\n            [Uint8ClampedArray, convertAsUintArray],\n            [Uint16Array, convertAsUintArray],\n            [Uint32Array, convertAsUintArray],\n        ]);\n    }\n    Deserializer.prototype.setDeserializationStrategy = function (type, deserializer) {\n        this.deserializationStrategy.set(type, deserializer);\n    };\n    Deserializer.prototype.setNameResolver = function (nameResolverCallback) {\n        this.nameResolver = nameResolverCallback;\n    };\n    Deserializer.prototype.setTypeResolver = function (typeResolverCallback) {\n        if (typeof typeResolverCallback !== 'function') {\n            throw new TypeError('\\'typeResolverCallback\\' is not a function.');\n        }\n        this.typeResolver = typeResolverCallback;\n    };\n    Deserializer.prototype.getTypeResolver = function () {\n        return this.typeResolver;\n    };\n    Deserializer.prototype.setErrorHandler = function (errorHandlerCallback) {\n        if (typeof errorHandlerCallback !== 'function') {\n            throw new TypeError('\\'errorHandlerCallback\\' is not a function.');\n        }\n        this.errorHandler = errorHandlerCallback;\n    };\n    Deserializer.prototype.getErrorHandler = function () {\n        return this.errorHandler;\n    };\n    Deserializer.prototype.convertSingleValue = function (sourceObject, typeDescriptor, knownTypes, memberName, memberOptions) {\n        if (memberName === void 0) { memberName = 'object'; }\n        if (this.retrievePreserveNull(memberOptions) && sourceObject === null) {\n            return null;\n        }\n        else if (!isValueDefined(sourceObject)) {\n            return;\n        }\n        var deserializer = this.deserializationStrategy.get(typeDescriptor.ctor);\n        if (deserializer !== undefined) {\n            return deserializer(sourceObject, typeDescriptor, knownTypes, memberName, this, memberOptions);\n        }\n        if (typeof sourceObject === 'object') {\n            return convertAsObject(sourceObject, typeDescriptor, knownTypes, memberName, this);\n        }\n        var error = \"Could not deserialize '\" + memberName + \"'; don't know how to deserialize type\";\n        if (typeDescriptor.hasFriendlyName()) {\n            error += \" '\" + typeDescriptor.ctor.name + \"'\";\n        }\n        this.errorHandler(new TypeError(error + \".\"));\n    };\n    Deserializer.prototype.instantiateType = function (ctor) {\n        return new ctor();\n    };\n    Deserializer.prototype.mergeKnownTypes = function () {\n        var _this = this;\n        var knownTypeMaps = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            knownTypeMaps[_i] = arguments[_i];\n        }\n        var result = new Map();\n        knownTypeMaps.forEach(function (knownTypes) {\n            knownTypes.forEach(function (ctor, name) {\n                if (_this.nameResolver === undefined) {\n                    result.set(name, ctor);\n                }\n                else {\n                    result.set(_this.nameResolver(ctor), ctor);\n                }\n            });\n        });\n        return result;\n    };\n    Deserializer.prototype.createKnownTypesMap = function (knowTypes) {\n        var _this = this;\n        var map = new Map();\n        knowTypes.forEach(function (ctor) {\n            if (_this.nameResolver === undefined) {\n                var knownTypeMeta = JsonObjectMetadata.getFromConstructor(ctor);\n                var customName = (knownTypeMeta === null || knownTypeMeta === void 0 ? void 0 : knownTypeMeta.isExplicitlyMarked) === true\n                    ? knownTypeMeta.name\n                    : null;\n                map.set(customName !== null && customName !== void 0 ? customName : ctor.name, ctor);\n            }\n            else {\n                map.set(_this.nameResolver(ctor), ctor);\n            }\n        });\n        return map;\n    };\n    Deserializer.prototype.retrievePreserveNull = function (memberOptions) {\n        return getOptionValue('preserveNull', mergeOptions(this.options, memberOptions));\n    };\n    return Deserializer;\n}());\nexport { Deserializer };\nfunction throwTypeMismatchError(targetType, expectedSourceType, actualSourceType, memberName) {\n    throw new TypeError(\"Could not deserialize \" + memberName + \" as \" + targetType + \":\"\n        + (\" expected \" + expectedSourceType + \", got \" + actualSourceType + \".\"));\n}\nfunction makeTypeErrorMessage(expectedType, actualType, memberName) {\n    var expectedTypeName = typeof expectedType === 'function'\n        ? nameof(expectedType)\n        : expectedType;\n    var actualTypeName = typeof actualType === 'function' ? nameof(actualType) : actualType;\n    return \"Could not deserialize \" + memberName + \": expected '\" + expectedTypeName + \"',\"\n        + (\" got '\" + actualTypeName + \"'.\");\n}\nfunction srcTypeNameForDebug(sourceObject) {\n    return sourceObject == null ? 'undefined' : nameof(sourceObject.constructor);\n}\nfunction deserializeDirectly(sourceObject, typeDescriptor, knownTypes, objectName) {\n    if (sourceObject.constructor !== typeDescriptor.ctor) {\n        throw new TypeError(makeTypeErrorMessage(nameof(typeDescriptor.ctor), sourceObject.constructor, objectName));\n    }\n    return sourceObject;\n}\nfunction convertAsObject(sourceObject, typeDescriptor, knownTypes, memberName, deserializer) {\n    if (typeof sourceObject !== 'object' || sourceObject === null) {\n        deserializer.getErrorHandler()(new TypeError(\"Cannot deserialize \" + memberName + \": 'sourceObject' must be a defined object.\"));\n        return undefined;\n    }\n    var expectedSelfType = typeDescriptor.ctor;\n    var sourceObjectMetadata = JsonObjectMetadata.getFromConstructor(expectedSelfType);\n    var knownTypeConstructors = knownTypes;\n    var typeResolver = deserializer.getTypeResolver();\n    if (sourceObjectMetadata !== undefined) {\n        sourceObjectMetadata.processDeferredKnownTypes();\n        knownTypeConstructors = deserializer.mergeKnownTypes(knownTypeConstructors, deserializer.createKnownTypesMap(sourceObjectMetadata.knownTypes));\n        if (sourceObjectMetadata.typeResolver != null) {\n            typeResolver = sourceObjectMetadata.typeResolver;\n        }\n    }\n    var typeFromTypeHint = typeResolver(sourceObject, knownTypeConstructors);\n    if (typeFromTypeHint != null) {\n        if (isSubtypeOf(typeFromTypeHint, expectedSelfType)) {\n            expectedSelfType = typeFromTypeHint;\n            sourceObjectMetadata = JsonObjectMetadata.getFromConstructor(typeFromTypeHint);\n            if (sourceObjectMetadata !== undefined) {\n                knownTypeConstructors = deserializer.mergeKnownTypes(knownTypeConstructors, deserializer.createKnownTypesMap(sourceObjectMetadata.knownTypes));\n            }\n        }\n    }\n    if ((sourceObjectMetadata === null || sourceObjectMetadata === void 0 ? void 0 : sourceObjectMetadata.isExplicitlyMarked) === true) {\n        var sourceMetadata_1 = sourceObjectMetadata;\n        var sourceObjectWithDeserializedProperties_1 = {};\n        var classOptions_1 = mergeOptions(deserializer.options, sourceMetadata_1.options);\n        sourceMetadata_1.dataMembers.forEach(function (objMemberMetadata, propKey) {\n            var objMemberValue = sourceObject[propKey];\n            var objMemberDebugName = nameof(sourceMetadata_1.classType) + \".\" + propKey;\n            var objMemberOptions = mergeOptions(classOptions_1, objMemberMetadata.options);\n            var revivedValue;\n            if (objMemberMetadata.deserializer != null) {\n                revivedValue = objMemberMetadata.deserializer(objMemberValue, {\n                    fallback: function (so, td) { return deserializer.convertSingleValue(so, ensureTypeDescriptor(td), knownTypes); },\n                });\n            }\n            else if (objMemberMetadata.type == null) {\n                throw new TypeError(\"Cannot deserialize \" + objMemberDebugName + \" there is\"\n                    + \" no constructor nor deserialization function to use.\");\n            }\n            else {\n                revivedValue = deserializer.convertSingleValue(objMemberValue, objMemberMetadata.type(), knownTypeConstructors, objMemberDebugName, objMemberOptions);\n            }\n            if (isValueDefined(revivedValue)\n                || (deserializer.retrievePreserveNull(objMemberOptions)\n                    && revivedValue === null)) {\n                sourceObjectWithDeserializedProperties_1[objMemberMetadata.key] = revivedValue;\n            }\n            else if (objMemberMetadata.isRequired === true) {\n                deserializer.getErrorHandler()(new TypeError(\"Missing required member '\" + objMemberDebugName + \"'.\"));\n            }\n        });\n        var targetObject = void 0;\n        if (typeof sourceObjectMetadata.initializerCallback === 'function') {\n            try {\n                targetObject = sourceObjectMetadata.initializerCallback(sourceObjectWithDeserializedProperties_1, sourceObject);\n                if (targetObject == null) {\n                    throw new TypeError(\"Cannot deserialize \" + memberName + \":\"\n                        + \" 'initializer' function returned undefined/null\"\n                        + (\", but '\" + nameof(sourceObjectMetadata.classType) + \"' was expected.\"));\n                }\n                else if (!(targetObject instanceof sourceObjectMetadata.classType)) {\n                    throw new TypeError(\"Cannot deserialize \" + memberName + \":\"\n                        + (\"'initializer' returned '\" + nameof(targetObject.constructor) + \"'\")\n                        + (\", but '\" + nameof(sourceObjectMetadata.classType) + \"' was expected\")\n                        + (\", and '\" + nameof(targetObject.constructor) + \"' is not a subtype of\")\n                        + (\" '\" + nameof(sourceObjectMetadata.classType) + \"'\"));\n                }\n            }\n            catch (e) {\n                deserializer.getErrorHandler()(e);\n                return undefined;\n            }\n        }\n        else {\n            targetObject = deserializer.instantiateType(expectedSelfType);\n        }\n        Object.assign(targetObject, sourceObjectWithDeserializedProperties_1);\n        var methodName = sourceObjectMetadata.onDeserializedMethodName;\n        if (methodName != null) {\n            if (typeof targetObject[methodName] === 'function') {\n                targetObject[methodName]();\n            }\n            else if (typeof targetObject.constructor[methodName] === 'function') {\n                targetObject.constructor[methodName]();\n            }\n            else {\n                deserializer.getErrorHandler()(new TypeError(\"onDeserialized callback\"\n                    + (\"'\" + nameof(sourceObjectMetadata.classType) + \".\" + methodName + \"' is not a method.\")));\n            }\n        }\n        return targetObject;\n    }\n    else {\n        var targetObject_1 = {};\n        Object.keys(sourceObject).forEach(function (sourceKey) {\n            targetObject_1[sourceKey] = deserializer.convertSingleValue(sourceObject[sourceKey], new ConcreteTypeDescriptor(sourceObject[sourceKey].constructor), knownTypes, sourceKey);\n        });\n        return targetObject_1;\n    }\n}\nfunction convertAsArray(sourceObject, typeDescriptor, knownTypes, memberName, deserializer, memberOptions) {\n    if (!(typeDescriptor instanceof ArrayTypeDescriptor)) {\n        throw new TypeError(\"Could not deserialize \" + memberName + \" as Array: incorrect TypeDescriptor detected,\"\n            + ' please use proper annotation or function for this type');\n    }\n    if (!Array.isArray(sourceObject)) {\n        deserializer.getErrorHandler()(new TypeError(makeTypeErrorMessage(Array, sourceObject.constructor, memberName)));\n        return [];\n    }\n    if (typeDescriptor.elementType == null) {\n        deserializer.getErrorHandler()(new TypeError(\"Could not deserialize \" + memberName + \" as Array: missing constructor reference of\"\n            + \" Array elements.\"));\n        return [];\n    }\n    return sourceObject.map(function (element, i) {\n        try {\n            return deserializer.convertSingleValue(element, typeDescriptor.elementType, knownTypes, memberName + \"[\" + i + \"]\", memberOptions);\n        }\n        catch (e) {\n            deserializer.getErrorHandler()(e);\n            return undefined;\n        }\n    });\n}\nfunction convertAsSet(sourceObject, typeDescriptor, knownTypes, memberName, deserializer, memberOptions) {\n    if (!(typeDescriptor instanceof SetTypeDescriptor)) {\n        throw new TypeError(\"Could not deserialize \" + memberName + \" as Set: incorrect TypeDescriptor detected,\"\n            + \" please use proper annotation or function for this type\");\n    }\n    if (!Array.isArray(sourceObject)) {\n        deserializer.getErrorHandler()(new TypeError(makeTypeErrorMessage(Array, sourceObject.constructor, memberName)));\n        return new Set();\n    }\n    if (typeDescriptor.elementType == null) {\n        deserializer.getErrorHandler()(new TypeError(\"Could not deserialize \" + memberName + \" as Set: missing constructor reference of\"\n            + \" Set elements.\"));\n        return new Set();\n    }\n    var resultSet = new Set();\n    sourceObject.forEach(function (element, i) {\n        try {\n            resultSet.add(deserializer.convertSingleValue(element, typeDescriptor.elementType, knownTypes, memberName + \"[\" + i + \"]\", memberOptions));\n        }\n        catch (e) {\n            deserializer.getErrorHandler()(e);\n        }\n    });\n    return resultSet;\n}\nfunction isExpectedMapShape(source, expectedShape) {\n    return (expectedShape === 0 && Array.isArray(source))\n        || (expectedShape === 1 && typeof source === 'object');\n}\nfunction convertAsMap(sourceObject, typeDescriptor, knownTypes, memberName, deserializer, memberOptions) {\n    if (!(typeDescriptor instanceof MapTypeDescriptor)) {\n        throw new TypeError(\"Could not deserialize \" + memberName + \" as Map: incorrect TypeDescriptor detected,\"\n            + 'please use proper annotation or function for this type');\n    }\n    var expectedShape = typeDescriptor.getCompleteOptions().shape;\n    if (!isExpectedMapShape(sourceObject, expectedShape)) {\n        var expectedType = expectedShape === 0 ? Array : Object;\n        deserializer.getErrorHandler()(new TypeError(makeTypeErrorMessage(expectedType, sourceObject.constructor, memberName)));\n        return new Map();\n    }\n    if (typeDescriptor.keyType == null) {\n        deserializer.getErrorHandler()(new TypeError(\"Could not deserialize \" + memberName + \" as Map: missing key constructor.\"));\n        return new Map();\n    }\n    if (typeDescriptor.valueType == null) {\n        deserializer.getErrorHandler()(new TypeError(\"Could not deserialize \" + memberName + \" as Map: missing value constructor.\"));\n        return new Map();\n    }\n    var keyMemberName = memberName + \"[].key\";\n    var valueMemberName = memberName + \"[].value\";\n    var resultMap = new Map();\n    if (expectedShape === 1) {\n        Object.keys(sourceObject).forEach(function (key) {\n            try {\n                var resultKey = deserializer.convertSingleValue(key, typeDescriptor.keyType, knownTypes, keyMemberName, memberOptions);\n                if (isValueDefined(resultKey)) {\n                    resultMap.set(resultKey, deserializer.convertSingleValue(sourceObject[key], typeDescriptor.valueType, knownTypes, valueMemberName, memberOptions));\n                }\n            }\n            catch (e) {\n                deserializer.getErrorHandler()(e);\n            }\n        });\n    }\n    else {\n        sourceObject.forEach(function (element) {\n            try {\n                var key = deserializer.convertSingleValue(element.key, typeDescriptor.keyType, knownTypes, keyMemberName, memberOptions);\n                if (isValueDefined(key)) {\n                    resultMap.set(key, deserializer.convertSingleValue(element.value, typeDescriptor.valueType, knownTypes, valueMemberName, memberOptions));\n                }\n            }\n            catch (e) {\n                deserializer.getErrorHandler()(e);\n            }\n        });\n    }\n    return resultMap;\n}\nfunction deserializeDate(sourceObject, typeDescriptor, knownTypes, memberName) {\n    if (typeof sourceObject === 'number') {\n        var isInteger = sourceObject % 1 === 0;\n        if (!isInteger) {\n            throw new TypeError(\"Could not deserialize \" + memberName + \" as Date:\"\n                + \" expected an integer, got a number with decimal places.\");\n        }\n        return new Date(sourceObject);\n    }\n    else if (typeof sourceObject === 'string') {\n        return new Date(sourceObject);\n    }\n    else if (sourceObject instanceof Date) {\n        return sourceObject;\n    }\n    else {\n        throwTypeMismatchError('Date', 'an ISO-8601 string', srcTypeNameForDebug(sourceObject), memberName);\n    }\n}\nfunction stringToArrayBuffer(sourceObject, typeDescriptor, knownTypes, memberName) {\n    if (typeof sourceObject !== 'string') {\n        throwTypeMismatchError('ArrayBuffer', 'a string source', srcTypeNameForDebug(sourceObject), memberName);\n    }\n    return createArrayBufferFromString(sourceObject);\n}\nfunction stringToDataView(sourceObject, typeDescriptor, knownTypes, memberName) {\n    if (typeof sourceObject !== 'string') {\n        throwTypeMismatchError('DataView', 'a string source', srcTypeNameForDebug(sourceObject), memberName);\n    }\n    return new DataView(createArrayBufferFromString(sourceObject));\n}\nfunction createArrayBufferFromString(input) {\n    var buf = new ArrayBuffer(input.length * 2);\n    var bufView = new Uint16Array(buf);\n    for (var i = 0, strLen = input.length; i < strLen; i++) {\n        bufView[i] = input.charCodeAt(i);\n    }\n    return buf;\n}\nfunction convertAsFloatArray(sourceObject, typeDescriptor, knownTypes, memberName) {\n    var constructor = typeDescriptor.ctor;\n    if (Array.isArray(sourceObject) && sourceObject.every(function (elem) { return !isNaN(elem); })) {\n        return new constructor(sourceObject);\n    }\n    return throwTypeMismatchError(constructor.name, 'a numeric source array', srcTypeNameForDebug(sourceObject), memberName);\n}\nfunction convertAsUintArray(sourceObject, typeDescriptor, knownTypes, memberName) {\n    var constructor = typeDescriptor.ctor;\n    if (Array.isArray(sourceObject) && sourceObject.every(function (elem) { return !isNaN(elem); })) {\n        return new constructor(sourceObject.map(function (value) { return ~~value; }));\n    }\n    return throwTypeMismatchError(typeDescriptor.ctor.name, 'a numeric source array', srcTypeNameForDebug(sourceObject), memberName);\n}\n//# sourceMappingURL=deserializer.js.map","import { __spreadArrays } from \"tslib\";\nimport { AnyT } from './type-descriptor';\nexport var LAZY_TYPE_EXPLANATION = \"If the type is not yet defined, for example due to circular references, add '() => ' before it. E.g. @jsonMember(() => Foo)\";\nexport var MISSING_REFLECT_CONF_MSG = 'Make sure that you have both \"experimentalDecorators\"'\n    + ' and \"emitDecoratorMetadata\" enabled in your tsconfig.json';\nexport function isDirectlySerializableNativeType(type) {\n    return [Date, Number, String, Boolean].indexOf(type) !== -1;\n}\nexport function isDirectlyDeserializableNativeType(type) {\n    return [Number, String, Boolean].indexOf(type) !== -1;\n}\nexport function isTypeTypedArray(type) {\n    return [\n        Float32Array,\n        Float64Array,\n        Int8Array,\n        Uint8Array,\n        Uint8ClampedArray,\n        Int16Array,\n        Uint16Array,\n        Int32Array,\n        Uint32Array,\n    ].indexOf(type) !== -1;\n}\nexport function isObject(value) {\n    return typeof value === 'object';\n}\nexport function shouldOmitParseString(jsonStr, expectedType) {\n    var expectsTypesSerializedAsStrings = expectedType === String\n        || expectedType === ArrayBuffer\n        || expectedType === DataView;\n    var hasQuotes = jsonStr.length >= 2\n        && jsonStr[0] === '\"'\n        && jsonStr[jsonStr.length - 1] === '\"';\n    if (expectedType === Date) {\n        var isNumber = !isNaN(Number(jsonStr.trim()));\n        return !hasQuotes && !isNumber;\n    }\n    return expectsTypesSerializedAsStrings && !hasQuotes;\n}\nexport function parseToJSObject(json, expectedType) {\n    if (typeof json !== 'string' || shouldOmitParseString(json, expectedType)) {\n        return json;\n    }\n    return JSON.parse(json);\n}\nexport function isSubtypeOf(A, B) {\n    return A === B || A.prototype instanceof B;\n}\nexport function logError(message) {\n    var optionalParams = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n        optionalParams[_i - 1] = arguments[_i];\n    }\n    if (typeof console === 'object' && typeof console.error === 'function') {\n        console.error.apply(console, __spreadArrays([message], optionalParams));\n    }\n    else if (typeof console === 'object' && typeof console.log === 'function') {\n        console.log.apply(console, __spreadArrays([\"ERROR: \" + message], optionalParams));\n    }\n}\nexport function logMessage(message) {\n    var optionalParams = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n        optionalParams[_i - 1] = arguments[_i];\n    }\n    if (typeof console === 'object' && typeof console.log === 'function') {\n        console.log.apply(console, __spreadArrays([message], optionalParams));\n    }\n}\nexport function logWarning(message) {\n    var optionalParams = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n        optionalParams[_i - 1] = arguments[_i];\n    }\n    if (typeof console === 'object' && typeof console.warn === 'function') {\n        console.warn.apply(console, __spreadArrays([message], optionalParams));\n    }\n    else if (typeof console === 'object' && typeof console.log === 'function') {\n        console.log.apply(console, __spreadArrays([\"WARNING: \" + message], optionalParams));\n    }\n}\nexport function isValueDefined(value) {\n    return !(typeof value === 'undefined' || value === null);\n}\nexport function isInstanceOf(value, constructor) {\n    if (constructor === AnyT.ctor) {\n        return true;\n    }\n    else if (typeof value === 'number') {\n        return constructor === Number;\n    }\n    else if (typeof value === 'string') {\n        return constructor === String;\n    }\n    else if (typeof value === 'boolean') {\n        return constructor === Boolean;\n    }\n    else if (isObject(value)) {\n        return value instanceof constructor;\n    }\n    return false;\n}\nexport var isReflectMetadataSupported = typeof Reflect === 'object' && typeof Reflect.getMetadata === 'function';\nexport function nameof(fn) {\n    if (typeof fn.name === 'string') {\n        return fn.name;\n    }\n    return 'undefined';\n}\nexport function identity(arg) {\n    return arg;\n}\n//# sourceMappingURL=helpers.js.map","import { isReflectMetadataSupported, logError, MISSING_REFLECT_CONF_MSG, nameof } from './helpers';\nimport { injectMetadataInformation, } from './metadata';\nimport { extractOptionBase } from './options-base';\nimport { ArrayTypeDescriptor, ensureTypeDescriptor, ensureTypeThunk, } from './type-descriptor';\nexport function jsonArrayMember(maybeTypeThunk, options) {\n    if (options === void 0) { options = {}; }\n    return function (target, propKey) {\n        var _a;\n        var decoratorName = \"@jsonArrayMember on \" + nameof(target.constructor) + \".\" + String(propKey);\n        var typeThunk = ensureTypeThunk(maybeTypeThunk, decoratorName);\n        var dimensions = options.dimensions == null ? 1 : options.dimensions;\n        if (!isNaN(dimensions) && dimensions < 1) {\n            logError(decoratorName + \": 'dimensions' option must be at least 1.\");\n            return;\n        }\n        var reflectedType = isReflectMetadataSupported\n            ? Reflect.getMetadata('design:type', target, propKey)\n            : null;\n        if (reflectedType != null && reflectedType !== Array && reflectedType !== Object) {\n            logError(decoratorName + \": property is not an Array. \" + MISSING_REFLECT_CONF_MSG);\n            return;\n        }\n        injectMetadataInformation(target, propKey, {\n            type: function () { return createArrayType(ensureTypeDescriptor(typeThunk()), dimensions); },\n            emitDefaultValue: options.emitDefaultValue,\n            isRequired: options.isRequired,\n            options: extractOptionBase(options),\n            key: propKey.toString(),\n            name: (_a = options.name) !== null && _a !== void 0 ? _a : propKey.toString(),\n            deserializer: options.deserializer,\n            serializer: options.serializer,\n        });\n    };\n}\nexport function createArrayType(elementType, dimensions) {\n    var type = new ArrayTypeDescriptor(elementType);\n    for (var i = 1; i < dimensions; ++i) {\n        type = new ArrayTypeDescriptor(type);\n    }\n    return type;\n}\n//# sourceMappingURL=json-array-member.js.map","import { isReflectMetadataSupported, logError, MISSING_REFLECT_CONF_MSG, nameof } from './helpers';\nimport { injectMetadataInformation, } from './metadata';\nimport { extractOptionBase } from './options-base';\nimport { ensureTypeThunk, MapT } from './type-descriptor';\nexport function jsonMapMember(maybeKeyThunk, maybeValueThunk, options) {\n    if (options === void 0) { options = {}; }\n    return function (target, propKey) {\n        var _a;\n        var decoratorName = \"@jsonMapMember on \" + nameof(target.constructor) + \".\" + String(propKey);\n        var keyThunk = ensureTypeThunk(maybeKeyThunk, decoratorName);\n        var valueThunk = ensureTypeThunk(maybeValueThunk, decoratorName);\n        var reflectedType = isReflectMetadataSupported\n            ? Reflect.getMetadata('design:type', target, propKey)\n            : null;\n        if (reflectedType != null && reflectedType !== Map && reflectedType !== Object) {\n            logError(decoratorName + \": property is not a Map. \" + MISSING_REFLECT_CONF_MSG);\n            return;\n        }\n        injectMetadataInformation(target, propKey, {\n            type: function () { return MapT(keyThunk(), valueThunk(), { shape: options.shape }); },\n            emitDefaultValue: options.emitDefaultValue,\n            isRequired: options.isRequired,\n            options: extractOptionBase(options),\n            key: propKey.toString(),\n            name: (_a = options.name) !== null && _a !== void 0 ? _a : propKey.toString(),\n            deserializer: options.deserializer,\n            serializer: options.serializer,\n        });\n    };\n}\n//# sourceMappingURL=json-map-member.js.map","import { isReflectMetadataSupported, isSubtypeOf, isValueDefined, LAZY_TYPE_EXPLANATION, logError, logWarning, MISSING_REFLECT_CONF_MSG, nameof, } from './helpers';\nimport { injectMetadataInformation, } from './metadata';\nimport { extractOptionBase } from './options-base';\nimport { ArrayTypeDescriptor, ensureTypeDescriptor, ensureTypeThunk, isTypelike, isTypeThunk, MapTypeDescriptor, SetTypeDescriptor, TypeDescriptor, } from './type-descriptor';\nexport function jsonMember(optionsOrPrototype, propertyKeyOrOptions) {\n    if (typeof propertyKeyOrOptions === 'string' || typeof propertyKeyOrOptions === 'symbol') {\n        var property = propertyKeyOrOptions;\n        var prototype = optionsOrPrototype;\n        var decoratorName = \"@jsonMember on \" + nameof(prototype.constructor) + \".\" + String(property);\n        if (!isReflectMetadataSupported) {\n            logError(decoratorName + \": ReflectDecorators is required if the type is not explicitly provided with e.g. @jsonMember(Number)\");\n            return;\n        }\n        var reflectPropCtor = Reflect.getMetadata('design:type', prototype, property);\n        if (reflectPropCtor == null) {\n            logError(decoratorName + \": could not resolve detected property constructor at runtime. Potential solutions:\\n - \" + LAZY_TYPE_EXPLANATION + \"\\n - \" + MISSING_REFLECT_CONF_MSG);\n            return;\n        }\n        var typeDescriptor_1 = ensureTypeDescriptor(reflectPropCtor);\n        if (isSpecialPropertyType(decoratorName, typeDescriptor_1)) {\n            return;\n        }\n        injectMetadataInformation(prototype, property, {\n            type: function () { return typeDescriptor_1; },\n            key: propertyKeyOrOptions.toString(),\n            name: propertyKeyOrOptions.toString(),\n        });\n        return;\n    }\n    return jsonMemberDecoratorFactory(optionsOrPrototype, propertyKeyOrOptions);\n}\nfunction jsonMemberDecoratorFactory(optionsOrType, options) {\n    return function (target, property) {\n        var _a;\n        var decoratorName = \"@jsonMember on \" + nameof(target.constructor) + \".\" + String(property);\n        var typeThunk;\n        if (isTypelike(optionsOrType) || isTypeThunk(optionsOrType)) {\n            typeThunk = ensureTypeThunk(optionsOrType, decoratorName);\n        }\n        else {\n            options = optionsOrType;\n        }\n        options = options !== null && options !== void 0 ? options : {};\n        if (Object.prototype.hasOwnProperty.call(options, 'constructor')) {\n            if (typeThunk !== undefined) {\n                throw new Error('Cannot both define constructor option and type. Only one allowed.');\n            }\n            if (!isValueDefined(options.constructor)) {\n                logError(decoratorName + \": cannot resolve specified property constructor at runtime. \" + LAZY_TYPE_EXPLANATION);\n                return;\n            }\n            var newTypeDescriptor_1 = ensureTypeDescriptor(options.constructor);\n            typeThunk = function () { return newTypeDescriptor_1; };\n            if (isReflectMetadataSupported && !isSubtypeOf(newTypeDescriptor_1.ctor, Reflect.getMetadata('design:type', target, property))) {\n                logWarning(decoratorName + \": detected property type does not match\"\n                    + \" 'constructor' option.\");\n            }\n        }\n        else if (typeThunk !== undefined) {\n        }\n        else if (isReflectMetadataSupported) {\n            var reflectCtor_1 = Reflect.getMetadata('design:type', target, property);\n            if (reflectCtor_1 == null) {\n                logError(decoratorName + \": cannot resolve detected property constructor at runtime. \" + LAZY_TYPE_EXPLANATION);\n                return;\n            }\n            typeThunk = function () { return ensureTypeDescriptor(reflectCtor_1); };\n        }\n        else if (options.deserializer === undefined) {\n            logError(decoratorName + \": Cannot determine type\");\n            return;\n        }\n        var typeToTest = typeThunk === null || typeThunk === void 0 ? void 0 : typeThunk();\n        if (typeToTest !== undefined && isSpecialPropertyType(decoratorName, typeToTest)) {\n            return;\n        }\n        injectMetadataInformation(target, property, {\n            type: typeThunk === undefined\n                ? undefined\n                : function () { return ensureTypeDescriptor(typeThunk()); },\n            emitDefaultValue: options.emitDefaultValue,\n            isRequired: options.isRequired,\n            options: extractOptionBase(options),\n            key: property.toString(),\n            name: (_a = options.name) !== null && _a !== void 0 ? _a : property.toString(),\n            deserializer: options.deserializer,\n            serializer: options.serializer,\n        });\n    };\n}\nfunction isConstructorEqual(type, constructor) {\n    return type instanceof TypeDescriptor ? type.ctor === constructor : type === constructor;\n}\nfunction isSpecialPropertyType(decoratorName, typeDescriptor) {\n    if (!(typeDescriptor instanceof ArrayTypeDescriptor)\n        && isConstructorEqual(typeDescriptor, Array)) {\n        logError(decoratorName + \": property is an Array. Use the jsonArrayMember decorator to\"\n            + \" serialize this property.\");\n        return true;\n    }\n    if (!(typeDescriptor instanceof SetTypeDescriptor) && isConstructorEqual(typeDescriptor, Set)) {\n        logError(decoratorName + \": property is a Set. Use the jsonSetMember decorator to\"\n            + \" serialize this property.\");\n        return true;\n    }\n    if (!(typeDescriptor instanceof MapTypeDescriptor) && isConstructorEqual(typeDescriptor, Map)) {\n        logError(decoratorName + \": property is a Map. Use the jsonMapMember decorator to\"\n            + \" serialize this property.\");\n        return true;\n    }\n    return false;\n}\n//# sourceMappingURL=json-member.js.map","import { JsonObjectMetadata } from './metadata';\nimport { extractOptionBase } from './options-base';\nexport function jsonObject(optionsOrTarget) {\n    var options;\n    if (typeof optionsOrTarget === 'function') {\n        options = {};\n    }\n    else {\n        options = optionsOrTarget !== null && optionsOrTarget !== void 0 ? optionsOrTarget : {};\n    }\n    function decorator(target) {\n        var objectMetadata = JsonObjectMetadata.ensurePresentInPrototype(target.prototype);\n        objectMetadata.isExplicitlyMarked = true;\n        objectMetadata.onDeserializedMethodName = options.onDeserialized;\n        objectMetadata.beforeSerializationMethodName = options.beforeSerialization;\n        if (options.typeResolver != null) {\n            objectMetadata.typeResolver = options.typeResolver;\n        }\n        if (options.typeHintEmitter != null) {\n            objectMetadata.typeHintEmitter = options.typeHintEmitter;\n        }\n        objectMetadata.initializerCallback = options.initializer;\n        if (options.name != null) {\n            objectMetadata.name = options.name;\n        }\n        var optionsBase = extractOptionBase(options);\n        if (optionsBase !== undefined) {\n            objectMetadata.options = optionsBase;\n        }\n        if (options.knownTypes != null) {\n            options.knownTypes\n                .filter(function (knownType) { return Boolean(knownType); })\n                .forEach(function (knownType) { return objectMetadata.knownTypes.add(knownType); });\n        }\n    }\n    if (typeof optionsOrTarget === 'function') {\n        decorator(optionsOrTarget);\n    }\n    else {\n        return decorator;\n    }\n}\n//# sourceMappingURL=json-object.js.map","import { isReflectMetadataSupported, logError, MISSING_REFLECT_CONF_MSG, nameof } from './helpers';\nimport { injectMetadataInformation, } from './metadata';\nimport { extractOptionBase } from './options-base';\nimport { ensureTypeThunk, SetT } from './type-descriptor';\nexport function jsonSetMember(maybeTypeThunk, options) {\n    if (options === void 0) { options = {}; }\n    return function (target, propKey) {\n        var _a;\n        var decoratorName = \"@jsonSetMember on \" + nameof(target.constructor) + \".\" + String(propKey);\n        var typeThunk = ensureTypeThunk(maybeTypeThunk, decoratorName);\n        var reflectedType = isReflectMetadataSupported\n            ? Reflect.getMetadata('design:type', target, propKey)\n            : null;\n        if (reflectedType != null && reflectedType !== Set && reflectedType !== Object) {\n            logError(decoratorName + \": property is not a Set. \" + MISSING_REFLECT_CONF_MSG);\n            return;\n        }\n        injectMetadataInformation(target, propKey, {\n            type: function () { return SetT(typeThunk()); },\n            emitDefaultValue: options.emitDefaultValue,\n            isRequired: options.isRequired,\n            options: extractOptionBase(options),\n            key: propKey.toString(),\n            name: (_a = options.name) !== null && _a !== void 0 ? _a : propKey.toString(),\n            deserializer: options.deserializer,\n            serializer: options.serializer,\n        });\n    };\n}\n//# sourceMappingURL=json-set-member.js.map","import { isDirectlySerializableNativeType, isTypeTypedArray, logError, nameof } from './helpers';\nexport var METADATA_FIELD_KEY = '__typedJsonJsonObjectMetadataInformation__';\nvar JsonObjectMetadata = (function () {\n    function JsonObjectMetadata(classType) {\n        this.dataMembers = new Map();\n        this.knownTypes = new Set();\n        this.knownTypesDeferred = [];\n        this.isExplicitlyMarked = false;\n        this.isHandledWithoutAnnotation = false;\n        this.classType = classType;\n    }\n    JsonObjectMetadata.getJsonObjectName = function (ctor) {\n        var metadata = JsonObjectMetadata.getFromConstructor(ctor);\n        return metadata === undefined ? nameof(ctor) : nameof(metadata.classType);\n    };\n    JsonObjectMetadata.getFromConstructor = function (ctor) {\n        var prototype = ctor.prototype;\n        if (prototype == null) {\n            return;\n        }\n        var metadata;\n        if (Object.prototype.hasOwnProperty.call(prototype, METADATA_FIELD_KEY)) {\n            metadata = prototype[METADATA_FIELD_KEY];\n        }\n        if ((metadata === null || metadata === void 0 ? void 0 : metadata.isExplicitlyMarked) === true) {\n            return metadata;\n        }\n        if (JsonObjectMetadata.doesHandleWithoutAnnotation(ctor)) {\n            var primitiveMeta = new JsonObjectMetadata(ctor);\n            primitiveMeta.isExplicitlyMarked = true;\n            return primitiveMeta;\n        }\n    };\n    JsonObjectMetadata.ensurePresentInPrototype = function (prototype) {\n        if (Object.prototype.hasOwnProperty.call(prototype, METADATA_FIELD_KEY)) {\n            return prototype[METADATA_FIELD_KEY];\n        }\n        var objectMetadata = new JsonObjectMetadata(prototype.constructor);\n        var parentMetadata = prototype[METADATA_FIELD_KEY];\n        if (parentMetadata !== undefined) {\n            parentMetadata.dataMembers.forEach(function (memberMetadata, propKey) {\n                objectMetadata.dataMembers.set(propKey, memberMetadata);\n            });\n            parentMetadata.knownTypes.forEach(function (knownType) {\n                objectMetadata.knownTypes.add(knownType);\n            });\n            objectMetadata.typeResolver = parentMetadata.typeResolver;\n            objectMetadata.typeHintEmitter = parentMetadata.typeHintEmitter;\n        }\n        Object.defineProperty(prototype, METADATA_FIELD_KEY, {\n            enumerable: false,\n            configurable: false,\n            writable: false,\n            value: objectMetadata,\n        });\n        return objectMetadata;\n    };\n    JsonObjectMetadata.getKnownTypeNameFromType = function (constructor) {\n        var metadata = JsonObjectMetadata.getFromConstructor(constructor);\n        return metadata === undefined ? nameof(constructor) : nameof(metadata.classType);\n    };\n    JsonObjectMetadata.doesHandleWithoutAnnotation = function (ctor) {\n        return isDirectlySerializableNativeType(ctor) || isTypeTypedArray(ctor)\n            || ctor === DataView || ctor === ArrayBuffer;\n    };\n    JsonObjectMetadata.prototype.processDeferredKnownTypes = function () {\n        var _this = this;\n        this.knownTypesDeferred.forEach(function (typeThunk) {\n            typeThunk().getTypes().forEach(function (ctor) { return _this.knownTypes.add(ctor); });\n        });\n        this.knownTypesDeferred = [];\n    };\n    return JsonObjectMetadata;\n}());\nexport { JsonObjectMetadata };\nexport function injectMetadataInformation(prototype, propKey, metadata) {\n    var decoratorName = \"@jsonMember on \" + nameof(prototype.constructor) + \".\" + String(propKey);\n    if (typeof prototype === 'function') {\n        logError(decoratorName + \": cannot use a static property.\");\n        return;\n    }\n    if (typeof prototype[propKey] === 'function') {\n        logError(decoratorName + \": cannot use a method property.\");\n        return;\n    }\n    if (metadata == null\n        || (metadata.type === undefined && metadata.deserializer === undefined)) {\n        logError(decoratorName + \": JsonMemberMetadata has unknown type.\");\n        return;\n    }\n    var objectMetadata = JsonObjectMetadata.ensurePresentInPrototype(prototype);\n    if (metadata.deserializer === undefined) {\n        objectMetadata.knownTypesDeferred.push(metadata.type);\n    }\n    Object.keys(metadata)\n        .forEach(function (key) { return (metadata[key] === undefined) && delete metadata[key]; });\n    objectMetadata.dataMembers.set(metadata.name, metadata);\n}\n//# sourceMappingURL=metadata.js.map","import { __assign } from \"tslib\";\nvar kAllOptions = [\n    'preserveNull',\n];\nexport function extractOptionBase(from) {\n    var options = Object.keys(from)\n        .filter(function (key) { return kAllOptions.indexOf(key) > -1; })\n        .reduce(function (obj, key) {\n        obj[key] = from[key];\n        return obj;\n    }, {});\n    return Object.keys(options).length > 0 ? options : undefined;\n}\nexport function getDefaultOptionOf(key) {\n    switch (key) {\n        case 'preserveNull':\n            return false;\n    }\n    return null;\n}\nexport function getOptionValue(key, options) {\n    if (options != null && options[key] != null) {\n        return options[key];\n    }\n    return getDefaultOptionOf(key);\n}\nexport function mergeOptions(existing, moreSpecific) {\n    return moreSpecific == null\n        ? existing\n        : __assign(__assign({}, existing), moreSpecific);\n}\n//# sourceMappingURL=options-base.js.map","import { __assign } from \"tslib\";\nimport { identity, isInstanceOf, isValueDefined, logError, nameof, } from './helpers';\nimport { JsonObjectMetadata } from './metadata';\nimport { getOptionValue, mergeOptions } from './options-base';\nimport { AnyT, ArrayTypeDescriptor, ensureTypeDescriptor, MapTypeDescriptor, SetTypeDescriptor, } from './type-descriptor';\nexport function defaultTypeEmitter(targetObject, sourceObject, expectedSourceType, sourceTypeMetadata) {\n    var _a;\n    if (sourceObject.constructor !== expectedSourceType) {\n        targetObject.__type = (_a = sourceTypeMetadata === null || sourceTypeMetadata === void 0 ? void 0 : sourceTypeMetadata.name) !== null && _a !== void 0 ? _a : nameof(sourceObject.constructor);\n    }\n}\nvar Serializer = (function () {\n    function Serializer() {\n        this.typeHintEmitter = defaultTypeEmitter;\n        this.errorHandler = logError;\n        this.serializationStrategy = new Map([\n            [AnyT.ctor, identity],\n            [Date, identity],\n            [Number, identity],\n            [String, identity],\n            [Boolean, identity],\n            [ArrayBuffer, convertAsArrayBuffer],\n            [DataView, convertAsDataView],\n            [Array, convertAsArray],\n            [Set, convertAsSet],\n            [Map, convertAsMap],\n            [Float32Array, convertAsTypedArray],\n            [Float64Array, convertAsTypedArray],\n            [Int8Array, convertAsTypedArray],\n            [Uint8Array, convertAsTypedArray],\n            [Uint8ClampedArray, convertAsTypedArray],\n            [Int16Array, convertAsTypedArray],\n            [Uint16Array, convertAsTypedArray],\n            [Int32Array, convertAsTypedArray],\n            [Uint32Array, convertAsTypedArray],\n        ]);\n    }\n    Serializer.prototype.setSerializationStrategy = function (type, serializer) {\n        this.serializationStrategy.set(type, serializer);\n    };\n    Serializer.prototype.setTypeHintEmitter = function (typeEmitterCallback) {\n        if (typeof typeEmitterCallback !== 'function') {\n            throw new TypeError('\\'typeEmitterCallback\\' is not a function.');\n        }\n        this.typeHintEmitter = typeEmitterCallback;\n    };\n    Serializer.prototype.getTypeHintEmitter = function () {\n        return this.typeHintEmitter;\n    };\n    Serializer.prototype.setErrorHandler = function (errorHandlerCallback) {\n        if (typeof errorHandlerCallback !== 'function') {\n            throw new TypeError('\\'errorHandlerCallback\\' is not a function.');\n        }\n        this.errorHandler = errorHandlerCallback;\n    };\n    Serializer.prototype.getErrorHandler = function () {\n        return this.errorHandler;\n    };\n    Serializer.prototype.retrievePreserveNull = function (memberOptions) {\n        return getOptionValue('preserveNull', mergeOptions(this.options, memberOptions));\n    };\n    Serializer.prototype.convertSingleValue = function (sourceObject, typeDescriptor, memberName, memberOptions) {\n        if (memberName === void 0) { memberName = 'object'; }\n        if (this.retrievePreserveNull(memberOptions) && sourceObject === null) {\n            return null;\n        }\n        if (!isValueDefined(sourceObject)) {\n            return;\n        }\n        if (!isInstanceOf(sourceObject, typeDescriptor.ctor)) {\n            var expectedName = nameof(typeDescriptor.ctor);\n            var actualName = nameof(sourceObject.constructor);\n            this.errorHandler(new TypeError(\"Could not serialize '\" + memberName + \"': expected '\" + expectedName + \"',\"\n                + (\" got '\" + actualName + \"'.\")));\n            return;\n        }\n        var serializer = this.serializationStrategy.get(typeDescriptor.ctor);\n        if (serializer !== undefined) {\n            return serializer(sourceObject, typeDescriptor, memberName, this, memberOptions);\n        }\n        if (typeof sourceObject === 'object') {\n            return convertAsObject(sourceObject, typeDescriptor, memberName, this, memberOptions);\n        }\n        var error = \"Could not serialize '\" + memberName + \"'; don't know how to serialize type\";\n        if (typeDescriptor.hasFriendlyName()) {\n            error += \" '\" + typeDescriptor.ctor.name + \"'\";\n        }\n        this.errorHandler(new TypeError(error + \".\"));\n    };\n    return Serializer;\n}());\nexport { Serializer };\nfunction convertAsObject(sourceObject, typeDescriptor, memberName, serializer, memberOptions) {\n    var sourceTypeMetadata;\n    var targetObject;\n    var typeHintEmitter = serializer.getTypeHintEmitter();\n    if (sourceObject.constructor !== typeDescriptor.ctor\n        && sourceObject instanceof typeDescriptor.ctor) {\n        sourceTypeMetadata = JsonObjectMetadata.getFromConstructor(sourceObject.constructor);\n    }\n    else {\n        sourceTypeMetadata = JsonObjectMetadata.getFromConstructor(typeDescriptor.ctor);\n    }\n    if (sourceTypeMetadata === undefined) {\n        targetObject = __assign({}, sourceObject);\n    }\n    else {\n        var beforeSerializationMethodName = sourceTypeMetadata.beforeSerializationMethodName;\n        if (beforeSerializationMethodName != null) {\n            if (typeof sourceObject[beforeSerializationMethodName] === 'function') {\n                sourceObject[beforeSerializationMethodName]();\n            }\n            else if (typeof sourceObject.constructor[beforeSerializationMethodName]\n                === 'function') {\n                sourceObject.constructor[beforeSerializationMethodName]();\n            }\n            else {\n                serializer.getErrorHandler()(new TypeError(\"beforeSerialization callback '\"\n                    + (nameof(sourceTypeMetadata.classType) + \".\" + beforeSerializationMethodName)\n                    + \"' is not a method.\"));\n            }\n        }\n        var sourceMeta_1 = sourceTypeMetadata;\n        targetObject = {};\n        var classOptions_1 = mergeOptions(serializer.options, sourceMeta_1.options);\n        if (sourceMeta_1.typeHintEmitter != null) {\n            typeHintEmitter = sourceMeta_1.typeHintEmitter;\n        }\n        sourceMeta_1.dataMembers.forEach(function (objMemberMetadata) {\n            var objMemberOptions = mergeOptions(classOptions_1, objMemberMetadata.options);\n            var serialized;\n            if (objMemberMetadata.serializer != null) {\n                serialized = objMemberMetadata.serializer(sourceObject[objMemberMetadata.key], {\n                    fallback: function (so, td) { return serializer.convertSingleValue(so, ensureTypeDescriptor(td)); },\n                });\n            }\n            else if (objMemberMetadata.type == null) {\n                throw new TypeError(\"Could not serialize \" + objMemberMetadata.name + \", there is\"\n                    + \" no constructor nor serialization function to use.\");\n            }\n            else {\n                serialized = serializer.convertSingleValue(sourceObject[objMemberMetadata.key], objMemberMetadata.type(), nameof(sourceMeta_1.classType) + \".\" + objMemberMetadata.key, objMemberOptions);\n            }\n            if ((serializer.retrievePreserveNull(objMemberOptions) && serialized === null)\n                || isValueDefined(serialized)) {\n                targetObject[objMemberMetadata.name] = serialized;\n            }\n        });\n    }\n    typeHintEmitter(targetObject, sourceObject, typeDescriptor.ctor, sourceTypeMetadata);\n    return targetObject;\n}\nfunction convertAsArray(sourceObject, typeDescriptor, memberName, serializer, memberOptions) {\n    if (!(typeDescriptor instanceof ArrayTypeDescriptor)) {\n        throw new TypeError(\"Could not serialize \" + memberName + \" as Array: incorrect TypeDescriptor detected, please\"\n            + ' use proper annotation or function for this type');\n    }\n    if (typeDescriptor.elementType == null) {\n        throw new TypeError(\"Could not serialize \" + memberName + \" as Array: missing element type definition.\");\n    }\n    sourceObject.forEach(function (element, i) {\n        if (!(serializer.retrievePreserveNull(memberOptions) && element === null)\n            && !isInstanceOf(element, typeDescriptor.elementType.ctor)) {\n            var expectedTypeName = nameof(typeDescriptor.elementType.ctor);\n            var actualTypeName = element && nameof(element.constructor);\n            throw new TypeError(\"Could not serialize \" + memberName + \"[\" + i + \"]:\"\n                + (\" expected '\" + expectedTypeName + \"', got '\" + actualTypeName + \"'.\"));\n        }\n    });\n    return sourceObject.map(function (element, i) {\n        return serializer.convertSingleValue(element, typeDescriptor.elementType, memberName + \"[\" + i + \"]\", memberOptions);\n    });\n}\nfunction convertAsSet(sourceObject, typeDescriptor, memberName, serializer, memberOptions) {\n    if (!(typeDescriptor instanceof SetTypeDescriptor)) {\n        throw new TypeError(\"Could not serialize \" + memberName + \" as Set: incorrect TypeDescriptor detected, please\"\n            + ' use proper annotation or function for this type');\n    }\n    if (typeDescriptor.elementType == null) {\n        throw new TypeError(\"Could not serialize \" + memberName + \" as Set: missing element type definition.\");\n    }\n    memberName += '[]';\n    var resultArray = [];\n    sourceObject.forEach(function (element) {\n        var resultElement = serializer.convertSingleValue(element, typeDescriptor.elementType, memberName, memberOptions);\n        if (!isValueDefined(element) || isValueDefined(resultElement)) {\n            resultArray.push(resultElement);\n        }\n    });\n    return resultArray;\n}\nfunction convertAsMap(sourceObject, typeDescriptor, memberName, serializer, memberOptions) {\n    if (!(typeDescriptor instanceof MapTypeDescriptor)) {\n        throw new TypeError(\"Could not serialize \" + memberName + \" as Map: incorrect TypeDescriptor detected, please\"\n            + ' use proper annotation or function for this type');\n    }\n    if (typeDescriptor.valueType == null) {\n        throw new TypeError(\"Could not serialize \" + memberName + \" as Map: missing value type definition.\");\n    }\n    if (typeDescriptor.keyType == null) {\n        throw new TypeError(\"Could not serialize \" + memberName + \" as Map: missing key type definition.\");\n    }\n    var keyMemberName = memberName + \"[].key\";\n    var valueMemberName = memberName + \"[].value\";\n    var resultShape = typeDescriptor.getCompleteOptions().shape;\n    var result = resultShape === 1 ? {} : [];\n    var preserveNull = serializer.retrievePreserveNull(memberOptions);\n    sourceObject.forEach(function (value, key) {\n        var resultKeyValuePairObj = {\n            key: serializer.convertSingleValue(key, typeDescriptor.keyType, keyMemberName, memberOptions),\n            value: serializer.convertSingleValue(value, typeDescriptor.valueType, valueMemberName, memberOptions),\n        };\n        var keyDefined = isValueDefined(resultKeyValuePairObj.key);\n        var valueDefined = (resultKeyValuePairObj.value === null && preserveNull)\n            || isValueDefined(resultKeyValuePairObj.value);\n        if (keyDefined && valueDefined) {\n            if (resultShape === 1) {\n                result[resultKeyValuePairObj.key] = resultKeyValuePairObj.value;\n            }\n            else {\n                result.push(resultKeyValuePairObj);\n            }\n        }\n    });\n    return result;\n}\nfunction convertAsTypedArray(sourceObject) {\n    return Array.from(sourceObject);\n}\nfunction convertAsArrayBuffer(buffer) {\n    return Array.from(new Uint16Array(buffer))\n        .map(function (charCode) { return String.fromCharCode(charCode); }).join('');\n}\nfunction convertAsDataView(dataView) {\n    return convertAsArrayBuffer(dataView.buffer);\n}\n//# sourceMappingURL=serializer.js.map","import { __extends } from \"tslib\";\nimport { LAZY_TYPE_EXPLANATION } from './helpers';\nvar TypeDescriptor = (function () {\n    function TypeDescriptor(ctor) {\n        this.ctor = ctor;\n    }\n    TypeDescriptor.prototype.getTypes = function () {\n        return [this.ctor];\n    };\n    TypeDescriptor.prototype.hasFriendlyName = function () {\n        return this.ctor.name !== 'Object';\n    };\n    return TypeDescriptor;\n}());\nexport { TypeDescriptor };\nvar ConcreteTypeDescriptor = (function (_super) {\n    __extends(ConcreteTypeDescriptor, _super);\n    function ConcreteTypeDescriptor(ctor) {\n        return _super.call(this, ctor) || this;\n    }\n    return ConcreteTypeDescriptor;\n}(TypeDescriptor));\nexport { ConcreteTypeDescriptor };\nvar GenericTypeDescriptor = (function (_super) {\n    __extends(GenericTypeDescriptor, _super);\n    function GenericTypeDescriptor(ctor) {\n        return _super.call(this, ctor) || this;\n    }\n    return GenericTypeDescriptor;\n}(TypeDescriptor));\nexport { GenericTypeDescriptor };\nvar ArrayTypeDescriptor = (function (_super) {\n    __extends(ArrayTypeDescriptor, _super);\n    function ArrayTypeDescriptor(elementType) {\n        var _this = _super.call(this, Array) || this;\n        _this.elementType = elementType;\n        return _this;\n    }\n    ArrayTypeDescriptor.prototype.getTypes = function () {\n        return _super.prototype.getTypes.call(this).concat(this.elementType.getTypes());\n    };\n    return ArrayTypeDescriptor;\n}(GenericTypeDescriptor));\nexport { ArrayTypeDescriptor };\nexport function ArrayT(elementType) {\n    return new ArrayTypeDescriptor(ensureTypeDescriptor(elementType));\n}\nvar SetTypeDescriptor = (function (_super) {\n    __extends(SetTypeDescriptor, _super);\n    function SetTypeDescriptor(elementType) {\n        var _this = _super.call(this, Set) || this;\n        _this.elementType = elementType;\n        return _this;\n    }\n    SetTypeDescriptor.prototype.getTypes = function () {\n        return _super.prototype.getTypes.call(this).concat(this.elementType.getTypes());\n    };\n    return SetTypeDescriptor;\n}(GenericTypeDescriptor));\nexport { SetTypeDescriptor };\nexport function SetT(elementType) {\n    return new SetTypeDescriptor(ensureTypeDescriptor(elementType));\n}\nvar MapTypeDescriptor = (function (_super) {\n    __extends(MapTypeDescriptor, _super);\n    function MapTypeDescriptor(keyType, valueType, options) {\n        var _this = _super.call(this, Map) || this;\n        _this.keyType = keyType;\n        _this.valueType = valueType;\n        _this.options = options;\n        return _this;\n    }\n    MapTypeDescriptor.prototype.getTypes = function () {\n        return _super.prototype.getTypes.call(this).concat(this.keyType.getTypes(), this.valueType.getTypes());\n    };\n    MapTypeDescriptor.prototype.getCompleteOptions = function () {\n        var _a, _b;\n        return {\n            shape: (_b = (_a = this.options) === null || _a === void 0 ? void 0 : _a.shape) !== null && _b !== void 0 ? _b : 0,\n        };\n    };\n    return MapTypeDescriptor;\n}(GenericTypeDescriptor));\nexport { MapTypeDescriptor };\nexport function MapT(keyType, valueType, options) {\n    return new MapTypeDescriptor(ensureTypeDescriptor(keyType), ensureTypeDescriptor(valueType), options);\n}\nexport var AnyT = new ConcreteTypeDescriptor(function () { return undefined; });\nexport function isTypelike(type) {\n    return type != null && (typeof type === 'function' || type instanceof TypeDescriptor);\n}\nexport function isTypeThunk(candidate) {\n    return typeof candidate === 'function' && candidate.name === '';\n}\nexport function ensureTypeDescriptor(type) {\n    return type instanceof TypeDescriptor ? type : new ConcreteTypeDescriptor(type);\n}\nexport function ensureTypeThunk(typeThunkOrSerializable, decoratorName) {\n    if (typeThunkOrSerializable == null) {\n        throw new Error(\"No type given on \" + decoratorName + \". \" + LAZY_TYPE_EXPLANATION);\n    }\n    if (isTypeThunk(typeThunkOrSerializable)) {\n        return typeThunkOrSerializable;\n    }\n    return function () { return typeThunkOrSerializable; };\n}\n//# sourceMappingURL=type-descriptor.js.map","const randomUUID = typeof crypto !== 'undefined' && crypto.randomUUID && crypto.randomUUID.bind(crypto);\nexport default {\n  randomUUID\n};","import validate from './validate.js';\n\nfunction parse(uuid) {\n  if (!validate(uuid)) {\n    throw TypeError('Invalid UUID');\n  }\n\n  let v;\n  const arr = new Uint8Array(16); // Parse ########-....-....-....-............\n\n  arr[0] = (v = parseInt(uuid.slice(0, 8), 16)) >>> 24;\n  arr[1] = v >>> 16 & 0xff;\n  arr[2] = v >>> 8 & 0xff;\n  arr[3] = v & 0xff; // Parse ........-####-....-....-............\n\n  arr[4] = (v = parseInt(uuid.slice(9, 13), 16)) >>> 8;\n  arr[5] = v & 0xff; // Parse ........-....-####-....-............\n\n  arr[6] = (v = parseInt(uuid.slice(14, 18), 16)) >>> 8;\n  arr[7] = v & 0xff; // Parse ........-....-....-####-............\n\n  arr[8] = (v = parseInt(uuid.slice(19, 23), 16)) >>> 8;\n  arr[9] = v & 0xff; // Parse ........-....-....-....-############\n  // (Use \"/\" to avoid 32-bit truncation when bit-shifting high-order bytes)\n\n  arr[10] = (v = parseInt(uuid.slice(24, 36), 16)) / 0x10000000000 & 0xff;\n  arr[11] = v / 0x100000000 & 0xff;\n  arr[12] = v >>> 24 & 0xff;\n  arr[13] = v >>> 16 & 0xff;\n  arr[14] = v >>> 8 & 0xff;\n  arr[15] = v & 0xff;\n  return arr;\n}\n\nexport default parse;","export default /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;","// Unique ID creation requires a high quality random # generator. In the browser we therefore\n// require the crypto API and do not support built-in fallback to lower quality random number\n// generators (like Math.random()).\nlet getRandomValues;\nconst rnds8 = new Uint8Array(16);\nexport default function rng() {\n  // lazy load so that environments that need to polyfill have a chance to do so\n  if (!getRandomValues) {\n    // getRandomValues needs to be invoked in a context where \"this\" is a Crypto implementation.\n    getRandomValues = typeof crypto !== 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto);\n\n    if (!getRandomValues) {\n      throw new Error('crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported');\n    }\n  }\n\n  return getRandomValues(rnds8);\n}","// Adapted from Chris Veness' SHA1 code at\n// http://www.movable-type.co.uk/scripts/sha1.html\nfunction f(s, x, y, z) {\n  switch (s) {\n    case 0:\n      return x & y ^ ~x & z;\n\n    case 1:\n      return x ^ y ^ z;\n\n    case 2:\n      return x & y ^ x & z ^ y & z;\n\n    case 3:\n      return x ^ y ^ z;\n  }\n}\n\nfunction ROTL(x, n) {\n  return x << n | x >>> 32 - n;\n}\n\nfunction sha1(bytes) {\n  const K = [0x5a827999, 0x6ed9eba1, 0x8f1bbcdc, 0xca62c1d6];\n  const H = [0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0];\n\n  if (typeof bytes === 'string') {\n    const msg = unescape(encodeURIComponent(bytes)); // UTF8 escape\n\n    bytes = [];\n\n    for (let i = 0; i < msg.length; ++i) {\n      bytes.push(msg.charCodeAt(i));\n    }\n  } else if (!Array.isArray(bytes)) {\n    // Convert Array-like to Array\n    bytes = Array.prototype.slice.call(bytes);\n  }\n\n  bytes.push(0x80);\n  const l = bytes.length / 4 + 2;\n  const N = Math.ceil(l / 16);\n  const M = new Array(N);\n\n  for (let i = 0; i < N; ++i) {\n    const arr = new Uint32Array(16);\n\n    for (let j = 0; j < 16; ++j) {\n      arr[j] = bytes[i * 64 + j * 4] << 24 | bytes[i * 64 + j * 4 + 1] << 16 | bytes[i * 64 + j * 4 + 2] << 8 | bytes[i * 64 + j * 4 + 3];\n    }\n\n    M[i] = arr;\n  }\n\n  M[N - 1][14] = (bytes.length - 1) * 8 / Math.pow(2, 32);\n  M[N - 1][14] = Math.floor(M[N - 1][14]);\n  M[N - 1][15] = (bytes.length - 1) * 8 & 0xffffffff;\n\n  for (let i = 0; i < N; ++i) {\n    const W = new Uint32Array(80);\n\n    for (let t = 0; t < 16; ++t) {\n      W[t] = M[i][t];\n    }\n\n    for (let t = 16; t < 80; ++t) {\n      W[t] = ROTL(W[t - 3] ^ W[t - 8] ^ W[t - 14] ^ W[t - 16], 1);\n    }\n\n    let a = H[0];\n    let b = H[1];\n    let c = H[2];\n    let d = H[3];\n    let e = H[4];\n\n    for (let t = 0; t < 80; ++t) {\n      const s = Math.floor(t / 20);\n      const T = ROTL(a, 5) + f(s, b, c, d) + e + K[s] + W[t] >>> 0;\n      e = d;\n      d = c;\n      c = ROTL(b, 30) >>> 0;\n      b = a;\n      a = T;\n    }\n\n    H[0] = H[0] + a >>> 0;\n    H[1] = H[1] + b >>> 0;\n    H[2] = H[2] + c >>> 0;\n    H[3] = H[3] + d >>> 0;\n    H[4] = H[4] + e >>> 0;\n  }\n\n  return [H[0] >> 24 & 0xff, H[0] >> 16 & 0xff, H[0] >> 8 & 0xff, H[0] & 0xff, H[1] >> 24 & 0xff, H[1] >> 16 & 0xff, H[1] >> 8 & 0xff, H[1] & 0xff, H[2] >> 24 & 0xff, H[2] >> 16 & 0xff, H[2] >> 8 & 0xff, H[2] & 0xff, H[3] >> 24 & 0xff, H[3] >> 16 & 0xff, H[3] >> 8 & 0xff, H[3] & 0xff, H[4] >> 24 & 0xff, H[4] >> 16 & 0xff, H[4] >> 8 & 0xff, H[4] & 0xff];\n}\n\nexport default sha1;","import validate from './validate.js';\n/**\n * Convert array of 16 byte values to UUID string format of the form:\n * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\n */\n\nconst byteToHex = [];\n\nfor (let i = 0; i < 256; ++i) {\n  byteToHex.push((i + 0x100).toString(16).slice(1));\n}\n\nexport function unsafeStringify(arr, offset = 0) {\n  // Note: Be careful editing this code!  It's been tuned for performance\n  // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434\n  return (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();\n}\n\nfunction stringify(arr, offset = 0) {\n  const uuid = unsafeStringify(arr, offset); // Consistency check for valid UUID.  If this throws, it's likely due to one\n  // of the following:\n  // - One or more input array values don't map to a hex octet (leading to\n  // \"undefined\" in the uuid)\n  // - Invalid input values for the RFC `version` or `variant` fields\n\n  if (!validate(uuid)) {\n    throw TypeError('Stringified UUID is invalid');\n  }\n\n  return uuid;\n}\n\nexport default stringify;","import { unsafeStringify } from './stringify.js';\nimport parse from './parse.js';\n\nfunction stringToBytes(str) {\n  str = unescape(encodeURIComponent(str)); // UTF8 escape\n\n  const bytes = [];\n\n  for (let i = 0; i < str.length; ++i) {\n    bytes.push(str.charCodeAt(i));\n  }\n\n  return bytes;\n}\n\nexport const DNS = '6ba7b810-9dad-11d1-80b4-00c04fd430c8';\nexport const URL = '6ba7b811-9dad-11d1-80b4-00c04fd430c8';\nexport default function v35(name, version, hashfunc) {\n  function generateUUID(value, namespace, buf, offset) {\n    var _namespace;\n\n    if (typeof value === 'string') {\n      value = stringToBytes(value);\n    }\n\n    if (typeof namespace === 'string') {\n      namespace = parse(namespace);\n    }\n\n    if (((_namespace = namespace) === null || _namespace === void 0 ? void 0 : _namespace.length) !== 16) {\n      throw TypeError('Namespace must be array-like (16 iterable integer values, 0-255)');\n    } // Compute hash of namespace and value, Per 4.3\n    // Future: Use spread syntax when supported on all platforms, e.g. `bytes =\n    // hashfunc([...namespace, ... value])`\n\n\n    let bytes = new Uint8Array(16 + value.length);\n    bytes.set(namespace);\n    bytes.set(value, namespace.length);\n    bytes = hashfunc(bytes);\n    bytes[6] = bytes[6] & 0x0f | version;\n    bytes[8] = bytes[8] & 0x3f | 0x80;\n\n    if (buf) {\n      offset = offset || 0;\n\n      for (let i = 0; i < 16; ++i) {\n        buf[offset + i] = bytes[i];\n      }\n\n      return buf;\n    }\n\n    return unsafeStringify(bytes);\n  } // Function#name is not settable on some platforms (#270)\n\n\n  try {\n    generateUUID.name = name; // eslint-disable-next-line no-empty\n  } catch (err) {} // For CommonJS default export support\n\n\n  generateUUID.DNS = DNS;\n  generateUUID.URL = URL;\n  return generateUUID;\n}","import native from './native.js';\nimport rng from './rng.js';\nimport { unsafeStringify } from './stringify.js';\n\nfunction v4(options, buf, offset) {\n  if (native.randomUUID && !buf && !options) {\n    return native.randomUUID();\n  }\n\n  options = options || {};\n  const rnds = options.random || (options.rng || rng)(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n\n  rnds[6] = rnds[6] & 0x0f | 0x40;\n  rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided\n\n  if (buf) {\n    offset = offset || 0;\n\n    for (let i = 0; i < 16; ++i) {\n      buf[offset + i] = rnds[i];\n    }\n\n    return buf;\n  }\n\n  return unsafeStringify(rnds);\n}\n\nexport default v4;","import v35 from './v35.js';\nimport sha1 from './sha1.js';\nconst v5 = v35('v5', 0x50, sha1);\nexport default v5;","import REGEX from './regex.js';\n\nfunction validate(uuid) {\n  return typeof uuid === 'string' && REGEX.test(uuid);\n}\n\nexport default validate;","/* (ignored) */","/* (ignored) */","import Threads from \"./dist/index.js\"\n\nexport const registerSerializer = Threads.registerSerializer\nexport const spawn = Threads.spawn\nexport const BlobWorker = Threads.BlobWorker\nexport const DefaultSerializer = Threads.DefaultSerializer\nexport const Pool = Threads.Pool\nexport const Thread = Threads.Thread\nexport const Transfer = Threads.Transfer\nexport const Worker = Threads.Worker\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\tid: moduleId,\n\t\tloaded: false,\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Flag the module as loaded\n\tmodule.loaded = true;\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n// expose the module cache\n__webpack_require__.c = __webpack_module_cache__;\n\n","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.g = (function() {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","__webpack_require__.nmd = (module) => {\n\tmodule.paths = [];\n\tif (!module.children) module.children = [];\n\treturn module;\n};","","// module cache are used so entry inlining is disabled\n// startup\n// Load entry module and return exports\nvar __webpack_exports__ = __webpack_require__(__webpack_require__.s = \"./dist/esm5/index.js\");\n",""],"names":[],"sourceRoot":""}